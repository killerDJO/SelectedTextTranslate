; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	C:\Users\Евгений\Dropbox\Projects\SelectedTextTranslate\SelectedTextTranslate\jsoncpp\src\lib_json\json_reader.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD

PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
PUBLIC	?all@Features@Json@@SA?AV12@XZ			; Json::Features::all
PUBLIC	?strictMode@Features@Json@@SA?AV12@XZ		; Json::Features::strictMode
PUBLIC	??0Features@Json@@QAE@XZ			; Json::Features::Features
PUBLIC	??4Features@Json@@QAEAAV01@ABV01@@Z		; Json::Features::operator=
PUBLIC	_hypot
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Clrcont@_Iterator_base12@std@@QAEXXZ		; std::_Iterator_base12::_Clrcont
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ	; std::_Iterator_base12::_Getpnext
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ; std::allocator<char>::select_on_container_copy_construction
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Change_alloc
PUBLIC	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z		; std::_Debug_range<char const *>
PUBLIC	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z		; std::_Debug_pointer<char>
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	??0StaticString@Json@@QAE@PBD@Z			; Json::StaticString::StaticString
PUBLIC	??BStaticString@Json@@QBEPBDXZ			; Json::StaticString::operator char const *
PUBLIC	?c_str@StaticString@Json@@QBEPBDXZ		; Json::StaticString::c_str
PUBLIC	??4StaticString@Json@@QAEAAV01@ABV01@@Z		; Json::StaticString::operator=
PUBLIC	??_FValue@Json@@QAEXXZ				; Json::Value::`default constructor closure'
PUBLIC	??0Reader@Json@@QAE@XZ				; Json::Reader::Reader
PUBLIC	??0Reader@Json@@QAE@ABVFeatures@1@@Z		; Json::Reader::Reader
PUBLIC	?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
PUBLIC	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z	; Json::Reader::parse
PUBLIC	?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
PUBLIC	?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Reader::getFormatedErrorMessages
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	??1ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::~ErrorInfo
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z		; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z	; Json::Reader::ErrorInfo::operator=
PUBLIC	??_GErrorInfo@Reader@Json@@QAEPAXI@Z		; Json::Reader::ErrorInfo::`scalar deleting destructor'
PUBLIC	?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ; Json::Reader::expectToken
PUBLIC	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readToken
PUBLIC	?skipSpaces@Reader@Json@@AAEXXZ			; Json::Reader::skipSpaces
PUBLIC	?match@Reader@Json@@AAE_NPBDH@Z			; Json::Reader::match
PUBLIC	?readComment@Reader@Json@@AAE_NXZ		; Json::Reader::readComment
PUBLIC	?readCStyleComment@Reader@Json@@AAE_NXZ		; Json::Reader::readCStyleComment
PUBLIC	?readCppStyleComment@Reader@Json@@AAE_NXZ	; Json::Reader::readCppStyleComment
PUBLIC	?readString@Reader@Json@@AAE_NXZ		; Json::Reader::readString
PUBLIC	?readNumber@Reader@Json@@AAEXXZ			; Json::Reader::readNumber
PUBLIC	?readValue@Reader@Json@@AAE_NXZ			; Json::Reader::readValue
PUBLIC	?readObject@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readObject
PUBLIC	?readArray@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readArray
PUBLIC	?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeNumber
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeString
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
PUBLIC	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeDouble
PUBLIC	?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeCodePoint
PUBLIC	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
PUBLIC	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
PUBLIC	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
PUBLIC	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
PUBLIC	?currentValue@Reader@Json@@AAEAAVValue@2@XZ	; Json::Reader::currentValue
PUBLIC	?getNextChar@Reader@Json@@AAEDXZ		; Json::Reader::getNextChar
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ; Json::Reader::getLocationLineAndColumn
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
PUBLIC	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
PUBLIC	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens
PUBLIC	?select_on_container_copy_construction@?$allocator@PAVValue@Json@@@std@@QBE?AV12@XZ ; std::allocator<Json::Value *>::select_on_container_copy_construction
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@XZ	; std::allocator<Json::Value *>::allocator<Json::Value *>
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
PUBLIC	?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::deallocate
PUBLIC	?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::allocate
PUBLIC	?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z ; std::allocator<Json::Value *>::construct
PUBLIC	?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ; std::allocator<Json::Value *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SA?AV?$allocator@PAVValue@Json@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<Json::Value *> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Json::Value *> >::max_size
PUBLIC	?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::deallocate
PUBLIC	?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::deallocate
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Deque_val<std::_Deque_simple_types<Json::Value *> >
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
PUBLIC	??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::~_Deque_val<std::_Deque_simple_types<Json::Value *> >
PUBLIC	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??1?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	?_Change_alloc@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Change_alloc
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Free_proxy
PUBLIC	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
PUBLIC	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
PUBLIC	??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=
PUBLIC	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
PUBLIC	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
PUBLIC	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
PUBLIC	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
PUBLIC	?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter
PUBLIC	?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
PUBLIC	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
PUBLIC	?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
PUBLIC	?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_front
PUBLIC	?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front
PUBLIC	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
PUBLIC	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
PUBLIC	?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase
PUBLIC	?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::clear
PUBLIC	?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
PUBLIC	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
PUBLIC	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
PUBLIC	?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Orphan_off
PUBLIC	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=
PUBLIC	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
PUBLIC	?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
PUBLIC	?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
PUBLIC	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
PUBLIC	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	?select_on_container_copy_construction@?$allocator@VErrorInfo@Reader@Json@@@std@@QBE?AV12@XZ ; std::allocator<Json::Reader::ErrorInfo>::select_on_container_copy_construction
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
PUBLIC	?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::deallocate
PUBLIC	?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::allocate
PUBLIC	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct
PUBLIC	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct
PUBLIC	?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ; std::allocator<Json::Reader::ErrorInfo>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA?AV?$allocator@VErrorInfo@Reader@Json@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::deallocate
PUBLIC	?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
PUBLIC	?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::deallocate
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
PUBLIC	??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::~_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
PUBLIC	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	?_Change_alloc@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Change_alloc
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Free_proxy
PUBLIC	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
PUBLIC	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
PUBLIC	?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter
PUBLIC	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
PUBLIC	?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
PUBLIC	?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
PUBLIC	?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
PUBLIC	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
PUBLIC	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
PUBLIC	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
PUBLIC	?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
PUBLIC	?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
PUBLIC	?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
PUBLIC	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
PUBLIC	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
PUBLIC	?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Orphan_off
PUBLIC	??1Reader@Json@@QAE@XZ				; Json::Reader::~Reader
PUBLIC	??0Reader@Json@@QAE@ABV01@@Z			; Json::Reader::Reader
PUBLIC	??4Reader@Json@@QAEAAV01@ABV01@@Z		; Json::Reader::operator=
PUBLIC	??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z ; Json::operator>>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
PUBLIC	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
PUBLIC	??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
PUBLIC	??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
PUBLIC	??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
PUBLIC	??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
PUBLIC	??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
PUBLIC	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
PUBLIC	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator<
PUBLIC	?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Compat
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Setcont
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
PUBLIC	??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::move<Json::Value * &>
PUBLIC	??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$?9V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ; std::operator!=<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked
PUBLIC	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
PUBLIC	??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
PUBLIC	??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
PUBLIC	??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
PUBLIC	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
PUBLIC	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>
PUBLIC	??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
PUBLIC	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
PUBLIC	??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
PUBLIC	??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
PUBLIC	??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
PUBLIC	??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
PUBLIC	??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
PUBLIC	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
PUBLIC	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator<
PUBLIC	?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Compat
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Setcont
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::forward<Json::Value *>
PUBLIC	??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>
PUBLIC	??$?9V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ; std::operator!=<std::allocator<Json::Value *>,std::allocator<Json::Value *> >
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked
PUBLIC	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
PUBLIC	??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
PUBLIC	??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
PUBLIC	??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
PUBLIC	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
PUBLIC	??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-=
PUBLIC	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
PUBLIC	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value *>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::_Wrap_alloc<std::allocator<Json::Value * *> ><std::_Wrap_alloc<std::allocator<Json::Value *> > >
PUBLIC	??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
PUBLIC	??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value * *>
PUBLIC	??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>
PUBLIC	??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
PUBLIC	??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
PUBLIC	??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
PUBLIC	??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
PUBLIC	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
PUBLIC	??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * *> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ; std::_Allocate<Json::Value *>
PUBLIC	??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo *>
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ; std::_Allocate<Json::Value * *>
PUBLIC	??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z ; std::_Iter_cat<char const *>
PUBLIC	??$_Debug_range2@PBD@std@@YAXPBD0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<char const *>
PUBLIC	??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator==<std::allocator<char>,std::allocator<char> >
PUBLIC	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator==<char,char>
PUBLIC	??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<Json::Reader::ErrorInfo const &>
PUBLIC	??$?8V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ; std::operator==<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??$?8VErrorInfo@Reader@Json@@V012@@std@@YA_NABV?$allocator@VErrorInfo@Reader@Json@@@0@0@Z ; std::operator==<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
PUBLIC	??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
PUBLIC	??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
PUBLIC	??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
PUBLIC	??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
PUBLIC	??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
PUBLIC	??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
PUBLIC	??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
PUBLIC	??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z ; std::forward<Json::Reader::ErrorInfo const &>
PUBLIC	??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$emplace_back@ABQAVValue@Json@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::emplace_back<Json::Value * const &>
PUBLIC	??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>
PUBLIC	??$?8V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ; std::operator==<std::allocator<Json::Value *>,std::allocator<Json::Value *> >
PUBLIC	??$?8PAVValue@Json@@PAV01@@std@@YA_NABV?$allocator@PAVValue@Json@@@0@0@Z ; std::operator==<Json::Value *,Json::Value *>
PUBLIC	??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
PUBLIC	??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
PUBLIC	??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
PUBLIC	??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
PUBLIC	??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
PUBLIC	??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
PUBLIC	??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
PUBLIC	??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value *>
PUBLIC	??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value * *>
PUBLIC	??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>
PUBLIC	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ; std::_Unchecked<Json::Reader::ErrorInfo * *>
PUBLIC	??$_Uninit_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
PUBLIC	??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z ; std::_Rechecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
PUBLIC	??$_Val_type@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ; std::_Val_type<Json::Reader::ErrorInfo * *>
PUBLIC	??$_Ptr_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
PUBLIC	??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,unsigned int,Json::Reader::ErrorInfo *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
PUBLIC	??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ; std::_Unchecked<Json::Value * * *>
PUBLIC	??$_Uninit_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninit_copy<Json::Value * * *,Json::Value * * *,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
PUBLIC	??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z ; std::_Rechecked<Json::Value * * *,Json::Value * * *>
PUBLIC	??$_Val_type@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ; std::_Val_type<Json::Value * * *>
PUBLIC	??$_Ptr_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value * *,Json::Value * *>
PUBLIC	??$_Uninit_def_fill_n@PAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::Value * *,unsigned int,Json::Value * *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * *> > >
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$construct@PAVValue@Json@@ABQAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>
PUBLIC	??$construct@VErrorInfo@Reader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>
PUBLIC	??$_Iter_cat@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Iter_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
PUBLIC	??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
PUBLIC	??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
PUBLIC	??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
PUBLIC	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
PUBLIC	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
PUBLIC	??$_Reverse@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0Ubidirectional_iterator_tag@0@@Z ; std::_Reverse<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::distance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@H@Z ; std::advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$forward@ABQAVValue@Json@@@std@@YAABQAVValue@Json@@ABQAV12@@Z ; std::forward<Json::Value * const &>
PUBLIC	??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value *>
PUBLIC	??$_Iter_cat@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Iter_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
PUBLIC	??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
PUBLIC	??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
PUBLIC	??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
PUBLIC	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
PUBLIC	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
PUBLIC	??$_Reverse@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0Ubidirectional_iterator_tag@0@@Z ; std::_Reverse<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::distance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@H@Z ; std::advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>
PUBLIC	??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy<Json::Value *>
PUBLIC	??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy<Json::Value * *>
PUBLIC	??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo>
PUBLIC	??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ; std::move<Json::Reader::ErrorInfo &>
PUBLIC	??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
PUBLIC	??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@IABQAV123@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
PUBLIC	??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo *>
PUBLIC	??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * *,Json::Value * *>
PUBLIC	??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@IABQAPAV12@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
PUBLIC	??$construct@PAVValue@Json@@ABQAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@ABQAV34@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>
PUBLIC	??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Dist_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAPAHV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Dist_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Val_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAPAVErrorInfo@Reader@Json@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Val_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@HVErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@00PAHPAVErrorInfo@Reader@Json@@@Z ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int,Json::Reader::ErrorInfo>
PUBLIC	??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>
PUBLIC	??$_Advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>
PUBLIC	??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Dist_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAPAHV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Dist_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Val_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAPAPAVValue@Json@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Val_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@HPAVValue@Json@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@00PAHPAPAVValue@Json@@@Z ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int,Json::Value *>
PUBLIC	??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>
PUBLIC	??$_Advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>
PUBLIC	??$_Debug_range@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0PB_WI@Z ; std::_Debug_range<Json::Reader::ErrorInfo * *>
PUBLIC	??$_Debug_pointer@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@PB_WI@Z ; std::_Debug_pointer<Json::Reader::ErrorInfo *>
PUBLIC	??$_Debug_range@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0PB_WI@Z ; std::_Debug_range<Json::Value * * *>
PUBLIC	??$_Debug_pointer@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@PB_WI@Z ; std::_Debug_pointer<Json::Value * *>
PUBLIC	??$_Ptr_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@AAV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Ptr_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ; std::swap<Json::Reader::ErrorInfo>
PUBLIC	??$_Ptr_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@AAV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Ptr_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$swap@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z ; std::swap<Json::Value *>
PUBLIC	??$_Iter_cat@PAPAVErrorInfo@Reader@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@@Z ; std::_Iter_cat<Json::Reader::ErrorInfo * *>
PUBLIC	??$_Debug_range2@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<Json::Reader::ErrorInfo * *>
PUBLIC	??$_Iter_cat@PAPAPAVValue@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAPAVValue@Json@@@Z ; std::_Iter_cat<Json::Value * * *>
PUBLIC	??$_Debug_range2@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<Json::Value * * *>
PUBLIC	??$_Move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ; std::_Move<Json::Reader::ErrorInfo &>
PUBLIC	??$_Move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::_Move<Json::Value * &>
PUBLIC	??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; `string'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ ; `string'
PUBLIC	??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ ; `string'
PUBLIC	??_C@_03FFDNHNKN@rue?$AA@			; `string'
PUBLIC	??_C@_04KCECFHEP@alse?$AA@			; `string'
PUBLIC	??_C@_03KNPGGKC@ull?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@3@@Z@4JA ; `Json::Reader::addComment'::`2'::__LINE__Var
PUBLIC	??_C@_1OG@MJGKPHCJ@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AE5?$AE2?$AE3?$AE5?$AE?$DN?$AE8?$AE9?$AA?2?$AAd?$AAr?$AAo?$AAp?$AAb?$AAo?$AAx?$AA?2?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt@ ; `string'
PUBLIC	??_C@_1CC@CHPNCPJ@?$AAc?$AAo?$AAl?$AAl?$AAe?$AAc?$AAt?$AAC?$AAo?$AAm?$AAm?$AAe?$AAn?$AAt?$AAs?$AA_?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@HJPILKKO@?$AAl?$AAa?$AAs?$AAt?$AAV?$AAa?$AAl?$AAu?$AAe?$AA_?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ ; `string'
PUBLIC	??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ ; `string'
PUBLIC	??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ ; `string'
PUBLIC	??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ ; `string'
PUBLIC	??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ ; `string'
PUBLIC	??_C@_01GEODFPGF@?8?$AA@			; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf?$AA@			; `string'
PUBLIC	??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ ; `string'
PUBLIC	??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ ; `string'
PUBLIC	??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_02KAOAMBHJ@?$CK?5?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@	; `string'
PUBLIC	??_C@_04JBAOJHKB@See?5?$AA@			; `string'
PUBLIC	??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1EE@INPCGGNP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; `string'
PUBLIC	??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; `string'
PUBLIC	??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_1BAA@PADCGMJP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EC@CEAHEOFL@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1BAC@OLCLAAO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@IIKPBBHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa?$AAn@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_1EK@DEGNOCIK@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr@ ; `string'
PUBLIC	??_C@_1BAC@HLMALIEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1DK@CNDLFKCJ@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; `string'
PUBLIC	??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; `string'
PUBLIC	??_C@_1PK@ILLLEIAJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1OM@OEJNAKAK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1OO@NDCHBGNA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1OG@LDMEFICC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EI@ODOAHAHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; `string'
PUBLIC	??_C@_1OO@KGFFBOJD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EC@IJLEGPJO@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1BAC@PNIAAMMP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1OO@FFGHKCFC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@0000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp___hypot:PROC
EXTRN	__imp__sscanf:PROC
EXTRN	__imp__sprintf:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	__imp_?_Debug_message@std@@YAXPB_W0I@Z:PROC
EXTRN	__imp_??0_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_??1_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ:PROC
EXTRN	__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	__imp_??0id@locale@std@@QAE@I@Z:PROC
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	__imp_?_Syserror_map@std@@YAPBDH@Z:PROC
EXTRN	__imp_?_Winerror_map@std@@YAPBDH@Z:PROC
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:PROC
EXTRN	??0Value@Json@@QAE@W4ValueType@1@@Z:PROC	; Json::Value::Value
EXTRN	??0Value@Json@@QAE@H@Z:PROC			; Json::Value::Value
EXTRN	??0Value@Json@@QAE@I@Z:PROC			; Json::Value::Value
EXTRN	??0Value@Json@@QAE@N@Z:PROC			; Json::Value::Value
EXTRN	??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Json::Value::Value
EXTRN	??0Value@Json@@QAE@_N@Z:PROC			; Json::Value::Value
EXTRN	??1Value@Json@@QAE@XZ:PROC			; Json::Value::~Value
EXTRN	??4Value@Json@@QAEAAV01@ABV01@@Z:PROC		; Json::Value::operator=
EXTRN	?isArray@Value@Json@@QBE_NXZ:PROC		; Json::Value::isArray
EXTRN	?isObject@Value@Json@@QBE_NXZ:PROC		; Json::Value::isObject
EXTRN	??AValue@Json@@QAEAAV01@I@Z:PROC		; Json::Value::operator[]
EXTRN	??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Json::Value::operator[]
EXTRN	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z:PROC ; Json::Value::setComment
EXTRN	__imp___wassert:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?minInt@Value@Json@@2HB:DWORD			; Json::Value::minInt
EXTRN	?maxInt@Value@Json@@2HB:DWORD			; Json::Value::maxInt
EXTRN	?maxUInt@Value@Json@@2IB:DWORD			; Json::Value::maxUInt
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
_ignore	DB	01H DUP (?)
__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1OO@FFGHKCFC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1OO@FFGHKCFC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'J', 00H, 's', 00H, 'o', 00H, 'n', 00H, ':'
	DB	00H, ':', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H
	DB	' ', 00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BAC@PNIAAMMP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1BAC@PNIAAMMP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'J', 00H, 's', 00H, 'o', 00H, 'n', 00H, ':'
	DB	00H, ':', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, ':', 00H, ':', 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o'
	DB	00H, 'r', 00H, 'I', 00H, 'n', 00H, 'f', 00H, 'o', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o'
	DB	00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '-', 00H, '-', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@IJLEGPJO@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@
CONST	SEGMENT
??_C@_1EC@IJLEGPJO@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@ DB 'd'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'd', 00H
	DB	'e', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1OO@KGFFBOJD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1OO@KGFFBOJD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'J', 00H, 's', 00H, 'o', 00H, 'n', 00H, ':'
	DB	00H, ':', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H
	DB	' ', 00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '+', 00H, '+'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@ODOAHAHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
CONST	SEGMENT
??_C@_1EI@ODOAHAHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ DB 'd'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H, 'i', 00H
	DB	'n', 00H, 's', 00H, 'e', 00H, 'r', 00H, 't', 00H, ' ', 00H, 'i'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's', 00H, 'i'
	DB	00H, 'd', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1OG@LDMEFICC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1OG@LDMEFICC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'J', 00H, 's', 00H, 'o', 00H, 'n', 00H, ':'
	DB	00H, ':', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H
	DB	' ', 00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, '_', 00H, 'C', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, 'a', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1OO@NDCHBGNA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1OO@NDCHBGNA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'J', 00H, 's', 00H, 'o', 00H, 'n', 00H, ':'
	DB	00H, ':', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H
	DB	' ', 00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '+', 00H, '='
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1OM@OEJNAKAK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1OM@OEJNAKAK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'J', 00H, 's', 00H, 'o', 00H, 'n', 00H, ':'
	DB	00H, ':', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H
	DB	' ', 00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1PK@ILLLEIAJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1PK@ILLLEIAJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'J', 00H, 's', 00H, 'o', 00H, 'n', 00H, ':'
	DB	00H, ':', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, ':', 00H, ':', 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o'
	DB	00H, 'r', 00H, 'I', 00H, 'n', 00H, 'f', 00H, 'o', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
CONST	SEGMENT
??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 'A', 00H
	DB	'r', 00H, 'g', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
CONST	SEGMENT
??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ DB 'Standa'
	DB	'rd C++ Libraries Invalid Argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@CNDLFKCJ@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@CNDLFKCJ@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ DB 'd'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'o', 00H
	DB	'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b', 00H, 'l'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BAC@HLMALIEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1BAC@HLMALIEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'J', 00H, 's', 00H, 'o', 00H, 'n', 00H, ':'
	DB	00H, ':', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, ':', 00H, ':', 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o'
	DB	00H, 'r', 00H, 'I', 00H, 'n', 00H, 'f', 00H, 'o', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o'
	DB	00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '+', 00H, '=', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@DEGNOCIK@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr@
CONST	SEGMENT
??_C@_1EK@DEGNOCIK@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr@ DB 'd'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '+', 00H, ' ', 00H, 'o', 00H, 'f', 00H, 'f', 00H
	DB	's', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@IIKPBBHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa?$AAn@
CONST	SEGMENT
??_C@_1EG@IIKPBBHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa?$AAn@ DB 'd'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's', 00H, 'i', 00H, 'd'
	DB	00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@ DB 'd'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H, 'e', 00H
	DB	'm', 00H, 'p', 00H, 't', 00H, 'y', 00H, ' ', 00H, 'b', 00H, 'e'
	DB	00H, 'f', 00H, 'o', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'p', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BAC@OLCLAAO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1BAC@OLCLAAO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'J', 00H, 's', 00H, 'o', 00H, 'n', 00H, ':'
	DB	00H, ':', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, ':', 00H, ':', 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o'
	DB	00H, 'r', 00H, 'I', 00H, 'n', 00H, 'f', 00H, 'o', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o'
	DB	00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '+', 00H, '+', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@CEAHEOFL@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@
CONST	SEGMENT
??_C@_1EC@CEAHEOFL@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@ DB 'd'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'i', 00H
	DB	'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BAA@PADCGMJP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1BAA@PADCGMJP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'J', 00H, 's', 00H, 'o', 00H, 'n', 00H, ':'
	DB	00H, ':', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, ':', 00H, ':', 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o'
	DB	00H, 'r', 00H, 'I', 00H, 'n', 00H, 'f', 00H, 'o', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o'
	DB	00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '*', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
CONST	SEGMENT
??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'R', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
CONST	SEGMENT
??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ DB 'Stand'
	DB	'ard C++ Libraries Out of Range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@INPCGGNP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1EE@INPCGGNP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl@ DB 'd'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'd', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 'e'
	DB	00H, 'n', 00H, 'c', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'd', 00H, 'e', 00H, 'q'
	DB	00H, 'u', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'i'
	DB	00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 'g', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JBAOJHKB@See?5?$AA@
CONST	SEGMENT
??_C@_04JBAOJHKB@See?5?$AA@ DB 'See ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
CONST	SEGMENT
??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@ DB ' for detail.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAOAMBHJ@?$CK?5?$AA@
CONST	SEGMENT
??_C@_02KAOAMBHJ@?$CK?5?$AA@ DB '* ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ DB 'Line %d, Column '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: hexadecimal digit expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: four digits expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
CONST	SEGMENT
??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ DB 'expecting '
	DB	'another \u token to begin the second half of a unicode surrog'
	DB	'ate pair', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
CONST	SEGMENT
??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ DB 'additional si'
	DB	'x characters expected to parse unicode surrogate pair.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ DB 'Bad escape '
	DB	'sequence in string', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ DB 'Empty esc'
	DB	'ape sequence in string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf?$AA@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf?$AA@ DB '%lf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8?$AA@
CONST	SEGMENT
??_C@_01GEODFPGF@?8?$AA@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
CONST	SEGMENT
??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ DB ''' is not a number.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
CONST	SEGMENT
??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ DB 'Mi'
	DB	'ssing '','' or '']'' in array declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
CONST	SEGMENT
??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ DB 'Missin'
	DB	'g ''}'' or object member name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
CONST	SEGMENT
??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ DB 'Mi'
	DB	'ssing '','' or ''}'' in object declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
CONST	SEGMENT
??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ DB 'Missing '
	DB	''':'' after object member name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@HJPILKKO@?$AAl?$AAa?$AAs?$AAt?$AAV?$AAa?$AAl?$AAu?$AAe?$AA_?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@HJPILKKO@?$AAl?$AAa?$AAs?$AAt?$AAV?$AAa?$AAl?$AAu?$AAe?$AA_?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'l'
	DB	00H, 'a', 00H, 's', 00H, 't', 00H, 'V', 00H, 'a', 00H, 'l', 00H
	DB	'u', 00H, 'e', 00H, '_', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@CHPNCPJ@?$AAc?$AAo?$AAl?$AAl?$AAe?$AAc?$AAt?$AAC?$AAo?$AAm?$AAm?$AAe?$AAn?$AAt?$AAs?$AA_?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@CHPNCPJ@?$AAc?$AAo?$AAl?$AAl?$AAe?$AAc?$AAt?$AAC?$AAo?$AAm?$AAm?$AAe?$AAn?$AAt?$AAs?$AA_?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, 's', 00H, '_', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1OG@MJGKPHCJ@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AE5?$AE2?$AE3?$AE5?$AE?$DN?$AE8?$AE9?$AA?2?$AAd?$AAr?$AAo?$AAp?$AAb?$AAo?$AAx?$AA?2?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt@
CONST	SEGMENT
??_C@_1OG@MJGKPHCJ@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AE5?$AE2?$AE3?$AE5?$AE?$DN?$AE8?$AE9?$AA?2?$AAd?$AAr?$AAo?$AAp?$AAb?$AAo?$AAx?$AA?2?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, '5', 04H, '2', 04H, '3', 04H, '5', 04H, '='
	DB	04H, '8', 04H, '9', 04H, '\', 00H, 'd', 00H, 'r', 00H, 'o', 00H
	DB	'p', 00H, 'b', 00H, 'o', 00H, 'x', 00H, '\', 00H, 'p', 00H, 'r'
	DB	00H, 'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H
	DB	'\', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'e', 00H, 'd', 00H, 't', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	't', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'l', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, '\', 00H, 's', 00H, 'e', 00H, 'l', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, 't', 00H, 'e'
	DB	00H, 'x', 00H, 't', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	's', 00H, 'l', 00H, 'a', 00H, 't', 00H, 'e', 00H, '\', 00H, 'j'
	DB	00H, 's', 00H, 'o', 00H, 'n', 00H, 'c', 00H, 'p', 00H, 'p', 00H
	DB	'\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'l', 00H, 'i'
	DB	00H, 'b', 00H, '_', 00H, 'j', 00H, 's', 00H, 'o', 00H, 'n', 00H
	DB	'\', 00H, 'j', 00H, 's', 00H, 'o', 00H, 'n', 00H, '_', 00H, 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '.', 00H
	DB	'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@3@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@3@@Z@4JA DD 0199H ; `Json::Reader::addComment'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_03KNPGGKC@ull?$AA@
CONST	SEGMENT
??_C@_03KNPGGKC@ull?$AA@ DB 'ull', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCECFHEP@alse?$AA@
CONST	SEGMENT
??_C@_04KCECFHEP@alse?$AA@ DB 'alse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFDNHNKN@rue?$AA@
CONST	SEGMENT
??_C@_03FFDNHNKN@rue?$AA@ DB 'rue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
CONST	SEGMENT
??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ DB 'Syntax err'
	DB	'or: value, object or array expected.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
CONST	SEGMENT
??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ DB 'A valid JS'
	DB	'ON document must be either an array or an object value.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ DB 'I'
	DB	00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H, 'O', 00H
	DB	'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T', 00H, ' '
	DB	00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H, 'P', 00H
	DB	'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H, 't'
	DB	00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z$0
__ehfuncinfo$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$1
__ehfuncinfo$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$1
__ehfuncinfo$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$2
__ehfuncinfo$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z$1
__ehfuncinfo$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
__ehfuncinfo$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z$0
__ehfuncinfo$??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$2
__ehfuncinfo$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z$1
__ehfuncinfo$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
__ehfuncinfo$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
__ehfuncinfo$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
__ehfuncinfo$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$5
	DD	02H
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$2
__ehfuncinfo$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z$0
__ehfuncinfo$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$2
__ehfuncinfo$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$5
	DD	02H
	DD	FLAT:__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$2
__ehfuncinfo$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z$0
__ehfuncinfo$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$2
__ehfuncinfo$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$2
__ehfuncinfo$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$2
__ehfuncinfo$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$29 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$2
__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$28 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$0
__ehfuncinfo$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z DD 019930522H
	DD	016H
	DD	FLAT:__unwindtable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z
	DD	02H
	DD	FLAT:__tryblocktable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z DD 05H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$28
	DD	0dH
	DD	0dH
	DD	0eH
	DD	01H
	DD	FLAT:__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$29
__unwindtable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$6
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$7
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$8
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$10
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$13
	DD	08H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$14
	DD	09H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$15
	DD	0aH
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$16
	DD	09H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$16
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$20
	DD	0fH
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$21
	DD	010H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$22
	DD	011H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$23
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$21
	DD	013H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$23
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$26
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z$0
__ehfuncinfo$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z$0
__ehfuncinfo$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$0
__tryblocktable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$4
__unwindtable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$3
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z$0
__ehfuncinfo$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$29 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$2
__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$28 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$0
__ehfuncinfo$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z DD 019930522H
	DD	016H
	DD	FLAT:__unwindtable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z
	DD	02H
	DD	FLAT:__tryblocktable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z DD 05H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$28
	DD	0dH
	DD	0dH
	DD	0eH
	DD	01H
	DD	FLAT:__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$29
__unwindtable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$6
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$7
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$8
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$10
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$13
	DD	08H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$14
	DD	09H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$15
	DD	0aH
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$16
	DD	09H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$16
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$20
	DD	0fH
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$21
	DD	010H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$22
	DD	011H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$23
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$21
	DD	013H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$23
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$26
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z$0
__ehfuncinfo$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$0
__tryblocktable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$4
__unwindtable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$3
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z$0
__ehfuncinfo$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0
__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3
__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$0
__ehfuncinfo$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$1
__ehfuncinfo$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Reader@Json@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$2
__ehfuncinfo$??0Reader@Json@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z$0
__ehfuncinfo$?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$8
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$10
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$11
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$12
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$16
	DD	0aH
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$17
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$20
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$8
	DD	03H
	DD	FLAT:__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$9
	DD	05H
	DD	FLAT:__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$14
	DD	07H
	DD	FLAT:__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$15
	DD	08H
	DD	FLAT:__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$16
	DD	05H
	DD	FLAT:__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z$0
__ehfuncinfo$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z$0
__ehfuncinfo$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z$0
__ehfuncinfo$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z$0
__ehfuncinfo$?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$8
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$10
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$11
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$12
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$16
	DD	0aH
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$17
	DD	03H
	DD	FLAT:__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$20
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ$1
__ehfuncinfo$?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$8
	DD	03H
	DD	FLAT:__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$9
	DD	05H
	DD	FLAT:__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$14
	DD	07H
	DD	FLAT:__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$15
	DD	08H
	DD	FLAT:__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$16
	DD	05H
	DD	FLAT:__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z$0
__ehfuncinfo$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$1
__ehfuncinfo$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z$0
__ehfuncinfo$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1
__ehfuncinfo$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1
__ehfuncinfo$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$4
__ehfuncinfo$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
__ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$1
__ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$1
__ehfuncinfo$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?readValue@Reader@Json@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$3
__ehfuncinfo$?readValue@Reader@Json@@AAE_NXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?readValue@Reader@Json@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z$0
__ehfuncinfo$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$7
	DD	01H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z$0
__ehfuncinfo$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z$0
__ehfuncinfo$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Reader@Json@@QAE@ABVFeatures@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$2
__ehfuncinfo$??0Reader@Json@@QAE@ABVFeatures@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Reader@Json@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@XZ$3
__ehfuncinfo$??0Reader@Json@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
__ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
__ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z PROC ; std::_Move<Json::Value * &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ENDP ; std::_Move<Json::Value * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z PROC ; std::_Move<Json::Reader::ErrorInfo &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ENDP ; std::_Move<Json::Reader::ErrorInfo &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Debug_range2@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<Json::Value * * *>, COMDAT

; 570  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 571  : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Debug_rang

; 572  : 		{	// check for non-null pointers, valid range
; 573  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@PB_WI@Z ; std::_Debug_pointer<Json::Value * *>
	add	esp, 12					; 0000000cH

; 574  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@PB_WI@Z ; std::_Debug_pointer<Json::Value * *>
	add	esp, 12					; 0000000cH

; 575  : 		if (_Last < _First)

	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jae	SHORT $LN3@Debug_rang

; 576  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Debug_rang:

; 577  : 		}
; 578  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range2@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAPAVValue@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAPAVValue@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAPAVValue@Json@@@Z PROC ; std::_Iter_cat<Json::Value * * *>, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@PAPAPAVValue@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAPAVValue@Json@@@Z ENDP ; std::_Iter_cat<Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Debug_range2@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<Json::Reader::ErrorInfo * *>, COMDAT

; 570  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 571  : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Debug_rang

; 572  : 		{	// check for non-null pointers, valid range
; 573  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@PB_WI@Z ; std::_Debug_pointer<Json::Reader::ErrorInfo *>
	add	esp, 12					; 0000000cH

; 574  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@PB_WI@Z ; std::_Debug_pointer<Json::Reader::ErrorInfo *>
	add	esp, 12					; 0000000cH

; 575  : 		if (_Last < _First)

	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jae	SHORT $LN3@Debug_rang

; 576  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Debug_rang:

; 577  : 		}
; 578  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range2@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAVErrorInfo@Reader@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVErrorInfo@Reader@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Iter_cat<Json::Reader::ErrorInfo * *>, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@PAPAVErrorInfo@Reader@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Iter_cat<Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$swap@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z PROC ; std::swap<Json::Value *>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	??$_Move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::_Move<Json::Value * &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 53   : 	_Left = _Move(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$_Move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::_Move<Json::Value * &>
	add	esp, 4
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 54   : 	_Right = _Move(_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	call	??$_Move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::_Move<Json::Value * &>
	add	esp, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 55   : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@swap
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@swap:
	DD	1
	DD	$LN4@swap
$LN4@swap:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN3@swap
$LN3@swap:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
??$swap@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z ENDP ; std::swap<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 2043 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_impl
$LN2@Copy_impl:
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
$LN3@Copy_impl:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_impl

; 2045 : 		*_Dest = *_First;

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	mov	esi, eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN2@Copy_impl
$LN1@Copy_impl:

; 2046 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2047 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@AAV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@AAV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Ptr_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 414  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 415  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 416  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 417  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@AAV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Ptr_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
__Tmp$ = -64						; size = 44
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z PROC ; std::swap<Json::Reader::ErrorInfo>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	??$_Move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ; std::_Move<Json::Reader::ErrorInfo &>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 53   : 	_Left = _Move(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$_Move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ; std::_Move<Json::Reader::ErrorInfo &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z

; 54   : 	_Right = _Move(_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	call	??$_Move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ; std::_Move<Json::Reader::ErrorInfo &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z

; 55   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@swap
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@swap:
	DD	1
	DD	$LN6@swap
$LN6@swap:
	DD	-64					; ffffffc0H
	DD	44					; 0000002cH
	DD	$LN4@swap
$LN4@swap:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ENDP ; std::swap<Json::Reader::ErrorInfo>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 2043 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_impl
$LN2@Copy_impl:
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
$LN3@Copy_impl:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_impl

; 2045 : 		*_Dest = *_First;

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	mov	ecx, eax
	call	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
	jmp	SHORT $LN2@Copy_impl
$LN1@Copy_impl:

; 2046 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2047 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@AAV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@AAV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Ptr_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 414  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 415  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 416  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 417  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@AAV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Ptr_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@PB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@PB_WI@Z PROC ; std::_Debug_pointer<Json::Value * *>, COMDAT

; 552  : 	{	// test iterator for non-singularity, pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 553  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 554  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_poin:

; 555  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@PB_WI@Z ENDP ; std::_Debug_pointer<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0PB_WI@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_range@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0PB_WI@Z PROC ; std::_Debug_range<Json::Value * * *>, COMDAT

; 583  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 584  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PAPAPAVValue@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAPAVValue@Json@@@Z ; std::_Iter_cat<Json::Value * * *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range2@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<Json::Value * * *>
	add	esp, 20					; 00000014H

; 585  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0PB_WI@Z ENDP ; std::_Debug_range<Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@PB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@PB_WI@Z PROC ; std::_Debug_pointer<Json::Reader::ErrorInfo *>, COMDAT

; 552  : 	{	// test iterator for non-singularity, pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 553  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 554  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_poin:

; 555  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@PB_WI@Z ENDP ; std::_Debug_pointer<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0PB_WI@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_range@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0PB_WI@Z PROC ; std::_Debug_range<Json::Reader::ErrorInfo * *>, COMDAT

; 583  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 584  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PAPAVErrorInfo@Reader@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@@Z ; std::_Iter_cat<Json::Reader::ErrorInfo * *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range2@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<Json::Reader::ErrorInfo * *>
	add	esp, 20					; 00000014H

; 585  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0PB_WI@Z ENDP ; std::_Debug_range<Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>, COMDAT

; 689  : 	{	// increment iterator by offset, random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 690  : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	call	??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=

; 691  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Off$ = 32						; size = 4
___formal$ = 36						; size = 1
??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>, COMDAT

; 741  : 	{	// add to _Off distance between random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Distance2

; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);

	push	745					; 000002e9H
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 12					; 0000000cH

; 746  : 		_DEBUG_POINTER(_Last);

	push	746					; 000002eaH
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 12					; 0000000cH
$LN1@Distance2:

; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	mov	ecx, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [edx], eax

; 751  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@HPAVValue@Json@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@00PAHPAPAVValue@Json@@@Z
_TEXT	SEGMENT
tv174 = -396						; size = 4
tv146 = -396						; size = 4
$T1 = -388						; size = 4
$T2 = -376						; size = 8
$T3 = -360						; size = 8
$T4 = -344						; size = 8
$T5 = -328						; size = 4
$T6 = -316						; size = 8
$T7 = -300						; size = 8
__Next1$8 = -92						; size = 8
__Next$9 = -76						; size = 8
__Hole$10 = -60						; size = 8
__Tmp$11 = -44						; size = 4
__Factor$12 = -32					; size = 4
__Count$ = -20						; size = 4
__Shift$ = -8						; size = 4
__First$ = 8						; size = 8
__Mid$ = 16						; size = 8
__Last$ = 24						; size = 8
___formal$ = 32						; size = 4
___formal$ = 36						; size = 4
??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@HPAVValue@Json@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@00PAHPAPAVValue@Json@@@Z PROC ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int,Json::Value *>, COMDAT

; 3202 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-396]
	mov	ecx, 99					; 00000063H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3203 : 	_Diff _Shift = _Mid - _First;

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	mov	DWORD PTR __Shift$[ebp], eax

; 3204 : 	_Diff _Count = _Last - _First;

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	mov	DWORD PTR __Count$[ebp], eax

; 3205 : 
; 3206 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	eax, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$12[ebp], eax
$LN9@Rotate:
	cmp	DWORD PTR __Factor$12[ebp], 0
	je	SHORT $LN8@Rotate

; 3207 : 		{	// find subcycle count as GCD of shift count and length
; 3208 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$12[ebp]
	mov	DWORD PTR __Tmp$11[ebp], edx

; 3209 : 		_Count = _Factor;

	mov	eax, DWORD PTR __Factor$12[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 3210 : 		_Factor = _Tmp;

	mov	eax, DWORD PTR __Tmp$11[ebp]
	mov	DWORD PTR __Factor$12[ebp], eax

; 3211 : 		}

	jmp	SHORT $LN9@Rotate
$LN8@Rotate:

; 3212 : 
; 3213 : 	if (_Count < _Last - _First)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	cmp	DWORD PTR __Count$[ebp], eax
	jge	$LN10@Rotate

; 3214 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN6@Rotate
$LN5@Rotate:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN6@Rotate:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN10@Rotate

; 3215 : 			{	// rotate each subcycle
; 3216 : 			_RanIt _Hole = _First + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Hole$10[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+

; 3217 : 			_RanIt _Next = _Hole;

	mov	eax, DWORD PTR __Hole$10[ebp]
	mov	DWORD PTR __Next$9[ebp], eax
	mov	ecx, DWORD PTR __Hole$10[ebp+4]
	mov	DWORD PTR __Next$9[ebp+4], ecx

; 3218 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Shift$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR __Next$9[ebp]
	call	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	ecx, eax
	call	??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@Rotate
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR $T3[ebp+4], edx
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv146[ebp], eax
	jmp	SHORT $LN13@Rotate
$LN12@Rotate:
	mov	ecx, DWORD PTR __Shift$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	ecx, DWORD PTR __Next$9[ebp]
	call	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	DWORD PTR tv146[ebp], eax
$LN13@Rotate:
	mov	eax, DWORD PTR tv146[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Next1$8[ebp], edx
	mov	DWORD PTR __Next1$8[ebp+4], eax
$LN3@Rotate:

; 3219 : 			for (; ; )
; 3220 : 				{	// percolate elements back around subcycle
; 3221 : 				iter_swap(_Next, _Next1);

	mov	eax, DWORD PTR __Next1$8[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Next1$8[ebp]
	push	ecx
	mov	edx, DWORD PTR __Next$9[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Next$9[ebp]
	push	eax
	call	??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 16					; 00000010H

; 3222 : 				_Next = _Next1;

	mov	eax, DWORD PTR __Next1$8[ebp]
	mov	DWORD PTR __Next$9[ebp], eax
	mov	ecx, DWORD PTR __Next1$8[ebp+4]
	mov	DWORD PTR __Next$9[ebp+4], ecx

; 3223 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 3224 : 					: _First + (_Shift - (_Last - _Next1));

	lea	eax, DWORD PTR __Next1$8[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	cmp	DWORD PTR __Shift$[ebp], eax
	jge	SHORT $LN14@Rotate
	mov	ecx, DWORD PTR __Shift$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	ecx, DWORD PTR __Next1$8[ebp]
	call	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	DWORD PTR tv174[ebp], eax
	jmp	SHORT $LN15@Rotate
$LN14@Rotate:
	lea	eax, DWORD PTR __Next1$8[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	mov	ecx, DWORD PTR __Shift$[ebp]
	sub	ecx, eax
	push	ecx
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	DWORD PTR tv174[ebp], eax
$LN15@Rotate:
	mov	eax, DWORD PTR tv174[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Next1$8[ebp], edx
	mov	DWORD PTR __Next1$8[ebp+4], eax

; 3225 : 				if (_Next1 == _Hole)

	lea	eax, DWORD PTR __Hole$10[ebp]
	push	eax
	lea	ecx, DWORD PTR __Next1$8[ebp]
	call	??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Rotate

; 3226 : 					break;

	jmp	SHORT $LN2@Rotate
$LN1@Rotate:

; 3227 : 				}

	jmp	$LN3@Rotate
$LN2@Rotate:

; 3228 : 			}

	jmp	$LN5@Rotate
$LN10@Rotate:

; 3229 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@Rotate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 396				; 0000018cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN20@Rotate:
	DD	3
	DD	$LN19@Rotate
$LN19@Rotate:
	DD	-60					; ffffffc4H
	DD	8
	DD	$LN16@Rotate
	DD	-76					; ffffffb4H
	DD	8
	DD	$LN17@Rotate
	DD	-92					; ffffffa4H
	DD	8
	DD	$LN18@Rotate
$LN18@Rotate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	49					; 00000031H
	DB	0
$LN17@Rotate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
$LN16@Rotate:
	DB	95					; 0000005fH
	DB	72					; 00000048H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@HPAVValue@Json@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@00PAHPAPAVValue@Json@@@Z ENDP ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAPAPAVValue@Json@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 8
??$_Val_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAPAPAVValue@Json@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Val_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 645  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Val_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAPAPAVValue@Json@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAPAHV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 8
??$_Dist_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAPAHV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 705  : 	{	// return distance type from arbitrary argument

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 706  : 	return (0);

	xor	eax, eax

; 707  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Dist_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAPAHV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 8
__Right$ = 16						; size = 8
??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 27   : 	{	// swap *_Left and *_Right

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 28   : 	swap(*_Left, *_Right);

	lea	ecx, DWORD PTR __Right$[ebp]
	call	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	push	eax
	lea	ecx, DWORD PTR __Left$[ebp]
	call	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	push	eax
	call	??$swap@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z ; std::swap<Json::Value *>
	add	esp, 8

; 29   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z PROC ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 2064 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@AAV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Ptr_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2067 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ENDP ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z PROC ; std::_Debug_pointer<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 540  : 	{	// test pointer for non-singularity, arbitrary type

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 541  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z ENDP ; std::_Debug_pointer<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>, COMDAT

; 689  : 	{	// increment iterator by offset, random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 690  : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	call	??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=

; 691  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Off$ = 32						; size = 4
___formal$ = 36						; size = 1
??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>, COMDAT

; 741  : 	{	// add to _Off distance between random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Distance2

; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);

	push	745					; 000002e9H
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 12					; 0000000cH

; 746  : 		_DEBUG_POINTER(_Last);

	push	746					; 000002eaH
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 12					; 0000000cH
$LN1@Distance2:

; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
	mov	ecx, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [edx], eax

; 751  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@HVErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@00PAHPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
tv174 = -396						; size = 4
tv146 = -396						; size = 4
$T1 = -388						; size = 4
$T2 = -376						; size = 8
$T3 = -360						; size = 8
$T4 = -344						; size = 8
$T5 = -328						; size = 4
$T6 = -316						; size = 8
$T7 = -300						; size = 8
__Next1$8 = -92						; size = 8
__Next$9 = -76						; size = 8
__Hole$10 = -60						; size = 8
__Tmp$11 = -44						; size = 4
__Factor$12 = -32					; size = 4
__Count$ = -20						; size = 4
__Shift$ = -8						; size = 4
__First$ = 8						; size = 8
__Mid$ = 16						; size = 8
__Last$ = 24						; size = 8
___formal$ = 32						; size = 4
___formal$ = 36						; size = 4
??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@HVErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@00PAHPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int,Json::Reader::ErrorInfo>, COMDAT

; 3202 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-396]
	mov	ecx, 99					; 00000063H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3203 : 	_Diff _Shift = _Mid - _First;

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
	mov	DWORD PTR __Shift$[ebp], eax

; 3204 : 	_Diff _Count = _Last - _First;

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
	mov	DWORD PTR __Count$[ebp], eax

; 3205 : 
; 3206 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	eax, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$12[ebp], eax
$LN9@Rotate:
	cmp	DWORD PTR __Factor$12[ebp], 0
	je	SHORT $LN8@Rotate

; 3207 : 		{	// find subcycle count as GCD of shift count and length
; 3208 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$12[ebp]
	mov	DWORD PTR __Tmp$11[ebp], edx

; 3209 : 		_Count = _Factor;

	mov	eax, DWORD PTR __Factor$12[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 3210 : 		_Factor = _Tmp;

	mov	eax, DWORD PTR __Tmp$11[ebp]
	mov	DWORD PTR __Factor$12[ebp], eax

; 3211 : 		}

	jmp	SHORT $LN9@Rotate
$LN8@Rotate:

; 3212 : 
; 3213 : 	if (_Count < _Last - _First)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
	cmp	DWORD PTR __Count$[ebp], eax
	jge	$LN10@Rotate

; 3214 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN6@Rotate
$LN5@Rotate:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN6@Rotate:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN10@Rotate

; 3215 : 			{	// rotate each subcycle
; 3216 : 			_RanIt _Hole = _First + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Hole$10[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+

; 3217 : 			_RanIt _Next = _Hole;

	mov	eax, DWORD PTR __Hole$10[ebp]
	mov	DWORD PTR __Next$9[ebp], eax
	mov	ecx, DWORD PTR __Hole$10[ebp+4]
	mov	DWORD PTR __Next$9[ebp+4], ecx

; 3218 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Shift$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR __Next$9[ebp]
	call	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	ecx, eax
	call	??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@Rotate
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR $T3[ebp+4], edx
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv146[ebp], eax
	jmp	SHORT $LN13@Rotate
$LN12@Rotate:
	mov	ecx, DWORD PTR __Shift$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	ecx, DWORD PTR __Next$9[ebp]
	call	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	DWORD PTR tv146[ebp], eax
$LN13@Rotate:
	mov	eax, DWORD PTR tv146[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Next1$8[ebp], edx
	mov	DWORD PTR __Next1$8[ebp+4], eax
$LN3@Rotate:

; 3219 : 			for (; ; )
; 3220 : 				{	// percolate elements back around subcycle
; 3221 : 				iter_swap(_Next, _Next1);

	mov	eax, DWORD PTR __Next1$8[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Next1$8[ebp]
	push	ecx
	mov	edx, DWORD PTR __Next$9[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Next$9[ebp]
	push	eax
	call	??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 16					; 00000010H

; 3222 : 				_Next = _Next1;

	mov	eax, DWORD PTR __Next1$8[ebp]
	mov	DWORD PTR __Next$9[ebp], eax
	mov	ecx, DWORD PTR __Next1$8[ebp+4]
	mov	DWORD PTR __Next$9[ebp+4], ecx

; 3223 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 3224 : 					: _First + (_Shift - (_Last - _Next1));

	lea	eax, DWORD PTR __Next1$8[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
	cmp	DWORD PTR __Shift$[ebp], eax
	jge	SHORT $LN14@Rotate
	mov	ecx, DWORD PTR __Shift$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	ecx, DWORD PTR __Next1$8[ebp]
	call	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	DWORD PTR tv174[ebp], eax
	jmp	SHORT $LN15@Rotate
$LN14@Rotate:
	lea	eax, DWORD PTR __Next1$8[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
	mov	ecx, DWORD PTR __Shift$[ebp]
	sub	ecx, eax
	push	ecx
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	DWORD PTR tv174[ebp], eax
$LN15@Rotate:
	mov	eax, DWORD PTR tv174[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Next1$8[ebp], edx
	mov	DWORD PTR __Next1$8[ebp+4], eax

; 3225 : 				if (_Next1 == _Hole)

	lea	eax, DWORD PTR __Hole$10[ebp]
	push	eax
	lea	ecx, DWORD PTR __Next1$8[ebp]
	call	??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Rotate

; 3226 : 					break;

	jmp	SHORT $LN2@Rotate
$LN1@Rotate:

; 3227 : 				}

	jmp	$LN3@Rotate
$LN2@Rotate:

; 3228 : 			}

	jmp	$LN5@Rotate
$LN10@Rotate:

; 3229 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@Rotate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 396				; 0000018cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN20@Rotate:
	DD	3
	DD	$LN19@Rotate
$LN19@Rotate:
	DD	-60					; ffffffc4H
	DD	8
	DD	$LN16@Rotate
	DD	-76					; ffffffb4H
	DD	8
	DD	$LN17@Rotate
	DD	-92					; ffffffa4H
	DD	8
	DD	$LN18@Rotate
$LN18@Rotate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	49					; 00000031H
	DB	0
$LN17@Rotate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
$LN16@Rotate:
	DB	95					; 0000005fH
	DB	72					; 00000048H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@HVErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@00PAHPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int,Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAPAVErrorInfo@Reader@Json@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 8
??$_Val_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAPAVErrorInfo@Reader@Json@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Val_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 645  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Val_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAPAVErrorInfo@Reader@Json@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAPAHV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 8
??$_Dist_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAPAHV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 705  : 	{	// return distance type from arbitrary argument

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 706  : 	return (0);

	xor	eax, eax

; 707  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Dist_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAPAHV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 8
__Right$ = 16						; size = 8
??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 27   : 	{	// swap *_Left and *_Right

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 28   : 	swap(*_Left, *_Right);

	lea	ecx, DWORD PTR __Right$[ebp]
	call	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	push	eax
	lea	ecx, DWORD PTR __Left$[ebp]
	call	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	push	eax
	call	??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ; std::swap<Json::Reader::ErrorInfo>
	add	esp, 8

; 29   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z PROC ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 2064 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@AAV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Ptr_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2067 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ENDP ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z PROC ; std::_Debug_pointer<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 540  : 	{	// test pointer for non-singularity, arbitrary type

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 541  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z ENDP ; std::_Debug_pointer<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@ABQAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@ABQAV34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVValue@Json@@ABQAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@ABQAV34@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABQAVValue@Json@@@std@@YAABQAVValue@Json@@ABQAV12@@Z ; std::forward<Json::Value * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z ; std::allocator<Json::Value *>::construct

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVValue@Json@@ABQAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@ABQAV34@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@IABQAPAV12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@IABQAPAV12@@Z PROC ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>, COMDAT

; 2631 : 	{	// copy _Val _Count times through [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Fill_n

; 2633 : 		*_Dest = _Val;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@Fill_n
$LN1@Fill_n:

; 2634 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2635 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@IABQAPAV12@@Z ENDP ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::Value * *,Json::Value * *>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 402  : 	_DEBUG_RANGE(_First, _Last);

	push	402					; 00000192H
	push	OFFSET ??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0PB_WI@Z ; std::_Debug_range<Json::Value * * *>
	add	esp, 16					; 00000010H

; 403  : 	_DEBUG_POINTER(_Dest);

	push	403					; 00000193H
	push	OFFSET ??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Debug_pointer@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@PB_WI@Z ; std::_Debug_pointer<Json::Value * *>
	add	esp, 12					; 0000000cH

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 407  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::Value * *,Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@IABQAV123@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@IABQAV123@@Z PROC ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>, COMDAT

; 2631 : 	{	// copy _Val _Count times through [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Fill_n

; 2633 : 		*_Dest = _Val;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@Fill_n
$LN1@Fill_n:

; 2634 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2635 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@IABQAV123@@Z ENDP ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 402  : 	_DEBUG_RANGE(_First, _Last);

	push	402					; 00000192H
	push	OFFSET ??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0PB_WI@Z ; std::_Debug_range<Json::Reader::ErrorInfo * *>
	add	esp, 16					; 00000010H

; 403  : 	_DEBUG_POINTER(_Dest);

	push	403					; 00000193H
	push	OFFSET ??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Debug_pointer@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@PB_WI@Z ; std::_Debug_pointer<Json::Reader::ErrorInfo *>
	add	esp, 12					; 0000000cH

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 407  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z PROC ; std::move<Json::Reader::ErrorInfo &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ENDP ; std::move<Json::Reader::ErrorInfo &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_GErrorInfo@Reader@Json@@QAEPAXI@Z

; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z PROC ; std::allocator<Json::Value *>::destroy<Json::Value * *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value *>::destroy<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z PROC ; std::allocator<Json::Value *>::destroy<Json::Value *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value *>::destroy<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@H@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@H@Z PROC ; std::advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>, COMDAT

; 696  : 	{	// increment iterator by offset, arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 697  : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$_Advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>
	add	esp, 12					; 0000000cH

; 698  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@H@Z ENDP ; std::advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
tv138 = -276						; size = 4
tv135 = -272						; size = 4
tv141 = -268						; size = 4
$T2 = -257						; size = 1
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
__Off$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z PROC ; std::distance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 756  : 	{	// return distance between iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 757  : 	typename iterator_traits<_InIt>::difference_type _Off = 0;

	mov	DWORD PTR __Off$[ebp], 0

; 758  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	lea	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv141[ebp], eax
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR tv135[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv138[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>
	add	esp, 32					; 00000020H

; 759  : 	return (_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T5[ebp]

; 760  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@distance
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@distance:
	DD	1
	DD	$LN9@distance
$LN9@distance:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN7@distance
$LN7@distance:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$2:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ENDP ; std::distance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Mid$ = 16						; size = 8
__Last$ = 24						; size = 8
___formal$ = 32						; size = 1
??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 3234 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3235 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __First$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Val_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAPAPAVValue@Json@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Val_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Dist_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAPAHV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Dist_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@HPAVValue@Json@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@00PAHPAPAVValue@Json@@@Z ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int,Json::Value *>
	add	esp, 32					; 00000020H

; 3236 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Reverse@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0Ubidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
___formal$ = 24						; size = 1
??$_Reverse@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0Ubidirectional_iterator_tag@0@@Z PROC ; std::_Reverse<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 3159 : 	{	// reverse elements in [_First, _Last), bidirectional iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3160 : 	for (; _First != _Last && _First != --_Last; ++_First)

	jmp	SHORT $LN3@Reverse
$LN2@Reverse:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
$LN3@Reverse:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Reverse
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Reverse

; 3161 : 		_STD iter_swap(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 16					; 00000010H
	jmp	SHORT $LN2@Reverse
$LN4@Reverse:

; 3162 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Reverse@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0Ubidirectional_iterator_tag@0@@Z ENDP ; std::_Reverse<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-, COMDAT
; _this$ = ecx

; 260  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-

; 262  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -24						; size = 8
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+, COMDAT
; _this$ = ecx

; 243  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 245  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 246  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN5@operator:
	DD	1
	DD	$LN4@operator
$LN4@operator:
	DD	-24					; ffffffe8H
	DD	8
	DD	$LN3@operator
$LN3@operator:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=, COMDAT
; _this$ = ecx

; 237  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 238  : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=

; 239  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 240  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--, COMDAT
; _this$ = ecx

; 224  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 		--*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--

; 226  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 227  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++, COMDAT
; _this$ = ecx

; 211  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 212  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++

; 213  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 214  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*, COMDAT
; _this$ = ecx

; 201  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*

; 203  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx

; 197  : 		{	// construct with offset _Off

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >

; 198  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Iter$ = 12						; size = 12
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT

; 674  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 675  : 	return (_Iter._Unchecked());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 676  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z$0:
	lea	ecx, DWORD PTR __Iter$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
_TEXT	SEGMENT
tv133 = -288						; size = 4
tv132 = -284						; size = 4
$T2 = -276						; size = 4
$T3 = -264						; size = 8
$T4 = -248						; size = 8
$T5 = -232						; size = 4
__Ans$ = -28						; size = 12
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 12
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z PROC ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 2094 : 	{	// copy [_First, _Last) to [_Dest, ...), random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T5[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2095 : 	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	push	eax
	lea	ecx, DWORD PTR __Ans$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2096 : 	_Copy_impl(_First, _Last,
; 2097 : 		_Unchecked(_Dest));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv132[ebp], eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv133[ebp], eax
	mov	edx, DWORD PTR tv133[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 28					; 0000001cH

; 2098 : 	return (_Ans);

	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T5[ebp]
	or	ecx, 1
	mov	DWORD PTR $T5[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2099 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Copy_impl
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN11@Copy_impl:
	DD	1
	DD	$LN10@Copy_impl
$LN10@Copy_impl:
	DD	-28					; ffffffe4H
	DD	12					; 0000000cH
	DD	$LN8@Copy_impl
$LN8@Copy_impl:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z$1:
	lea	ecx, DWORD PTR __Ans$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ENDP ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
___formal$ = 40						; size = 1
??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 570  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 571  : 	if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 572  : 		{	// check for non-null pointers, valid range
; 573  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 12					; 0000000cH

; 574  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 12					; 0000000cH

; 575  : 		if (_Last < _First)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator<
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 576  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_rang:

; 577  : 		}
; 578  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z PROC ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value *>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::forward<Json::Value *>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ENDP ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value *>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVValue@Json@@@std@@YAABQAVValue@Json@@ABQAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVValue@Json@@@std@@YAABQAVValue@Json@@ABQAV12@@Z PROC ; std::forward<Json::Value * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@ABQAVValue@Json@@@std@@YAABQAVValue@Json@@ABQAV12@@Z ENDP ; std::forward<Json::Value * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@H@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@H@Z PROC ; std::advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>, COMDAT

; 696  : 	{	// increment iterator by offset, arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 697  : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$_Advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>
	add	esp, 12					; 0000000cH

; 698  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@H@Z ENDP ; std::advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
tv138 = -276						; size = 4
tv135 = -272						; size = 4
tv141 = -268						; size = 4
$T2 = -257						; size = 1
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
__Off$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z PROC ; std::distance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 756  : 	{	// return distance between iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 757  : 	typename iterator_traits<_InIt>::difference_type _Off = 0;

	mov	DWORD PTR __Off$[ebp], 0

; 758  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	lea	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv141[ebp], eax
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR tv135[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv138[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Distance2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>
	add	esp, 32					; 00000020H

; 759  : 	return (_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T5[ebp]

; 760  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@distance
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@distance:
	DD	1
	DD	$LN9@distance
$LN9@distance:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN7@distance
$LN7@distance:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$2:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ENDP ; std::distance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Mid$ = 16						; size = 8
__Last$ = 24						; size = 8
___formal$ = 32						; size = 1
??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 3234 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3235 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __First$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Val_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAPAVErrorInfo@Reader@Json@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Val_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Dist_type@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAPAHV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Dist_type<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@HVErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@00PAHPAVErrorInfo@Reader@Json@@@Z ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int,Json::Reader::ErrorInfo>
	add	esp, 32					; 00000020H

; 3236 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Reverse@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0Ubidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
___formal$ = 24						; size = 1
??$_Reverse@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0Ubidirectional_iterator_tag@0@@Z PROC ; std::_Reverse<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 3159 : 	{	// reverse elements in [_First, _Last), bidirectional iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3160 : 	for (; _First != _Last && _First != --_Last; ++_First)

	jmp	SHORT $LN3@Reverse
$LN2@Reverse:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
$LN3@Reverse:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Reverse
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Reverse

; 3161 : 		_STD iter_swap(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 16					; 00000010H
	jmp	SHORT $LN2@Reverse
$LN4@Reverse:

; 3162 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Reverse@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0Ubidirectional_iterator_tag@0@@Z ENDP ; std::_Reverse<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-, COMDAT
; _this$ = ecx

; 260  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-

; 262  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -24						; size = 8
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+, COMDAT
; _this$ = ecx

; 243  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 245  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 246  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN5@operator:
	DD	1
	DD	$LN4@operator
$LN4@operator:
	DD	-24					; ffffffe8H
	DD	8
	DD	$LN3@operator
$LN3@operator:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=, COMDAT
; _this$ = ecx

; 237  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 238  : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=

; 239  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 240  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--, COMDAT
; _this$ = ecx

; 224  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 		--*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--

; 226  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 227  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++, COMDAT
; _this$ = ecx

; 211  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 212  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++

; 213  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 214  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*, COMDAT
; _this$ = ecx

; 201  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*

; 203  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 197  : 		{	// construct with offset _Off

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >

; 198  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Iter$ = 12						; size = 12
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT

; 674  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 675  : 	return (_Iter._Unchecked());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 676  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z$0:
	lea	ecx, DWORD PTR __Iter$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
_TEXT	SEGMENT
tv133 = -288						; size = 4
tv132 = -284						; size = 4
$T2 = -276						; size = 4
$T3 = -264						; size = 8
$T4 = -248						; size = 8
$T5 = -232						; size = 4
__Ans$ = -28						; size = 12
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 12
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z PROC ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 2094 : 	{	// copy [_First, _Last) to [_Dest, ...), random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T5[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2095 : 	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
	push	eax
	lea	ecx, DWORD PTR __Ans$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2096 : 	_Copy_impl(_First, _Last,
; 2097 : 		_Unchecked(_Dest));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv132[ebp], eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv133[ebp], eax
	mov	edx, DWORD PTR tv133[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 28					; 0000001cH

; 2098 : 	return (_Ans);

	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T5[ebp]
	or	ecx, 1
	mov	DWORD PTR $T5[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2099 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Copy_impl
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN11@Copy_impl:
	DD	1
	DD	$LN10@Copy_impl
$LN10@Copy_impl:
	DD	-28					; ffffffe4H
	DD	12					; 0000000cH
	DD	$LN8@Copy_impl
$LN8@Copy_impl:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z$1:
	lea	ecx, DWORD PTR __Ans$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ENDP ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
___formal$ = 40						; size = 1
??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 570  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 571  : 	if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 572  : 		{	// check for non-null pointers, valid range
; 573  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 12					; 0000000cH

; 574  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 12					; 0000000cH

; 575  : 		if (_Last < _First)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator<
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 576  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_rang:

; 577  : 		}
; 578  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	DWORD PTR __imp_??0id@locale@std@@QAE@I@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	DWORD PTR __imp_??0id@locale@std@@QAE@I@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$construct@VErrorInfo@Reader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@VErrorInfo@Reader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@ABQAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVValue@Json@@ABQAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABQAVValue@Json@@@std@@YAABQAVValue@Json@@ABQAV12@@Z ; std::forward<Json::Value * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVValue@Json@@ABQAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@ABQAV34@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVValue@Json@@ABQAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 731  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * *> > >, COMDAT

; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 90   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_def_fill_n@PAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<Json::Value * *,unsigned int,Json::Value * *>, COMDAT

; 681  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@IABQAPAV12@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
	add	esp, 12					; 0000000cH

; 683  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_def_fill_n@PAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<Json::Value * *,unsigned int,Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z PROC ; std::_Ptr_cat<Json::Value * *,Json::Value * *>, COMDAT

; 444  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 447  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z ENDP ; std::_Ptr_cat<Json::Value * *,Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z PROC ; std::_Val_type<Json::Value * * *>, COMDAT

; 645  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Val_type@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ENDP ; std::_Val_type<Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z PROC ; std::_Rechecked<Json::Value * * *,Json::Value * * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 289  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 290  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 291  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z ENDP ; std::_Rechecked<Json::Value * * *,Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninit_copy<Json::Value * * *,Json::Value * * *,std::_Wrap_alloc<std::allocator<Json::Value * *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value * *,Json::Value * *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * *,Json::Value * *>
	add	esp, 20					; 00000014H

; 417  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninit_copy<Json::Value * * *,Json::Value * * *,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z PROC ; std::_Unchecked<Json::Value * * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 281  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 282  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ENDP ; std::_Unchecked<Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
___formal$ = 48						; size = 1
??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 2418 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Move
$LN2@Move:
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
$LN3@Move:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Move

; 2420 : 		*_Dest = _STD move(*_First);

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	push	eax
	call	??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::move<Json::Value * &>
	add	esp, 4
	mov	esi, eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN2@Move
$LN1@Move:

; 2421 : 	return (_Dest);

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2422 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
___formal$ = 48						; size = 1
??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 2525 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2
$LN2@Move_backw:

; 2526 : 	while (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Move_backw

; 2527 : 		*--_Dest = _STD move(*--_Last);

	lea	ecx, DWORD PTR __Last$[ebp]
	call	??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
	mov	ecx, eax
	call	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	push	eax
	call	??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::move<Json::Value * &>
	add	esp, 4
	mov	esi, eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
	mov	ecx, eax
	call	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN2@Move_backw
$LN1@Move_backw:

; 2528 : 	return (_Dest);

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2529 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 414  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 415  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 416  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 417  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
___formal$ = 40						; size = 1
??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 570  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 571  : 	if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 572  : 		{	// check for non-null pointers, valid range
; 573  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 12					; 0000000cH

; 574  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 12					; 0000000cH

; 575  : 		if (_Last < _First)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator<
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 576  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_rang:

; 577  : 		}
; 578  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo *>

; 731  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >, COMDAT

; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 90   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,unsigned int,Json::Reader::ErrorInfo *>, COMDAT

; 681  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@IABQAV123@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
	add	esp, 12					; 0000000cH

; 683  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,unsigned int,Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z PROC ; std::_Ptr_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>, COMDAT

; 444  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 447  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z ENDP ; std::_Ptr_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z PROC ; std::_Val_type<Json::Reader::ErrorInfo * *>, COMDAT

; 645  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Val_type@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ENDP ; std::_Val_type<Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z PROC ; std::_Rechecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 289  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 290  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 291  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z ENDP ; std::_Rechecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninit_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
	add	esp, 20					; 00000014H

; 417  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninit_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z PROC ; std::_Unchecked<Json::Reader::ErrorInfo * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 281  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 282  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ENDP ; std::_Unchecked<Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
___formal$ = 48						; size = 1
??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 2418 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Move
$LN2@Move:
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
$LN3@Move:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Move

; 2420 : 		*_Dest = _STD move(*_First);

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	push	eax
	call	??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ; std::move<Json::Reader::ErrorInfo &>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	mov	ecx, eax
	call	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
	jmp	SHORT $LN2@Move
$LN1@Move:

; 2421 : 	return (_Dest);

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2422 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
___formal$ = 48						; size = 1
??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 2525 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2
$LN2@Move_backw:

; 2526 : 	while (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Move_backw

; 2527 : 		*--_Dest = _STD move(*--_Last);

	lea	ecx, DWORD PTR __Last$[ebp]
	call	??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
	mov	ecx, eax
	call	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	push	eax
	call	??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ; std::move<Json::Reader::ErrorInfo &>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
	mov	ecx, eax
	call	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	mov	ecx, eax
	call	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
	jmp	SHORT $LN2@Move_backw
$LN1@Move_backw:

; 2528 : 	return (_Dest);

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2529 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 414  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 415  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 416  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 417  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
___formal$ = 40						; size = 1
??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 570  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 571  : 	if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 572  : 		{	// check for non-null pointers, valid range
; 573  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 12					; 0000000cH

; 574  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 12					; 0000000cH

; 575  : 		if (_Last < _First)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator<
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 576  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_rang:

; 577  : 		}
; 578  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo>

; 731  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value * *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy<Json::Value * *>

; 731  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy<Json::Value *>

; 731  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
tv300 = -408						; size = 4
tv299 = -404						; size = 4
tv303 = -400						; size = 4
tv296 = -400						; size = 4
tv306 = -396						; size = 4
tv295 = -396						; size = 4
tv288 = -396						; size = 4
tv281 = -396						; size = 4
tv302 = -392						; size = 4
tv292 = -392						; size = 4
tv285 = -392						; size = 4
tv278 = -392						; size = 4
tv317 = -388						; size = 4
tv315 = -388						; size = 4
tv291 = -388						; size = 4
tv269 = -388						; size = 4
$T2 = -380						; size = 4
$T3 = -368						; size = 4
$T4 = -356						; size = 4
$T5 = -344						; size = 4
$T6 = -329						; size = 1
$T7 = -320						; size = 4
$T8 = -308						; size = 8
$T9 = -292						; size = 4
$T10 = -280						; size = 8
$T11 = -264						; size = 4
$T12 = -252						; size = 8
$T13 = -236						; size = 4
$T14 = -224						; size = 4
$T15 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Mid$ = 24						; size = 12
__Last$ = 36						; size = 12
??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 3240 : 	{	// rotate [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 396				; 0000018cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-408]
	mov	ecx, 99					; 00000063H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T15[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 3241 : 	_DEBUG_RANGE(_First, _Mid);

	push	3241					; 00000ca9H
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Mid$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv269[ebp], eax
	mov	ecx, DWORD PTR tv269[ebp]
	mov	DWORD PTR tv278[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv281[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 32					; 00000020H

; 3242 : 	_DEBUG_RANGE(_Mid, _Last);

	push	3242					; 00000caaH
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv315[ebp], eax
	mov	ecx, DWORD PTR tv315[ebp]
	mov	DWORD PTR tv285[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv288[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 32					; 00000020H

; 3243 : 	if (_First != _Mid && _Mid != _Last)

	lea	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@rotate
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@rotate

; 3244 : 		_Rotate(_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),
; 3245 : 			_Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T7[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv291[ebp], eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv292[ebp], eax
	mov	ecx, DWORD PTR tv292[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T9[ebp], esp
	lea	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv295[ebp], eax
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv296[ebp], eax
	mov	ecx, DWORD PTR tv296[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T11[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv299[ebp], eax
	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv300[ebp], eax
	mov	ecx, DWORD PTR tv300[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	call	??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 28					; 0000001cH
$LN1@rotate:

; 3246 : 	_STD advance(_First, _STD distance(_Mid, _Last));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T13[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv317[ebp], eax
	mov	ecx, DWORD PTR tv317[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T14[ebp], esp
	lea	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv306[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::distance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv303[ebp], eax
	mov	eax, DWORD PTR tv303[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@H@Z ; std::advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,int>
	add	esp, 8

; 3247 : 	return (_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T15[ebp]
	or	ecx, 1
	mov	DWORD PTR $T15[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3248 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 408				; 00000198H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$1:
	lea	ecx, DWORD PTR __Mid$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$3:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$5:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$10:
	mov	ecx, DWORD PTR $T13[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-412]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
tv186 = -324						; size = 4
tv185 = -320						; size = 4
tv178 = -320						; size = 4
tv182 = -316						; size = 4
tv175 = -316						; size = 4
tv189 = -312						; size = 4
tv181 = -312						; size = 4
$T2 = -304						; size = 4
$T3 = -292						; size = 4
$T4 = -277						; size = 1
$T5 = -265						; size = 1
$T6 = -256						; size = 4
$T7 = -244						; size = 8
$T8 = -228						; size = 4
$T9 = -216						; size = 8
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z PROC ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 3166 : 	{	// reverse elements in [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-324]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3167 : 	_DEBUG_RANGE(_First, _Last);

	push	3167					; 00000c5fH
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv189[ebp], eax
	mov	ecx, DWORD PTR tv189[ebp]
	mov	DWORD PTR tv175[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv178[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 32					; 00000020H

; 3168 : 	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR $T4[ebp], dl
	movzx	eax, BYTE PTR $T4[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T6[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv181[ebp], eax
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv182[ebp], eax
	mov	ecx, DWORD PTR tv182[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T8[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv185[ebp], eax
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv186[ebp], eax
	mov	ecx, DWORD PTR tv186[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	call	??$_Reverse@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0Ubidirectional_iterator_tag@0@@Z ; std::_Reverse<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 20					; 00000014H

; 3169 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z$2:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-328]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ENDP ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
tv65 = -260						; size = 4
tv128 = -256						; size = 4
$T2 = -245						; size = 1
$T3 = -233						; size = 1
$T4 = -224						; size = 4
$T5 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 12
___formal$ = 40						; size = 1
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z PROC ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 2105 : 	{	// copy [_First, _Last) to [_Dest, ...), checked dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T5[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2106 : 	return (_Copy_impl(_First, _Last,
; 2107 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??$_Iter_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv128[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv65[ebp], eax
	mov	edx, DWORD PTR $T5[ebp]
	or	edx, 1
	mov	DWORD PTR $T5[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2108 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
$T2 = -197						; size = 1
___formal$ = 8						; size = 12
??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 273  : 	{	// return type is derived from true_type if iterator is checked

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 274  : 	return (typename _Is_checked_helper<_Iter>::type());

	xor	eax, eax
	mov	BYTE PTR $T2[ebp], al
	mov	cl, BYTE PTR $T2[ebp]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR ___formal$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	al, BYTE PTR $T1[ebp]

; 275  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=, COMDAT
; _this$ = ecx

; 132  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 134  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv67 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==, COMDAT
; _this$ = ecx

; 127  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv67[ebp]

; 129  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-, COMDAT
; _this$ = ecx

; 115  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		return (_Right._Myoff <= _Myoff
; 117  : 			? _Myoff - _Right._Myoff
; 118  : 			: -(difference_type)(_Right._Myoff - _Myoff));

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	ja	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+4]
	neg	edx
	mov	DWORD PTR tv74[ebp], edx
$LN4@operator:
	mov	eax, DWORD PTR tv74[ebp]

; 119  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=, COMDAT
; _this$ = ecx

; 92   : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		_Myoff += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 94   : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 95   : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--, COMDAT
; _this$ = ecx

; 79   : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 		--_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 81   : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 82   : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++, COMDAT
; _this$ = ecx

; 66   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 		++_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 68   : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 69   : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ
_TEXT	SEGMENT
__Off$ = -32						; size = 4
__Block$ = -20						; size = 4
_this$ = -8						; size = 4
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*, COMDAT
; _this$ = ecx

; 54   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 		size_type _Block = _Mycont->_Getblock(_Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	DWORD PTR __Off$[ebp], edx

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Block$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 58   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx

; 46   : 	_Deque_unchecked_const_iterator(size_type _Off,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		const _Container_base12 *_Pdeque)
; 48   : 		{	// construct with offset _Off
; 49   : 		_Mycont = (_Mydeque *)_Pdeque;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pdeque$[ebp]
	mov	DWORD PTR [eax], ecx

; 50   : 		_Myoff = _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Iter$ = 12						; size = 12
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT

; 541  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 542  : 	return (_Iter._Unchecked());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 543  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z$0:
	lea	ecx, DWORD PTR __Iter$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z PROC ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 540  : 	{	// test pointer for non-singularity, arbitrary type

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 541  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z ENDP ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z
_TEXT	SEGMENT
tv140 = -252						; size = 4
tv137 = -248						; size = 4
tv143 = -244						; size = 4
$T2 = -233						; size = 1
$T3 = -224						; size = 4
$T4 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z PROC ; std::_Debug_range<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 583  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 584  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv137[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv140[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H

; 585  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$2:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z ENDP ; std::_Debug_range<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?8PAVValue@Json@@PAV01@@std@@YA_NABV?$allocator@PAVValue@Json@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8PAVValue@Json@@PAV01@@std@@YA_NABV?$allocator@PAVValue@Json@@@0@0@Z PROC ; std::operator==<Json::Value *,Json::Value *>, COMDAT

; 660  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 661  : 	return (true);

	mov	al, 1

; 662  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8PAVValue@Json@@PAV01@@std@@YA_NABV?$allocator@PAVValue@Json@@@0@0@Z ENDP ; std::operator==<Json::Value *,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
$T2 = -197						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<Json::Value *>,std::allocator<Json::Value *> >, COMDAT

; 892  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
	push	eax
	call	??$?8PAVValue@Json@@PAV01@@std@@YA_NABV?$allocator@PAVValue@Json@@@0@0@Z ; std::operator==<Json::Value *,Json::Value *>
	add	esp, 8

; 894  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<Json::Value *>,std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::forward<Json::Value *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value *>

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$emplace_back@ABQAVValue@Json@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Block$ = -32						; size = 4
__Newoff$ = -20						; size = 4
_this$ = -8						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVValue@Json@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::emplace_back<Json::Value * const &>, COMDAT
; _this$ = ecx

; 1155 : 		void emplace_back(_Valty&&... _Val)

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1156 : 		{	// insert element at end
; 1157 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1158 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@emplace_ba
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 4
	shr	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], ecx
	ja	SHORT $LN2@emplace_ba
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN2@emplace_ba:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx*4-1]
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR __Newoff$[ebp], ecx
	mov	eax, DWORD PTR __Newoff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	jne	SHORT $LN1@emplace_ba
	push	4
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@emplace_ba:

; 1159 : 		this->_Getal().construct(
; 1160 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1161 : 			_STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@ABQAVValue@Json@@@std@@YAABQAVValue@Json@@ABQAV12@@Z ; std::forward<Json::Value * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVValue@Json@@ABQAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>

; 1162 : 		_PUSH_BACK_END;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1163 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$emplace_back@ABQAVValue@Json@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::emplace_back<Json::Value * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 731  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z ; std::forward<Json::Reader::ErrorInfo const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z PROC ; std::forward<Json::Reader::ErrorInfo const &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z ENDP ; std::forward<Json::Reader::ErrorInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
tv300 = -408						; size = 4
tv299 = -404						; size = 4
tv303 = -400						; size = 4
tv296 = -400						; size = 4
tv306 = -396						; size = 4
tv295 = -396						; size = 4
tv288 = -396						; size = 4
tv281 = -396						; size = 4
tv302 = -392						; size = 4
tv292 = -392						; size = 4
tv285 = -392						; size = 4
tv278 = -392						; size = 4
tv317 = -388						; size = 4
tv315 = -388						; size = 4
tv291 = -388						; size = 4
tv269 = -388						; size = 4
$T2 = -380						; size = 4
$T3 = -368						; size = 4
$T4 = -356						; size = 4
$T5 = -344						; size = 4
$T6 = -329						; size = 1
$T7 = -320						; size = 4
$T8 = -308						; size = 8
$T9 = -292						; size = 4
$T10 = -280						; size = 8
$T11 = -264						; size = 4
$T12 = -252						; size = 8
$T13 = -236						; size = 4
$T14 = -224						; size = 4
$T15 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Mid$ = 24						; size = 12
__Last$ = 36						; size = 12
??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 3240 : 	{	// rotate [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 396				; 0000018cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-408]
	mov	ecx, 99					; 00000063H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T15[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 3241 : 	_DEBUG_RANGE(_First, _Mid);

	push	3241					; 00000ca9H
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Mid$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv269[ebp], eax
	mov	ecx, DWORD PTR tv269[ebp]
	mov	DWORD PTR tv278[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv281[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 32					; 00000020H

; 3242 : 	_DEBUG_RANGE(_Mid, _Last);

	push	3242					; 00000caaH
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv315[ebp], eax
	mov	ecx, DWORD PTR tv315[ebp]
	mov	DWORD PTR tv285[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv288[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 32					; 00000020H

; 3243 : 	if (_First != _Mid && _Mid != _Last)

	lea	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@rotate
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@rotate

; 3244 : 		_Rotate(_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),
; 3245 : 			_Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T7[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv291[ebp], eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv292[ebp], eax
	mov	ecx, DWORD PTR tv292[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T9[ebp], esp
	lea	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv295[ebp], eax
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv296[ebp], eax
	mov	ecx, DWORD PTR tv296[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T11[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv299[ebp], eax
	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv300[ebp], eax
	mov	ecx, DWORD PTR tv300[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	call	??$_Rotate@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 28					; 0000001cH
$LN1@rotate:

; 3246 : 	_STD advance(_First, _STD distance(_Mid, _Last));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T13[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv317[ebp], eax
	mov	ecx, DWORD PTR tv317[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T14[ebp], esp
	lea	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv306[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$distance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAHV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::distance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv303[ebp], eax
	mov	eax, DWORD PTR tv303[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$advance@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@H@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@H@Z ; std::advance<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,int>
	add	esp, 8

; 3247 : 	return (_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T15[ebp]
	or	ecx, 1
	mov	DWORD PTR $T15[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3248 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 408				; 00000198H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$1:
	lea	ecx, DWORD PTR __Mid$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$3:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$5:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$10:
	mov	ecx, DWORD PTR $T13[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-412]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
tv186 = -324						; size = 4
tv185 = -320						; size = 4
tv178 = -320						; size = 4
tv182 = -316						; size = 4
tv175 = -316						; size = 4
tv189 = -312						; size = 4
tv181 = -312						; size = 4
$T2 = -304						; size = 4
$T3 = -292						; size = 4
$T4 = -277						; size = 1
$T5 = -265						; size = 1
$T6 = -256						; size = 4
$T7 = -244						; size = 8
$T8 = -228						; size = 4
$T9 = -216						; size = 8
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z PROC ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 3166 : 	{	// reverse elements in [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-324]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3167 : 	_DEBUG_RANGE(_First, _Last);

	push	3167					; 00000c5fH
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv189[ebp], eax
	mov	ecx, DWORD PTR tv189[ebp]
	mov	DWORD PTR tv175[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv178[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 32					; 00000020H

; 3168 : 	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR $T4[ebp], dl
	movzx	eax, BYTE PTR $T4[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T6[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv181[ebp], eax
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv182[ebp], eax
	mov	ecx, DWORD PTR tv182[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T8[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv185[ebp], eax
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv186[ebp], eax
	mov	ecx, DWORD PTR tv186[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	call	??$_Reverse@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0Ubidirectional_iterator_tag@0@@Z ; std::_Reverse<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 20					; 00000014H

; 3169 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z$2:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-328]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ENDP ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
tv65 = -260						; size = 4
tv128 = -256						; size = 4
$T2 = -245						; size = 1
$T3 = -233						; size = 1
$T4 = -224						; size = 4
$T5 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 12
___formal$ = 40						; size = 1
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z PROC ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 2105 : 	{	// copy [_First, _Last) to [_Dest, ...), checked dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T5[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2106 : 	return (_Copy_impl(_First, _Last,
; 2107 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??$_Iter_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv128[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv65[ebp], eax
	mov	edx, DWORD PTR $T5[ebp]
	or	edx, 1
	mov	DWORD PTR $T5[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2108 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
$T2 = -197						; size = 1
___formal$ = 8						; size = 12
??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 273  : 	{	// return type is derived from true_type if iterator is checked

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 274  : 	return (typename _Is_checked_helper<_Iter>::type());

	xor	eax, eax
	mov	BYTE PTR $T2[ebp], al
	mov	cl, BYTE PTR $T2[ebp]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR ___formal$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	al, BYTE PTR $T1[ebp]

; 275  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=, COMDAT
; _this$ = ecx

; 132  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 134  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv67 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==, COMDAT
; _this$ = ecx

; 127  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv67[ebp]

; 129  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-, COMDAT
; _this$ = ecx

; 115  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		return (_Right._Myoff <= _Myoff
; 117  : 			? _Myoff - _Right._Myoff
; 118  : 			: -(difference_type)(_Right._Myoff - _Myoff));

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	ja	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+4]
	neg	edx
	mov	DWORD PTR tv74[ebp], edx
$LN4@operator:
	mov	eax, DWORD PTR tv74[ebp]

; 119  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=, COMDAT
; _this$ = ecx

; 92   : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		_Myoff += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 94   : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 95   : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--, COMDAT
; _this$ = ecx

; 79   : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 		--_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 81   : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 82   : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++, COMDAT
; _this$ = ecx

; 66   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 		++_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 68   : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 69   : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
__Off$ = -32						; size = 4
__Block$ = -20						; size = 4
_this$ = -8						; size = 4
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*, COMDAT
; _this$ = ecx

; 54   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 		size_type _Block = _Mycont->_Getblock(_Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	mov	DWORD PTR __Off$[ebp], edx

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	imul	eax, DWORD PTR __Off$[ebp], 44
	mov	ecx, DWORD PTR __Block$[ebp]
	add	eax, DWORD PTR [edx+ecx*4]

; 58   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 46   : 	_Deque_unchecked_const_iterator(size_type _Off,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		const _Container_base12 *_Pdeque)
; 48   : 		{	// construct with offset _Off
; 49   : 		_Mycont = (_Mydeque *)_Pdeque;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pdeque$[ebp]
	mov	DWORD PTR [eax], ecx

; 50   : 		_Myoff = _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Iter$ = 12						; size = 12
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT

; 541  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 542  : 	return (_Iter._Unchecked());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 543  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z$0:
	lea	ecx, DWORD PTR __Iter$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z PROC ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 540  : 	{	// test pointer for non-singularity, arbitrary type

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 541  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z ENDP ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z
_TEXT	SEGMENT
tv140 = -252						; size = 4
tv137 = -248						; size = 4
tv143 = -244						; size = 4
$T2 = -233						; size = 1
$T3 = -224						; size = 4
$T4 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z PROC ; std::_Debug_range<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 583  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 584  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv137[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv140[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H

; 585  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$2:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z ENDP ; std::_Debug_range<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?8VErrorInfo@Reader@Json@@V012@@std@@YA_NABV?$allocator@VErrorInfo@Reader@Json@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8VErrorInfo@Reader@Json@@V012@@std@@YA_NABV?$allocator@VErrorInfo@Reader@Json@@@0@0@Z PROC ; std::operator==<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>, COMDAT

; 660  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 661  : 	return (true);

	mov	al, 1

; 662  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8VErrorInfo@Reader@Json@@V012@@std@@YA_NABV?$allocator@VErrorInfo@Reader@Json@@@0@0@Z ENDP ; std::operator==<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
$T2 = -197						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >, COMDAT

; 892  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
	push	eax
	call	??$?8VErrorInfo@Reader@Json@@V012@@std@@YA_NABV?$allocator@VErrorInfo@Reader@Json@@@0@0@Z ; std::operator==<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
	add	esp, 8

; 894  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Block$ = -32						; size = 4
__Newoff$ = -20						; size = 4
_this$ = -8						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<Json::Reader::ErrorInfo const &>, COMDAT
; _this$ = ecx

; 1155 : 		void emplace_back(_Valty&&... _Val)

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1156 : 		{	// insert element at end
; 1157 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1158 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@emplace_ba
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], ecx
	ja	SHORT $LN2@emplace_ba
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@emplace_ba:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR __Newoff$[ebp], ecx
	mov	eax, DWORD PTR __Newoff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	jne	SHORT $LN1@emplace_ba
	push	1
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@emplace_ba:

; 1159 : 		this->_Getal().construct(
; 1160 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1161 : 			_STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z ; std::forward<Json::Reader::ErrorInfo const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 1
	div	esi
	imul	edx, edx, 44
	mov	eax, DWORD PTR __Block$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>

; 1162 : 		_PUSH_BACK_END;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1163 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<Json::Reader::ErrorInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 660  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 661  : 	return (true);

	mov	al, 1

; 662  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
$T2 = -197						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT

; 892  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	push	eax
	call	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z	; std::operator==<char,char>
	add	esp, 8

; 894  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@PBD@std@@YAXPBD0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Debug_range2@PBD@std@@YAXPBD0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<char const *>, COMDAT

; 570  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 571  : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Debug_rang

; 572  : 		{	// check for non-null pointers, valid range
; 573  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 574  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 575  : 		if (_Last < _First)

	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jae	SHORT $LN3@Debug_rang

; 576  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Debug_rang:

; 577  : 		}
; 578  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range2@PBD@std@@YAXPBD0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z PROC ; std::_Iter_cat<char const *>, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z ENDP ; std::_Iter_cat<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z PROC ; std::_Allocate<Json::Value * *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ENDP ; std::_Allocate<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z PROC ; std::_Allocate<Json::Reader::ErrorInfo *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ENDP ; std::_Allocate<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z PROC ; std::_Allocate<Json::Value *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ENDP ; std::_Allocate<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
	add	esp, 12					; 0000000cH

; 873  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z PROC ; std::_Allocate<Json::Reader::ErrorInfo>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 97612893	; 05d1745dH
	ja	SHORT $LN1@Allocate
	imul	eax, DWORD PTR __Count$[ebp], 44
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ENDP ; std::_Allocate<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
	add	esp, 8

; 880  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 859  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate

; 848  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * *> > >, COMDAT

; 95   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value * *,Json::Value * *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * *> > >
	add	esp, 16					; 00000010H

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Value * *> > >, COMDAT

; 690  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 691  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value * *,Json::Value * *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ; std::_Val_type<Json::Value * * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninit_def_fill_n@PAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::Value * *,unsigned int,Json::Value * *>
	add	esp, 20					; 00000014H

; 693  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::_Wrap_alloc<std::allocator<Json::Value * *> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ; std::_Unchecked<Json::Value * * *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ; std::_Unchecked<Json::Value * * *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ; std::_Unchecked<Json::Value * * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninit_copy<Json::Value * * *,Json::Value * * *,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z ; std::_Rechecked<Json::Value * * *,Json::Value * * *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 428  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
tv67 = -288						; size = 4
tv157 = -284						; size = 4
tv154 = -280						; size = 4
tv166 = -276						; size = 4
tv151 = -272						; size = 4
tv165 = -268						; size = 4
$T2 = -257						; size = 1
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
$T6 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T6[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	mov	BYTE PTR $T2[ebp], al
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv165[ebp], eax
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR tv151[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv166[ebp], eax
	mov	eax, DWORD PTR tv166[ebp]
	mov	DWORD PTR tv154[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv157[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	or	ecx, 1
	mov	DWORD PTR $T6[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2442 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$1:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$3:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$4:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
tv67 = -288						; size = 4
tv157 = -284						; size = 4
tv154 = -280						; size = 4
tv166 = -276						; size = 4
tv151 = -272						; size = 4
tv165 = -268						; size = 4
$T2 = -257						; size = 1
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
$T6 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T6[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	mov	BYTE PTR $T2[ebp], al
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv165[ebp], eax
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR tv151[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv166[ebp], eax
	mov	eax, DWORD PTR tv166[ebp]
	mov	DWORD PTR tv154[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv157[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	or	ecx, 1
	mov	DWORD PTR $T6[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2549 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$1:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$3:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z$4:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z
_TEXT	SEGMENT
tv140 = -252						; size = 4
tv137 = -248						; size = 4
tv143 = -244						; size = 4
$T2 = -233						; size = 1
$T3 = -224						; size = 4
$T4 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z PROC ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 583  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 584  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv137[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv140[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H

; 585  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z$2:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z ENDP ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN4@construct:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ PROC	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ENDP	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
	add	esp, 8

; 880  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >, COMDAT

; 95   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
	add	esp, 16					; 00000010H

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >, COMDAT

; 690  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 691  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ; std::_Val_type<Json::Reader::ErrorInfo * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,unsigned int,Json::Reader::ErrorInfo *>
	add	esp, 20					; 00000014H

; 693  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ; std::_Unchecked<Json::Reader::ErrorInfo * *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ; std::_Unchecked<Json::Reader::ErrorInfo * *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ; std::_Unchecked<Json::Reader::ErrorInfo * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z ; std::_Rechecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 428  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 561  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 817  : 		{	// construct from a related allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>

; 818  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
tv67 = -288						; size = 4
tv157 = -284						; size = 4
tv154 = -280						; size = 4
tv166 = -276						; size = 4
tv151 = -272						; size = 4
tv165 = -268						; size = 4
$T2 = -257						; size = 1
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
$T6 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T6[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	mov	BYTE PTR $T2[ebp], al
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv165[ebp], eax
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR tv151[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv166[ebp], eax
	mov	eax, DWORD PTR tv166[ebp]
	mov	DWORD PTR tv154[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv157[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	or	ecx, 1
	mov	DWORD PTR $T6[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2442 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$1:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$3:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$4:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
tv67 = -288						; size = 4
tv157 = -284						; size = 4
tv154 = -280						; size = 4
tv166 = -276						; size = 4
tv151 = -272						; size = 4
tv165 = -268						; size = 4
$T2 = -257						; size = 1
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
$T6 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T6[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	mov	BYTE PTR $T2[ebp], al
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv165[ebp], eax
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR tv151[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv166[ebp], eax
	mov	eax, DWORD PTR tv166[ebp]
	mov	DWORD PTR tv154[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv157[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	or	ecx, 1
	mov	DWORD PTR $T6[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2549 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$1:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$3:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z$4:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z
_TEXT	SEGMENT
tv140 = -252						; size = 4
tv137 = -248						; size = 4
tv143 = -244						; size = 4
$T2 = -233						; size = 1
$T3 = -224						; size = 4
$T4 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z PROC ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 583  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 584  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv137[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv140[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range2@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H

; 585  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z$2:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z ENDP ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>
	add	esp, 8

; 880  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value * *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value * *>
	add	esp, 8

; 880  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>, COMDAT
; _this$ = ecx

; 561  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::_Wrap_alloc<std::allocator<Json::Value * *> ><std::_Wrap_alloc<std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 817  : 		{	// construct from a related allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>

; 818  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::_Wrap_alloc<std::allocator<Json::Value * *> ><std::_Wrap_alloc<std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value *>
	add	esp, 8

; 880  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z
_TEXT	SEGMENT
tv395 = -632						; size = 4
tv408 = -628						; size = 4
tv403 = -628						; size = 4
tv418 = -624						; size = 4
tv400 = -624						; size = 4
tv415 = -620						; size = 4
tv397 = -620						; size = 4
tv444 = -616						; size = 4
tv437 = -616						; size = 4
tv413 = -612						; size = 4
tv394 = -612						; size = 4
tv443 = -608						; size = 4
tv436 = -608						; size = 4
tv410 = -604						; size = 4
tv392 = -604						; size = 4
tv388 = -604						; size = 4
tv442 = -600						; size = 4
tv435 = -600						; size = 4
tv385 = -600						; size = 4
tv380 = -600						; size = 4
tv421 = -596						; size = 4
tv407 = -596						; size = 4
tv390 = -596						; size = 4
tv383 = -596						; size = 4
tv377 = -596						; size = 4
tv373 = -596						; size = 4
tv446 = -592						; size = 4
tv441 = -592						; size = 4
tv440 = -592						; size = 4
tv434 = -592						; size = 4
tv433 = -592						; size = 4
tv432 = -592						; size = 4
tv429 = -592						; size = 4
tv365 = -592						; size = 4
tv439 = -589						; size = 1
tv431 = -589						; size = 1
$T2 = -584						; size = 4
$T3 = -572						; size = 4
$T4 = -560						; size = 12
$T5 = -540						; size = 4
$T6 = -528						; size = 12
$T7 = -508						; size = 12
$T8 = -488						; size = 12
$T9 = -468						; size = 4
$T10 = -456						; size = 12
$T11 = -436						; size = 4
$T12 = -424						; size = 4
$T13 = -412						; size = 4
$T14 = -400						; size = 12
$T15 = -380						; size = 4
$T16 = -368						; size = 4
$T17 = -356						; size = 12
$T18 = -336						; size = 12
$T19 = -316						; size = 4
$T20 = -304						; size = 12
$T21 = -284						; size = 4
$T22 = -272						; size = 12
__Num$23 = -60						; size = 4
__Oldsize$ = -48					; size = 4
__Off$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
__First$ = 24						; size = 12
__Last$ = 36						; size = 12
??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; _this$ = ecx

; 1545 : 		typename enable_if<_Is_iterator<_Iter>::value,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 616				; 00000268H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-632]
	mov	ecx, 154				; 0000009aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T9[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1546 : 			iterator>::type
; 1547 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1548 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1549 : 		size_type _Off = _Where - begin();

	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv365[ebp], eax
	mov	ecx, DWORD PTR tv365[ebp]
	mov	DWORD PTR tv373[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	edx, DWORD PTR tv373[ebp]
	push	edx
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	mov	DWORD PTR __Off$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T10[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ

; 1550 : 
; 1551 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1552 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN17@insert

; 1553 : 			_DEBUG_ERROR("deque insert iterator outside range");

	mov	esi, esp
	push	1553					; 00000611H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EI@ODOAHAHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@insert:

; 1554 : 		_DEBUG_RANGE(_First, _Last);

	push	1554					; 00000612H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T11[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv429[ebp], eax
	mov	ecx, DWORD PTR tv429[ebp]
	mov	DWORD PTR tv377[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T12[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv380[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 32					; 00000020H

; 1555 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1556 : 
; 1557 : 		size_type _Oldsize = this->_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldsize$[ebp], ecx

; 1558 : 
; 1559 : 		if (_First == _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@insert
	jmp	$LN15@insert
$LN16@insert:

; 1560 : 			;
; 1561 : 		else if (_Off <= this->_Mysize / 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	shr	ecx, 1
	cmp	DWORD PTR __Off$[ebp], ecx
	ja	$LN14@insert

; 1562 : 			{	// closer to front, push to front then rotate
; 1563 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 5

; 1564 : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN12@insert
$LN11@insert:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
$LN12@insert:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	mov	BYTE PTR tv431[ebp], al
	movzx	ecx, BYTE PTR tv431[ebp]
	test	ecx, ecx
	je	SHORT $LN10@insert

; 1565 : 				push_front(*_First);	// prepend flipped

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	mov	DWORD PTR tv432[ebp], eax
	mov	eax, DWORD PTR tv432[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_front
	jmp	SHORT $LN11@insert
$LN10@insert:
	jmp	SHORT $LN20@insert
__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$0:
$LN9@insert:

; 1566 : 
; 1567 : 			_CATCH_ALL
; 1568 : 			for (; _Oldsize < this->_Mysize; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Oldsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN8@insert

; 1569 : 				pop_front();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front
	jmp	SHORT $LN9@insert
$LN8@insert:

; 1570 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1571 : 			_CATCH_END

	mov	eax, $LN50@insert
	ret	0
$LN20@insert:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	jmp	SHORT __tryend$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$1
$LN50@insert:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
__tryend$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$1:

; 1572 : 
; 1573 : 			size_type _Num = this->_Mysize - _Oldsize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Oldsize$[ebp]
	mov	DWORD PTR __Num$23[ebp], ecx

; 1574 : 			_STD reverse(begin(), begin() + _Num);	// flip new stuff in place

	lea	eax, DWORD PTR $T14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv433[ebp], eax
	mov	ecx, DWORD PTR tv433[ebp]
	mov	DWORD PTR tv383[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T13[ebp], esp
	mov	eax, DWORD PTR __Num$23[ebp]
	push	eax
	push	edx
	mov	ecx, DWORD PTR tv383[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	DWORD PTR tv385[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T15[ebp], esp
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv388[ebp], eax
	call	??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T14[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ

; 1575 : 			_STD rotate(begin(), begin() + _Num, begin() + _Num + _Off);

	lea	eax, DWORD PTR $T17[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv434[ebp], eax
	mov	ecx, DWORD PTR tv434[ebp]
	mov	DWORD PTR tv390[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 8
	mov	edx, DWORD PTR __Num$23[ebp]
	push	edx
	lea	eax, DWORD PTR $T18[ebp]
	push	eax
	mov	ecx, DWORD PTR tv390[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	DWORD PTR tv435[ebp], eax
	mov	ecx, DWORD PTR tv435[ebp]
	mov	DWORD PTR tv392[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 9
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T16[ebp], esp
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	push	edx
	mov	ecx, DWORD PTR tv392[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	DWORD PTR tv436[ebp], eax
	mov	ecx, DWORD PTR tv436[ebp]
	mov	DWORD PTR tv394[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 10		; 0000000aH
	lea	edx, DWORD PTR $T20[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv437[ebp], eax
	mov	eax, DWORD PTR tv437[ebp]
	mov	DWORD PTR tv397[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 11		; 0000000bH
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T19[ebp], esp
	mov	edx, DWORD PTR __Num$23[ebp]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR tv397[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	DWORD PTR tv400[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T21[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv403[ebp], eax
	lea	ecx, DWORD PTR $T22[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 12		; 0000000cH
	call	??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv395[ebp], eax
	lea	ecx, DWORD PTR $T22[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 9
	lea	ecx, DWORD PTR $T20[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 8
	lea	ecx, DWORD PTR $T18[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T17[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ

; 1576 : 			}
; 1577 : 		else

	jmp	$LN15@insert
$LN14@insert:

; 1578 : 			{	// closer to back
; 1579 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 13		; 0000000dH

; 1580 : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN5@insert
$LN4@insert:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
$LN5@insert:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	mov	BYTE PTR tv439[ebp], al
	movzx	ecx, BYTE PTR tv439[ebp]
	test	ecx, ecx
	je	SHORT $LN3@insert

; 1581 : 				push_back(*_First);	// append

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	mov	DWORD PTR tv440[ebp], eax
	mov	eax, DWORD PTR tv440[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
	jmp	SHORT $LN4@insert
$LN3@insert:
	jmp	SHORT $LN22@insert
__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$2:
$LN2@insert:

; 1582 : 
; 1583 : 			_CATCH_ALL
; 1584 : 			for (; _Oldsize < this->_Mysize; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Oldsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN1@insert

; 1585 : 				pop_back();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
	jmp	SHORT $LN2@insert
$LN1@insert:

; 1586 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1587 : 			_CATCH_END

	mov	eax, $LN52@insert
	ret	0
$LN22@insert:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	jmp	SHORT __tryend$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$3
$LN52@insert:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
__tryend$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$3:

; 1588 : 
; 1589 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T2[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	DWORD PTR tv441[ebp], eax
	mov	ecx, DWORD PTR tv441[ebp]
	mov	DWORD PTR tv407[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 15		; 0000000fH
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv442[ebp], eax
	mov	eax, DWORD PTR tv442[ebp]
	mov	DWORD PTR tv410[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 16		; 00000010H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	mov	edx, DWORD PTR __Oldsize$[ebp]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR tv410[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	DWORD PTR tv443[ebp], eax
	mov	eax, DWORD PTR tv443[ebp]
	mov	DWORD PTR tv413[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 17		; 00000011H
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv444[ebp], eax
	mov	edx, DWORD PTR tv444[ebp]
	mov	DWORD PTR tv415[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 18		; 00000012H
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T5[ebp], esp
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	push	eax
	mov	ecx, DWORD PTR tv415[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	DWORD PTR tv418[ebp], eax
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	BYTE PTR __$EHRec$[ebp+12], 20		; 00000014H
	call	??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv408[ebp], eax
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 19		; 00000013H
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
$LN15@insert:

; 1590 : 			}
; 1591 : 		return (begin() + _Off);

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv446[ebp], eax
	mov	ecx, DWORD PTR tv446[ebp]
	mov	DWORD PTR tv421[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 21		; 00000015H
	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv421[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	ecx, DWORD PTR $T9[ebp]
	or	ecx, 1
	mov	DWORD PTR $T9[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@insert:

; 1592 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 632				; 00000278H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$4:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$5:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$6:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$7:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$8:
	mov	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$10:
	lea	ecx, DWORD PTR $T14[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$13:
	lea	ecx, DWORD PTR $T17[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$14:
	lea	ecx, DWORD PTR $T18[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$15:
	mov	ecx, DWORD PTR $T16[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$16:
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$20:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$21:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$22:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$23:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$26:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-636]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
tv140 = -376						; size = 4
tv236 = -372						; size = 4
tv235 = -368						; size = 4
tv232 = -364						; size = 4
tv231 = -360						; size = 4
tv228 = -356						; size = 4
tv223 = -356						; size = 4
tv242 = -352						; size = 4
tv220 = -352						; size = 4
tv225 = -348						; size = 4
tv73 = -348						; size = 4
$T2 = -340						; size = 4
$T3 = -328						; size = 4
$T4 = -313						; size = 1
$T5 = -304						; size = 4
$T6 = -292						; size = 4
$T7 = -280						; size = 4
$T8 = -268						; size = 8
$T9 = -252						; size = 4
$T10 = -240						; size = 8
$T11 = -224						; size = 4
$T12 = -209						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z PROC ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 2124 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 364				; 0000016cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-376]
	mov	ecx, 91					; 0000005bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T11[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2125 : 	if (_First == _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@copy

; 2126 : 		return (_Dest);

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T11[ebp]
	or	ecx, 1
	mov	DWORD PTR $T11[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN3@copy

; 2127 : 	else

	jmp	$LN1@copy
$LN2@copy:

; 2128 : 		{	// worth copying, check then copy
; 2129 : 		_DEBUG_RANGE(_First, _Last);

	push	2129					; 00000851H
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv220[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv223[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 32					; 00000020H

; 2130 : 		_DEBUG_POINTER(_Dest);

	push	2130					; 00000852H
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 12					; 0000000cH

; 2131 : 		return (_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2132 : 			_Dest, _Is_checked(_Dest)));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv225[ebp], eax
	call	??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR $T12[ebp], al
	mov	cl, BYTE PTR $T12[ebp]
	mov	BYTE PTR $T4[ebp], cl
	movzx	edx, BYTE PTR $T4[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T6[ebp], esp
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv242[ebp], eax
	mov	ecx, DWORD PTR tv242[ebp]
	mov	DWORD PTR tv228[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T7[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv231[ebp], eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv232[ebp], eax
	mov	ecx, DWORD PTR tv232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T9[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv235[ebp], eax
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv236[ebp], eax
	mov	ecx, DWORD PTR tv236[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H
	mov	DWORD PTR tv140[ebp], eax
	mov	edx, DWORD PTR $T11[ebp]
	or	edx, 1
	mov	DWORD PTR $T11[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@copy
$LN1@copy:

; 2133 : 		}
; 2134 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
$LN3@copy:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 376				; 00000178H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z$1:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z$4:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z$7:
	mov	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-380]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ENDP ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-, COMDAT
; _this$ = ecx

; 661  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 662  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-

; 663  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
$T2 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-, COMDAT
; _this$ = ecx

; 655  : 		{	// return this - integer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 656  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 657  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 658  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-=, COMDAT
; _this$ = ecx

; 650  : 		{	// decrement by integer

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (*this += -_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=

; 652  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
$T2 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+, COMDAT
; _this$ = ecx

; 644  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 645  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 646  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=, COMDAT
; _this$ = ecx

; 638  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 639  : 		this->_Myoff += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 640  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 641  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--, COMDAT
; _this$ = ecx

; 625  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 626  : 		--*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--

; 627  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 628  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++, COMDAT
; _this$ = ecx

; 612  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 613  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++

; 614  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 615  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*, COMDAT
; _this$ = ecx

; 602  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*

; 604  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 597  : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 598  : 		return (_Unchecked_type(this->_Myoff, this->_Getcont()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx

; 585  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >

; 586  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z PROC ; std::operator!=<std::allocator<Json::Value *>,std::allocator<Json::Value *> >, COMDAT

; 900  : 	{	// test for allocator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 901  : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ; std::operator==<std::allocator<Json::Value *>,std::allocator<Json::Value *> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 902  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?9V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<Json::Value *>,std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::forward<Json::Value *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>
	add	esp, 12					; 0000000cH

; 873  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z PROC ; std::forward<Json::Value *>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ENDP ; std::forward<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
tv85 = -224						; size = 4
tv84 = -221						; size = 1
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; _this$ = ecx

; 1011 : 		void _Construct(_Iter _First, _Iter _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 1012 : 		{	// initialize from [_First, _Last), input iterators
; 1013 : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 1014 : 
; 1015 : 		for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Construct
$LN2@Construct:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
$LN3@Construct:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
	mov	BYTE PTR tv84[ebp], al
	movzx	ecx, BYTE PTR tv84[ebp]
	test	ecx, ecx
	je	SHORT $LN1@Construct

; 1016 : 			emplace_back(*_First);

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	mov	DWORD PTR tv85[ebp], eax
	mov	eax, DWORD PTR tv85[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$emplace_back@ABQAVValue@Json@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::emplace_back<Json::Value * const &>
	jmp	SHORT $LN2@Construct
$LN1@Construct:
	jmp	SHORT $LN7@Construct
__catch$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$0:

; 1017 : 
; 1018 : 		_CATCH_ALL
; 1019 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy

; 1020 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1021 : 		_CATCH_END

	mov	eax, $LN12@Construct
	ret	0
$LN7@Construct:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$1
$LN12@Construct:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$1:

; 1022 : 		}

	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
$LN6@Construct:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$2:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$3:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Setcont, COMDAT
; _this$ = ecx

; 507  : 		{	// set container pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 508  : 		this->_Adopt(_Pdeque);

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 509  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Compat, COMDAT
; _this$ = ecx

; 496  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 498  : 		if (_Mycont == 0
; 499  : 			|| _Mycont != _Right._Getcont())

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN1@Compat
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	DWORD PTR __Mycont$[ebp], eax
	je	$LN3@Compat
$LN1@Compat:

; 500  : 			{	// report error
; 501  : 			_DEBUG_ERROR("deque iterators incompatible");

	mov	esi, esp
	push	501					; 000001f5H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DK@CNDLFKCJ@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 502  : 			_SCL_SECURE_INVALID_ARGUMENT;

	mov	eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	eax, eax
	je	SHORT $LN5@Compat
	xor	ecx, ecx
	jne	SHORT $LN6@Compat
$LN5@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	502					; 000001f6H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@Compat
	int	3
$LN6@Compat:
	mov	esi, esp
	push	0
	push	502					; 000001f6H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1OG@LDMEFICC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Compat:

; 503  : 			}
; 504  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator<, COMDAT
; _this$ = ecx

; 474  : 		{	// test if this < _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 475  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Compat

; 476  : 		return (this->_Myoff < _Right._Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 477  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator<
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=, COMDAT
; _this$ = ecx

; 469  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 471  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==, COMDAT
; _this$ = ecx

; 463  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 464  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Compat

; 465  : 		return (this->_Myoff == _Right._Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 466  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
tv76 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-, COMDAT
; _this$ = ecx

; 450  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 451  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Compat

; 452  : 		return (_Right._Myoff <= this->_Myoff
; 453  : 			? this->_Myoff - _Right._Myoff
; 454  : 			: -(difference_type)(_Right._Myoff - this->_Myoff));

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv76[ebp], edx
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	neg	edx
	mov	DWORD PTR tv76[ebp], edx
$LN4@operator:
	mov	eax, DWORD PTR tv76[ebp]

; 455  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
$T2 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+, COMDAT
; _this$ = ecx

; 433  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 434  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 435  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 436  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=, COMDAT
; _this$ = ecx

; 410  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 411  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 412  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 413  : 		if (_Mycont == 0
; 414  : 			|| this->_Myoff + _Off < _Mycont->_Myoff
; 415  : 			|| _Mycont->_Myoff + _Mycont->_Mysize < this->_Myoff + _Off)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Mycont$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN1@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Mycont$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	add	edx, DWORD PTR __Off$[ebp]
	cmp	ecx, edx
	jae	$LN2@operator
$LN1@operator:

; 416  : 			{	// report error
; 417  : 			_DEBUG_ERROR("deque iterator + offset out of range");

	mov	esi, esp
	push	417					; 000001a1H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EK@DEGNOCIK@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 418  : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	418					; 000001a2H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	418					; 000001a2H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1OO@NDCHBGNA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 419  : 			}
; 420  : 
; 421  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 422  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 423  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 424  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff + _Off
; 425  : 			&& this->_Myoff + _Off <= _Mycont->_Myoff + _Mycont->_Mysize);
; 426  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 427  : 
; 428  : 		_Myoff += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 429  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 430  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--, COMDAT
; _this$ = ecx

; 382  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 383  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 384  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 385  : 		if (_Mycont == 0
; 386  : 			|| this->_Myoff <= _Mycont->_Myoff)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	ja	$LN2@operator
$LN1@operator:

; 387  : 		{	// report error
; 388  : 		_DEBUG_ERROR("deque iterator not decrementable");

	mov	esi, esp
	push	388					; 00000184H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EC@IJLEGPJO@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 389  : 		_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	389					; 00000185H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	389					; 00000185H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1OO@FFGHKCFC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 390  : 		}
; 391  : 
; 392  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 393  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 394  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 395  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff < this->_Myoff);
; 396  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 397  : 
; 398  : 		--_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 399  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 400  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++, COMDAT
; _this$ = ecx

; 353  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 355  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 356  : 		if (_Mycont == 0
; 357  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Mycont$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	$LN2@operator
$LN1@operator:

; 358  : 		{	// report error
; 359  : 		_DEBUG_ERROR("deque iterator not incrementable");

	mov	esi, esp
	push	359					; 00000167H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EC@CEAHEOFL@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 360  : 		_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	360					; 00000168H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	360					; 00000168H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1OO@KGFFBOJD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 361  : 		}
; 362  : 
; 363  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 364  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 365  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 366  : 		_SCL_SECURE_VALIDATE_RANGE(
; 367  : 			this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 368  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 369  : 
; 370  : 		++_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 371  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 372  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ
_TEXT	SEGMENT
__Off$ = -44						; size = 4
__Block$ = -32						; size = 4
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jb	SHORT $LN1@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Mycont$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	$LN2@operator
$LN1@operator:

; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");

	mov	esi, esp
	push	330					; 0000014aH
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EE@INPCGGNP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 331  : 		_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	331					; 0000014bH
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	331					; 0000014bH
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1OM@OEJNAKAK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR __Mycont$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	DWORD PTR __Off$[ebp], edx

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 345  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 317  : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 318  : 		return (_Unchecked_type(_Myoff, this->_Getcont()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 319  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx

; 302  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 303  : 		{	// construct with offset _Off in *_Pdeque
; 304  : 		_Setcont((_Mydeque *)_Pdeque);

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Setcont

; 305  : 		_Myoff = _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 306  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
__ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 880  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z ; std::forward<Json::Reader::ErrorInfo const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Block$ = -32						; size = 4
__Newoff$ = -20						; size = 4
_this$ = -8						; size = 4
??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>, COMDAT
; _this$ = ecx

; 1155 : 		void emplace_back(_Valty&&... _Val)

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1156 : 		{	// insert element at end
; 1157 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1158 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@emplace_ba
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], ecx
	ja	SHORT $LN2@emplace_ba
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@emplace_ba:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR __Newoff$[ebp], ecx
	mov	eax, DWORD PTR __Newoff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	jne	SHORT $LN1@emplace_ba
	push	1
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@emplace_ba:

; 1159 : 		this->_Getal().construct(
; 1160 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1161 : 			_STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 1
	div	esi
	imul	edx, edx, 44
	mov	eax, DWORD PTR __Block$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct

; 1162 : 		_PUSH_BACK_END;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1163 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z
_TEXT	SEGMENT
tv395 = -632						; size = 4
tv408 = -628						; size = 4
tv403 = -628						; size = 4
tv418 = -624						; size = 4
tv400 = -624						; size = 4
tv415 = -620						; size = 4
tv397 = -620						; size = 4
tv444 = -616						; size = 4
tv437 = -616						; size = 4
tv413 = -612						; size = 4
tv394 = -612						; size = 4
tv443 = -608						; size = 4
tv436 = -608						; size = 4
tv410 = -604						; size = 4
tv392 = -604						; size = 4
tv388 = -604						; size = 4
tv442 = -600						; size = 4
tv435 = -600						; size = 4
tv385 = -600						; size = 4
tv380 = -600						; size = 4
tv421 = -596						; size = 4
tv407 = -596						; size = 4
tv390 = -596						; size = 4
tv383 = -596						; size = 4
tv377 = -596						; size = 4
tv373 = -596						; size = 4
tv446 = -592						; size = 4
tv441 = -592						; size = 4
tv440 = -592						; size = 4
tv434 = -592						; size = 4
tv433 = -592						; size = 4
tv432 = -592						; size = 4
tv429 = -592						; size = 4
tv365 = -592						; size = 4
tv439 = -589						; size = 1
tv431 = -589						; size = 1
$T2 = -584						; size = 12
$T3 = -564						; size = 4
$T4 = -552						; size = 4
$T5 = -540						; size = 4
$T6 = -528						; size = 12
$T7 = -508						; size = 4
$T8 = -496						; size = 4
$T9 = -484						; size = 12
$T10 = -464						; size = 12
$T11 = -444						; size = 4
$T12 = -432						; size = 12
$T13 = -412						; size = 4
$T14 = -400						; size = 12
$T15 = -380						; size = 4
$T16 = -368						; size = 4
$T17 = -356						; size = 12
$T18 = -336						; size = 4
$T19 = -324						; size = 12
$T20 = -304						; size = 12
$T21 = -284						; size = 12
$T22 = -264						; size = 4
__Num$23 = -60						; size = 4
__Oldsize$ = -48					; size = 4
__Off$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
__First$ = 24						; size = 12
__Last$ = 36						; size = 12
??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; _this$ = ecx

; 1545 : 		typename enable_if<_Is_iterator<_Iter>::value,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 616				; 00000268H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-632]
	mov	ecx, 154				; 0000009aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T22[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1546 : 			iterator>::type
; 1547 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1548 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1549 : 		size_type _Off = _Where - begin();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv365[ebp], eax
	mov	ecx, DWORD PTR tv365[ebp]
	mov	DWORD PTR tv373[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	edx, DWORD PTR tv373[ebp]
	push	edx
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
	mov	DWORD PTR __Off$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 1550 : 
; 1551 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1552 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN17@insert

; 1553 : 			_DEBUG_ERROR("deque insert iterator outside range");

	mov	esi, esp
	push	1553					; 00000611H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EI@ODOAHAHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@insert:

; 1554 : 		_DEBUG_RANGE(_First, _Last);

	push	1554					; 00000612H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv429[ebp], eax
	mov	ecx, DWORD PTR tv429[ebp]
	mov	DWORD PTR tv377[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv380[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 32					; 00000020H

; 1555 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1556 : 
; 1557 : 		size_type _Oldsize = this->_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldsize$[ebp], ecx

; 1558 : 
; 1559 : 		if (_First == _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@insert
	jmp	$LN15@insert
$LN16@insert:

; 1560 : 			;
; 1561 : 		else if (_Off <= this->_Mysize / 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	shr	ecx, 1
	cmp	DWORD PTR __Off$[ebp], ecx
	ja	$LN14@insert

; 1562 : 			{	// closer to front, push to front then rotate
; 1563 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 5

; 1564 : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN12@insert
$LN11@insert:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
$LN12@insert:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	mov	BYTE PTR tv431[ebp], al
	movzx	ecx, BYTE PTR tv431[ebp]
	test	ecx, ecx
	je	SHORT $LN10@insert

; 1565 : 				push_front(*_First);	// prepend flipped

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	mov	DWORD PTR tv432[ebp], eax
	mov	eax, DWORD PTR tv432[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
	jmp	SHORT $LN11@insert
$LN10@insert:
	jmp	SHORT $LN20@insert
__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$0:
$LN9@insert:

; 1566 : 
; 1567 : 			_CATCH_ALL
; 1568 : 			for (; _Oldsize < this->_Mysize; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Oldsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN8@insert

; 1569 : 				pop_front();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
	jmp	SHORT $LN9@insert
$LN8@insert:

; 1570 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1571 : 			_CATCH_END

	mov	eax, $LN50@insert
	ret	0
$LN20@insert:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	jmp	SHORT __tryend$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$1
$LN50@insert:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
__tryend$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$1:

; 1572 : 
; 1573 : 			size_type _Num = this->_Mysize - _Oldsize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Oldsize$[ebp]
	mov	DWORD PTR __Num$23[ebp], ecx

; 1574 : 			_STD reverse(begin(), begin() + _Num);	// flip new stuff in place

	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv433[ebp], eax
	mov	ecx, DWORD PTR tv433[ebp]
	mov	DWORD PTR tv383[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T5[ebp], esp
	mov	eax, DWORD PTR __Num$23[ebp]
	push	eax
	push	edx
	mov	ecx, DWORD PTR tv383[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	DWORD PTR tv385[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T7[ebp], esp
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv388[ebp], eax
	call	??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 1575 : 			_STD rotate(begin(), begin() + _Num, begin() + _Num + _Off);

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv434[ebp], eax
	mov	ecx, DWORD PTR tv434[ebp]
	mov	DWORD PTR tv390[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 8
	mov	edx, DWORD PTR __Num$23[ebp]
	push	edx
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	mov	ecx, DWORD PTR tv390[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	DWORD PTR tv435[ebp], eax
	mov	ecx, DWORD PTR tv435[ebp]
	mov	DWORD PTR tv392[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 9
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T8[ebp], esp
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	push	edx
	mov	ecx, DWORD PTR tv392[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	DWORD PTR tv436[ebp], eax
	mov	ecx, DWORD PTR tv436[ebp]
	mov	DWORD PTR tv394[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 10		; 0000000aH
	lea	edx, DWORD PTR $T12[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv437[ebp], eax
	mov	eax, DWORD PTR tv437[ebp]
	mov	DWORD PTR tv397[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 11		; 0000000bH
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T11[ebp], esp
	mov	edx, DWORD PTR __Num$23[ebp]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR tv397[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	DWORD PTR tv400[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T13[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv403[ebp], eax
	lea	ecx, DWORD PTR $T14[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 12		; 0000000cH
	call	??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv395[ebp], eax
	lea	ecx, DWORD PTR $T14[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 9
	lea	ecx, DWORD PTR $T12[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 8
	lea	ecx, DWORD PTR $T10[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 1576 : 			}
; 1577 : 		else

	jmp	$LN15@insert
$LN14@insert:

; 1578 : 			{	// closer to back
; 1579 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 13		; 0000000dH

; 1580 : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN5@insert
$LN4@insert:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
$LN5@insert:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	mov	BYTE PTR tv439[ebp], al
	movzx	ecx, BYTE PTR tv439[ebp]
	test	ecx, ecx
	je	SHORT $LN3@insert

; 1581 : 				push_back(*_First);	// append

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	mov	DWORD PTR tv440[ebp], eax
	mov	eax, DWORD PTR tv440[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	jmp	SHORT $LN4@insert
$LN3@insert:
	jmp	SHORT $LN22@insert
__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$2:
$LN2@insert:

; 1582 : 
; 1583 : 			_CATCH_ALL
; 1584 : 			for (; _Oldsize < this->_Mysize; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Oldsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN1@insert

; 1585 : 				pop_back();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
	jmp	SHORT $LN2@insert
$LN1@insert:

; 1586 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1587 : 			_CATCH_END

	mov	eax, $LN52@insert
	ret	0
$LN22@insert:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	jmp	SHORT __tryend$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$3
$LN52@insert:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
__tryend$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$3:

; 1588 : 
; 1589 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T15[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	DWORD PTR tv441[ebp], eax
	mov	ecx, DWORD PTR tv441[ebp]
	mov	DWORD PTR tv407[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 15		; 0000000fH
	lea	edx, DWORD PTR $T17[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv442[ebp], eax
	mov	eax, DWORD PTR tv442[ebp]
	mov	DWORD PTR tv410[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 16		; 00000010H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T16[ebp], esp
	mov	edx, DWORD PTR __Oldsize$[ebp]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR tv410[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	DWORD PTR tv443[ebp], eax
	mov	eax, DWORD PTR tv443[ebp]
	mov	DWORD PTR tv413[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 17		; 00000011H
	lea	ecx, DWORD PTR $T19[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv444[ebp], eax
	mov	edx, DWORD PTR tv444[ebp]
	mov	DWORD PTR tv415[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 18		; 00000012H
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T18[ebp], esp
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	push	eax
	mov	ecx, DWORD PTR tv415[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	DWORD PTR tv418[ebp], eax
	lea	edx, DWORD PTR $T20[ebp]
	push	edx
	mov	BYTE PTR __$EHRec$[ebp+12], 20		; 00000014H
	call	??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv408[ebp], eax
	lea	ecx, DWORD PTR $T20[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 19		; 00000013H
	lea	ecx, DWORD PTR $T19[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T17[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
$LN15@insert:

; 1590 : 			}
; 1591 : 		return (begin() + _Off);

	lea	eax, DWORD PTR $T21[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv446[ebp], eax
	mov	ecx, DWORD PTR tv446[ebp]
	mov	DWORD PTR tv421[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 21		; 00000015H
	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv421[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	ecx, DWORD PTR $T22[ebp]
	or	ecx, 1
	mov	DWORD PTR $T22[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T21[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@insert:

; 1592 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 632				; 00000278H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$4:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$5:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$6:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$7:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$8:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$10:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$13:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$14:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$15:
	mov	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$16:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$20:
	mov	ecx, DWORD PTR $T15[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$21:
	lea	ecx, DWORD PTR $T17[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$22:
	mov	ecx, DWORD PTR $T16[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$23:
	lea	ecx, DWORD PTR $T19[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$26:
	lea	ecx, DWORD PTR $T21[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-636]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
tv140 = -376						; size = 4
tv236 = -372						; size = 4
tv235 = -368						; size = 4
tv232 = -364						; size = 4
tv231 = -360						; size = 4
tv228 = -356						; size = 4
tv223 = -356						; size = 4
tv242 = -352						; size = 4
tv220 = -352						; size = 4
tv225 = -348						; size = 4
tv73 = -348						; size = 4
$T2 = -340						; size = 4
$T3 = -328						; size = 4
$T4 = -313						; size = 1
$T5 = -304						; size = 4
$T6 = -292						; size = 4
$T7 = -280						; size = 4
$T8 = -268						; size = 8
$T9 = -252						; size = 4
$T10 = -240						; size = 8
$T11 = -224						; size = 4
$T12 = -209						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z PROC ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 2124 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 364				; 0000016cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-376]
	mov	ecx, 91					; 0000005bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T11[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2125 : 	if (_First == _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@copy

; 2126 : 		return (_Dest);

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T11[ebp]
	or	ecx, 1
	mov	DWORD PTR $T11[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN3@copy

; 2127 : 	else

	jmp	$LN1@copy
$LN2@copy:

; 2128 : 		{	// worth copying, check then copy
; 2129 : 		_DEBUG_RANGE(_First, _Last);

	push	2129					; 00000851H
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv220[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv223[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Debug_range@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 32					; 00000020H

; 2130 : 		_DEBUG_POINTER(_Dest);

	push	2130					; 00000852H
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Debug_pointer@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 12					; 0000000cH

; 2131 : 		return (_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2132 : 			_Dest, _Is_checked(_Dest)));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv225[ebp], eax
	call	??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR $T12[ebp], al
	mov	cl, BYTE PTR $T12[ebp]
	mov	BYTE PTR $T4[ebp], cl
	movzx	edx, BYTE PTR $T4[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T6[ebp], esp
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv242[ebp], eax
	mov	ecx, DWORD PTR tv242[ebp]
	mov	DWORD PTR tv228[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T7[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv231[ebp], eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv232[ebp], eax
	mov	ecx, DWORD PTR tv232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T9[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv235[ebp], eax
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv236[ebp], eax
	mov	ecx, DWORD PTR tv236[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$_Copy_impl@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U?$integral_constant@_N$00@0@@Z ; std::_Copy_impl<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H
	mov	DWORD PTR tv140[ebp], eax
	mov	edx, DWORD PTR $T11[ebp]
	or	edx, 1
	mov	DWORD PTR $T11[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@copy
$LN1@copy:

; 2133 : 		}
; 2134 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
$LN3@copy:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 376				; 00000178H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z$1:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z$2:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z$4:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z$7:
	mov	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-380]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ENDP ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-, COMDAT
; _this$ = ecx

; 661  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 662  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-

; 663  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
$T2 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+, COMDAT
; _this$ = ecx

; 644  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 645  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 646  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=, COMDAT
; _this$ = ecx

; 638  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 639  : 		this->_Myoff += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 640  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 641  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--, COMDAT
; _this$ = ecx

; 625  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 626  : 		--*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--

; 627  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 628  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++, COMDAT
; _this$ = ecx

; 612  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 613  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++

; 614  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 615  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*, COMDAT
; _this$ = ecx

; 602  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*

; 604  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked, COMDAT
; _this$ = ecx

; 597  : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 598  : 		return (_Unchecked_type(this->_Myoff, this->_Getcont()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 585  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >

; 586  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z PROC ; std::operator!=<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >, COMDAT

; 900  : 	{	// test for allocator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 901  : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ; std::operator==<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 902  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?9V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
tv85 = -224						; size = 4
tv84 = -221						; size = 1
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; _this$ = ecx

; 1011 : 		void _Construct(_Iter _First, _Iter _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 1012 : 		{	// initialize from [_First, _Last), input iterators
; 1013 : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 1014 : 
; 1015 : 		for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Construct
$LN2@Construct:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
$LN3@Construct:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	mov	BYTE PTR tv84[ebp], al
	movzx	ecx, BYTE PTR tv84[ebp]
	test	ecx, ecx
	je	SHORT $LN1@Construct

; 1016 : 			emplace_back(*_First);

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	mov	DWORD PTR tv85[ebp], eax
	mov	eax, DWORD PTR tv85[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<Json::Reader::ErrorInfo const &>
	jmp	SHORT $LN2@Construct
$LN1@Construct:
	jmp	SHORT $LN7@Construct
__catch$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$0:

; 1017 : 
; 1018 : 		_CATCH_ALL
; 1019 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 1020 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1021 : 		_CATCH_END

	mov	eax, $LN12@Construct
	ret	0
$LN7@Construct:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$1
$LN12@Construct:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$1:

; 1022 : 		}

	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
$LN6@Construct:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$2:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$3:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z PROC ; std::move<Json::Value * &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ENDP ; std::move<Json::Value * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT

; 900  : 	{	// test for allocator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 901  : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator==<std::allocator<char>,std::allocator<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 902  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Setcont, COMDAT
; _this$ = ecx

; 507  : 		{	// set container pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 508  : 		this->_Adopt(_Pdeque);

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 509  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Compat, COMDAT
; _this$ = ecx

; 496  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 498  : 		if (_Mycont == 0
; 499  : 			|| _Mycont != _Right._Getcont())

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN1@Compat
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	DWORD PTR __Mycont$[ebp], eax
	je	$LN3@Compat
$LN1@Compat:

; 500  : 			{	// report error
; 501  : 			_DEBUG_ERROR("deque iterators incompatible");

	mov	esi, esp
	push	501					; 000001f5H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DK@CNDLFKCJ@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 502  : 			_SCL_SECURE_INVALID_ARGUMENT;

	mov	eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	eax, eax
	je	SHORT $LN5@Compat
	xor	ecx, ecx
	jne	SHORT $LN6@Compat
$LN5@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	502					; 000001f6H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@Compat
	int	3
$LN6@Compat:
	mov	esi, esp
	push	0
	push	502					; 000001f6H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1PK@ILLLEIAJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Compat:

; 503  : 			}
; 504  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator<, COMDAT
; _this$ = ecx

; 474  : 		{	// test if this < _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 475  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Compat

; 476  : 		return (this->_Myoff < _Right._Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 477  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator<
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=, COMDAT
; _this$ = ecx

; 469  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 471  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==, COMDAT
; _this$ = ecx

; 463  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 464  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Compat

; 465  : 		return (this->_Myoff == _Right._Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 466  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
tv76 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-, COMDAT
; _this$ = ecx

; 450  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 451  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Compat

; 452  : 		return (_Right._Myoff <= this->_Myoff
; 453  : 			? this->_Myoff - _Right._Myoff
; 454  : 			: -(difference_type)(_Right._Myoff - this->_Myoff));

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv76[ebp], edx
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	neg	edx
	mov	DWORD PTR tv76[ebp], edx
$LN4@operator:
	mov	eax, DWORD PTR tv76[ebp]

; 455  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
$T2 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+, COMDAT
; _this$ = ecx

; 433  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 434  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 435  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 436  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=, COMDAT
; _this$ = ecx

; 410  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 411  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 412  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 413  : 		if (_Mycont == 0
; 414  : 			|| this->_Myoff + _Off < _Mycont->_Myoff
; 415  : 			|| _Mycont->_Myoff + _Mycont->_Mysize < this->_Myoff + _Off)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Mycont$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN1@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Mycont$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	add	edx, DWORD PTR __Off$[ebp]
	cmp	ecx, edx
	jae	$LN2@operator
$LN1@operator:

; 416  : 			{	// report error
; 417  : 			_DEBUG_ERROR("deque iterator + offset out of range");

	mov	esi, esp
	push	417					; 000001a1H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EK@DEGNOCIK@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 418  : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	418					; 000001a2H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	418					; 000001a2H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1BAC@HLMALIEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 419  : 			}
; 420  : 
; 421  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 422  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 423  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 424  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff + _Off
; 425  : 			&& this->_Myoff + _Off <= _Mycont->_Myoff + _Mycont->_Mysize);
; 426  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 427  : 
; 428  : 		_Myoff += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 429  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 430  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--, COMDAT
; _this$ = ecx

; 382  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 383  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 384  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 385  : 		if (_Mycont == 0
; 386  : 			|| this->_Myoff <= _Mycont->_Myoff)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	ja	$LN2@operator
$LN1@operator:

; 387  : 		{	// report error
; 388  : 		_DEBUG_ERROR("deque iterator not decrementable");

	mov	esi, esp
	push	388					; 00000184H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EC@IJLEGPJO@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 389  : 		_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	389					; 00000185H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	389					; 00000185H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1BAC@PNIAAMMP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 390  : 		}
; 391  : 
; 392  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 393  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 394  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 395  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff < this->_Myoff);
; 396  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 397  : 
; 398  : 		--_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 399  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 400  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++, COMDAT
; _this$ = ecx

; 353  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 355  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 356  : 		if (_Mycont == 0
; 357  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Mycont$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	$LN2@operator
$LN1@operator:

; 358  : 		{	// report error
; 359  : 		_DEBUG_ERROR("deque iterator not incrementable");

	mov	esi, esp
	push	359					; 00000167H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EC@CEAHEOFL@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 360  : 		_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	360					; 00000168H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	360					; 00000168H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1BAC@OLCLAAO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 361  : 		}
; 362  : 
; 363  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 364  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 365  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 366  : 		_SCL_SECURE_VALIDATE_RANGE(
; 367  : 			this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 368  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 369  : 
; 370  : 		++_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 371  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 372  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
__Off$ = -44						; size = 4
__Block$ = -32						; size = 4
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jb	SHORT $LN1@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Mycont$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	$LN2@operator
$LN1@operator:

; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");

	mov	esi, esp
	push	330					; 0000014aH
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EE@INPCGGNP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 331  : 		_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	331					; 0000014bH
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	331					; 0000014bH
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1BAA@PADCGMJP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR __Mycont$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	mov	DWORD PTR __Off$[ebp], edx

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	eax, DWORD PTR __Off$[ebp], 44
	mov	edx, DWORD PTR __Block$[ebp]
	add	eax, DWORD PTR [ecx+edx*4]

; 345  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked, COMDAT
; _this$ = ecx

; 317  : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 318  : 		return (_Unchecked_type(_Myoff, this->_Getcont()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 319  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 302  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 303  : 		{	// construct with offset _Off in *_Pdeque
; 304  : 		_Setcont((_Mydeque *)_Pdeque);

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Setcont

; 305  : 		_Myoff = _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 306  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
__ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2448 : 	{	// return string + NTCS

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T1[ebp], 0

; 2449 : 	return (_STD move(_Left.append(_Right)));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	push	eax
	call	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2450 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2428 : 	{	// return NTCS + string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T1[ebp], 0

; 2429 : 	return (_STD move(_Right.insert(0, _Left)));

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	push	eax
	call	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2430 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
$T2 = -252						; size = 4
__Ans$ = -48						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2338 : 	{	// return NTCS + string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0

; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;

	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	add	esi, eax
	push	esi
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2341 : 	_Ans += _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 2342 : 	_Ans += _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 2343 : 	return (_Ans);

	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2344 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-48					; ffffffd0H
	DD	28					; 0000001cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z$0:
	lea	ecx, DWORD PTR __Ans$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
tv201 = -304						; size = 4
tv199 = -304						; size = 4
tv202 = -300						; size = 4
tv200 = -300						; size = 4
tv65 = -300						; size = 4
$T2 = -292						; size = 4
$T3 = -280						; size = 4
__Meta$4 = -76						; size = 4
__Metadelim$5 = -64					; size = 4
__Ok$ = -52						; size = 8
__Changed$ = -33					; size = 1
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 76   : 	{	// get characters into string, discard delimiter

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 77   : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 78   : 
; 79   : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 80   : 	bool _Changed = false;

	mov	BYTE PTR __Changed$[ebp], 0

; 81   : 	const typename _Myis::sentry _Ok(_Istr, true);

	push	1
	mov	eax, DWORD PTR __Istr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 82   : 
; 83   : 	if (_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN12@getline

; 84   : 		{	// state okay, extract characters
; 85   : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 86   : 		_Str.erase();

	push	0
	mov	ecx, DWORD PTR __Str$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 87   : 		const typename _Traits::int_type _Metadelim =
; 88   : 			_Traits::to_int_type(_Delim);

	lea	eax, DWORD PTR __Delim$[ebp]
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	DWORD PTR __Metadelim$5[ebp], eax

; 89   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

	mov	eax, DWORD PTR __Istr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Istr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv65[ebp], eax
	mov	esi, esp
	mov	ecx, DWORD PTR tv65[ebp]
	call	DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR tv199[ebp]
	mov	DWORD PTR __Meta$4[ebp], eax
	jmp	SHORT $LN10@getline
$LN9@getline:

; 90   : 
; 91   : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

	mov	eax, DWORD PTR __Istr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Istr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv200[ebp], eax
	mov	esi, esp
	mov	ecx, DWORD PTR tv200[ebp]
	call	DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv201[ebp], eax
	mov	eax, DWORD PTR tv201[ebp]
	mov	DWORD PTR __Meta$4[ebp], eax
$LN10@getline:

; 92   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T2[ebp], eax
	lea	eax, DWORD PTR __Meta$4[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@getline

; 93   : 				{	// end of file, quit
; 94   : 				_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 1
	mov	DWORD PTR __State$[ebp], eax

; 95   : 				break;

	jmp	$LN8@getline
	jmp	$LN6@getline
$LN7@getline:

; 96   : 				}
; 97   : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

	lea	eax, DWORD PTR __Metadelim$5[ebp]
	push	eax
	lea	ecx, DWORD PTR __Meta$4[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@getline

; 98   : 				{	// got a delimiter, discard it and quit
; 99   : 				_Changed = true;

	mov	BYTE PTR __Changed$[ebp], 1

; 100  : 				_Istr.rdbuf()->sbumpc();

	mov	eax, DWORD PTR __Istr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Istr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv202[ebp], eax
	mov	esi, esp
	mov	ecx, DWORD PTR tv202[ebp]
	call	DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 101  : 				break;

	jmp	SHORT $LN8@getline
	jmp	SHORT $LN6@getline
$LN5@getline:

; 102  : 				}
; 103  : 			else if (_Str.max_size() <= _Str.size())

	mov	ecx, DWORD PTR __Str$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR __Str$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, esi
	ja	SHORT $LN3@getline

; 104  : 				{	// string too large, quit
; 105  : 				_State |= ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 2
	mov	DWORD PTR __State$[ebp], eax

; 106  : 				break;

	jmp	SHORT $LN8@getline

; 107  : 				}
; 108  : 			else

	jmp	SHORT $LN6@getline
$LN3@getline:

; 109  : 				{	// got a character, add it to string
; 110  : 				_Str += _Traits::to_char_type(_Meta);

	lea	eax, DWORD PTR __Meta$4[ebp]
	push	eax
	call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type
	add	esp, 4
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR __Str$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 111  : 				_Changed = true;

	mov	BYTE PTR __Changed$[ebp], 1
$LN6@getline:

; 112  : 				}

	jmp	$LN9@getline
$LN8@getline:
	jmp	SHORT $LN15@getline
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:

; 113  : 		_CATCH_IO_(_Istr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Istr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Istr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, $LN19@getline
	ret	0
$LN15@getline:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN12@getline
$LN19@getline:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN12@getline:

; 114  : 		}
; 115  : 
; 116  : 	if (!_Changed)

	movzx	eax, BYTE PTR __Changed$[ebp]
	test	eax, eax
	jne	SHORT $LN1@getline

; 117  : 		_State |= ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 2
	mov	DWORD PTR __State$[ebp], eax
$LN1@getline:

; 118  : 	_Istr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Istr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Istr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 119  : 	return (_Istr);

	mov	eax, DWORD PTR __Istr$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]

; 120  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@getline
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@getline:
	DD	3
	DD	$LN24@getline
$LN24@getline:
	DD	-52					; ffffffccH
	DD	8
	DD	$LN20@getline
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN21@getline
	DD	-76					; ffffffb4H
	DD	4
	DD	$LN22@getline
$LN22@getline:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$LN21@getline:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	0
$LN20@getline:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-308]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 149  : 	{	// get characters into string, discard delimiter

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 150  : 	return (getline(_STD move(_Istr), _Str, _Delim));

	movzx	eax, BYTE PTR __Delim$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Istr$[ebp]
	push	edx
	call	??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
	add	esp, 4
	push	eax
	call	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH

; 151  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
$T2 = -252						; size = 4
_result$ = -48						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_cp$ = 12						; size = 4
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; Json::codePointToUTF8, COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0

; 71   :    std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 72   :    
; 73   :    // based on description from http://en.wikipedia.org/wiki/UTF-8
; 74   : 
; 75   :    if (cp <= 0x7f) 

	cmp	DWORD PTR _cp$[ebp], 127		; 0000007fH
	ja	SHORT $LN7@codePointT

; 76   :    {
; 77   :       result.resize(1);

	push	1
	lea	ecx, DWORD PTR _result$[ebp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 78   :       result[0] = static_cast<char>(cp);

	push	0
	lea	ecx, DWORD PTR _result$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	cl, BYTE PTR _cp$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	$LN6@codePointT
$LN7@codePointT:

; 79   :    } 
; 80   :    else if (cp <= 0x7FF) 

	cmp	DWORD PTR _cp$[ebp], 2047		; 000007ffH
	ja	SHORT $LN5@codePointT

; 81   :    {
; 82   :       result.resize(2);

	push	2
	lea	ecx, DWORD PTR _result$[ebp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 83   :       result[1] = static_cast<char>(0x80 | (0x3f & cp));

	mov	ebx, DWORD PTR _cp$[ebp]
	and	ebx, 63					; 0000003fH
	or	ebx, 128				; 00000080H
	push	1
	lea	ecx, DWORD PTR _result$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	BYTE PTR [eax], bl

; 84   :       result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));

	mov	ebx, DWORD PTR _cp$[ebp]
	shr	ebx, 6
	and	ebx, 31					; 0000001fH
	or	ebx, 192				; 000000c0H
	push	0
	lea	ecx, DWORD PTR _result$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	BYTE PTR [eax], bl
	jmp	$LN6@codePointT
$LN5@codePointT:

; 85   :    } 
; 86   :    else if (cp <= 0xFFFF) 

	cmp	DWORD PTR _cp$[ebp], 65535		; 0000ffffH
	ja	SHORT $LN3@codePointT

; 87   :    {
; 88   :       result.resize(3);

	push	3
	lea	ecx, DWORD PTR _result$[ebp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 89   :       result[2] = static_cast<char>(0x80 | (0x3f & cp));

	mov	ebx, DWORD PTR _cp$[ebp]
	and	ebx, 63					; 0000003fH
	or	ebx, 128				; 00000080H
	push	2
	lea	ecx, DWORD PTR _result$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	BYTE PTR [eax], bl

; 90   :       result[1] = 0x80 | static_cast<char>((0x3f & (cp >> 6)));

	mov	eax, DWORD PTR _cp$[ebp]
	shr	eax, 6
	and	eax, 63					; 0000003fH
	movsx	ebx, al
	or	ebx, 128				; 00000080H
	push	1
	lea	ecx, DWORD PTR _result$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	BYTE PTR [eax], bl

; 91   :       result[0] = 0xE0 | static_cast<char>((0xf & (cp >> 12)));

	mov	eax, DWORD PTR _cp$[ebp]
	shr	eax, 12					; 0000000cH
	and	eax, 15					; 0000000fH
	movsx	ebx, al
	or	ebx, 224				; 000000e0H
	push	0
	lea	ecx, DWORD PTR _result$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	BYTE PTR [eax], bl
	jmp	SHORT $LN6@codePointT
$LN3@codePointT:

; 92   :    }
; 93   :    else if (cp <= 0x10FFFF) 

	cmp	DWORD PTR _cp$[ebp], 1114111		; 0010ffffH
	ja	SHORT $LN6@codePointT

; 94   :    {
; 95   :       result.resize(4);

	push	4
	lea	ecx, DWORD PTR _result$[ebp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 96   :       result[3] = static_cast<char>(0x80 | (0x3f & cp));

	mov	ebx, DWORD PTR _cp$[ebp]
	and	ebx, 63					; 0000003fH
	or	ebx, 128				; 00000080H
	push	3
	lea	ecx, DWORD PTR _result$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	BYTE PTR [eax], bl

; 97   :       result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));

	mov	ebx, DWORD PTR _cp$[ebp]
	shr	ebx, 6
	and	ebx, 63					; 0000003fH
	or	ebx, 128				; 00000080H
	push	2
	lea	ecx, DWORD PTR _result$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	BYTE PTR [eax], bl

; 98   :       result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));

	mov	ebx, DWORD PTR _cp$[ebp]
	shr	ebx, 12					; 0000000cH
	and	ebx, 63					; 0000003fH
	or	ebx, 128				; 00000080H
	push	1
	lea	ecx, DWORD PTR _result$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	BYTE PTR [eax], bl

; 99   :       result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));

	mov	ebx, DWORD PTR _cp$[ebp]
	shr	ebx, 18					; 00000012H
	and	ebx, 7
	or	ebx, 240				; 000000f0H
	push	0
	lea	ecx, DWORD PTR _result$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	BYTE PTR [eax], bl
$LN6@codePointT:

; 100  :    }
; 101  : 
; 102  :    return result;

	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 103  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@codePointT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@codePointT:
	DD	1
	DD	$LN15@codePointT
$LN15@codePointT:
	DD	-48					; ffffffd0H
	DD	28					; 0000001cH
	DD	$LN13@codePointT
$LN13@codePointT:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; Json::codePointToUTF8
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?containsNewLine@Json@@YA_NPBD0@Z
_TEXT	SEGMENT
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
?containsNewLine@Json@@YA_NPBD0@Z PROC			; Json::containsNewLine, COMDAT

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 63   :    for ( ;begin < end; ++begin )

	jmp	SHORT $LN5@containsNe
$LN4@containsNe:
	mov	eax, DWORD PTR _begin$[ebp]
	add	eax, 1
	mov	DWORD PTR _begin$[ebp], eax
$LN5@containsNe:
	mov	eax, DWORD PTR _begin$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jae	SHORT $LN3@containsNe

; 64   :       if ( *begin == '\n'  ||  *begin == '\r' )

	mov	eax, DWORD PTR _begin$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN1@containsNe
	mov	eax, DWORD PTR _begin$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN2@containsNe
$LN1@containsNe:

; 65   :          return true;

	mov	al, 1
	jmp	SHORT $LN6@containsNe
$LN2@containsNe:

; 66   :    return false;

	jmp	SHORT $LN4@containsNe
$LN3@containsNe:
	xor	al, al
$LN6@containsNe:

; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?containsNewLine@Json@@YA_NPBD0@Z ENDP			; Json::containsNewLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?in@Json@@YA_NDDDDDD@Z
_TEXT	SEGMENT
tv79 = -196						; size = 4
_c$ = 8							; size = 1
_c1$ = 12						; size = 1
_c2$ = 16						; size = 1
_c3$ = 20						; size = 1
_c4$ = 24						; size = 1
_c5$ = 28						; size = 1
?in@Json@@YA_NDDDDDD@Z PROC				; Json::in, COMDAT

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 55   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

	movsx	eax, BYTE PTR _c$[ebp]
	movsx	ecx, BYTE PTR _c1$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@in
	movsx	edx, BYTE PTR _c$[ebp]
	movsx	eax, BYTE PTR _c2$[ebp]
	cmp	edx, eax
	je	SHORT $LN3@in
	movsx	ecx, BYTE PTR _c$[ebp]
	movsx	edx, BYTE PTR _c3$[ebp]
	cmp	ecx, edx
	je	SHORT $LN3@in
	movsx	eax, BYTE PTR _c$[ebp]
	movsx	ecx, BYTE PTR _c4$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@in
	movsx	edx, BYTE PTR _c$[ebp]
	movsx	eax, BYTE PTR _c5$[ebp]
	cmp	edx, eax
	je	SHORT $LN3@in
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $LN4@in
$LN3@in:
	mov	DWORD PTR tv79[ebp], 1
$LN4@in:
	mov	al, BYTE PTR tv79[ebp]

; 56   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?in@Json@@YA_NDDDDDD@Z ENDP				; Json::in
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?in@Json@@YA_NDDDDD@Z
_TEXT	SEGMENT
tv76 = -196						; size = 4
_c$ = 8							; size = 1
_c1$ = 12						; size = 1
_c2$ = 16						; size = 1
_c3$ = 20						; size = 1
_c4$ = 24						; size = 1
?in@Json@@YA_NDDDDD@Z PROC				; Json::in, COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 49   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

	movsx	eax, BYTE PTR _c$[ebp]
	movsx	ecx, BYTE PTR _c1$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@in
	movsx	edx, BYTE PTR _c$[ebp]
	movsx	eax, BYTE PTR _c2$[ebp]
	cmp	edx, eax
	je	SHORT $LN3@in
	movsx	ecx, BYTE PTR _c$[ebp]
	movsx	edx, BYTE PTR _c3$[ebp]
	cmp	ecx, edx
	je	SHORT $LN3@in
	movsx	eax, BYTE PTR _c$[ebp]
	movsx	ecx, BYTE PTR _c4$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@in
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN4@in
$LN3@in:
	mov	DWORD PTR tv76[ebp], 1
$LN4@in:
	mov	al, BYTE PTR tv76[ebp]

; 50   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?in@Json@@YA_NDDDDD@Z ENDP				; Json::in
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
_TEXT	SEGMENT
tv85 = -424						; size = 4
tv65 = -420						; size = 4
$T2 = -412						; size = 28
$T3 = -376						; size = 12
$T4 = -356						; size = 4
_ok$ = -149						; size = 1
_reader$ = -140						; size = 120
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sin$ = 8						; size = 4
_root$ = 12						; size = 4
??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z PROC ; Json::operator>>, COMDAT

; 876  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 412				; 0000019cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-424]
	mov	ecx, 103				; 00000067H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 877  :     Json::Reader reader;

	lea	ecx, DWORD PTR _reader$[ebp]
	call	??0Reader@Json@@QAE@XZ			; Json::Reader::Reader
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 878  :     bool ok = reader.parse(sin, root, true);

	push	1
	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sin$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _reader$[ebp]
	call	?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
	mov	BYTE PTR _ok$[ebp], al

; 879  :     //JSON_ASSERT( ok );
; 880  :     if (!ok) throw std::runtime_error(reader.getFormatedErrorMessages());

	movzx	eax, BYTE PTR _ok$[ebp]
	test	eax, eax
	jne	SHORT $LN1@operator
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _reader$[ebp]
	call	?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Reader::getFormatedErrorMessages
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv85[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv85[ebp]
	push	edx
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@operator:

; 881  :     return sin;

	mov	eax, DWORD PTR _sin$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _reader$[ebp]
	call	??1Reader@Json@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]
$LN3@operator:

; 882  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 424				; 000001a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-140					; ffffff74H
	DD	120					; 00000078H
	DD	$LN6@operator
$LN6@operator:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$0:
	lea	ecx, DWORD PTR _reader$[ebp]
	jmp	??1Reader@Json@@QAE@XZ
__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-428]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z ENDP ; Json::operator>>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4Reader@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4Reader@Json@@QAEAAV01@ABV01@@Z PROC			; Json::Reader::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cx, WORD PTR [eax+116]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+116], cx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+118]
	mov	BYTE PTR [eax+118], dl
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4Reader@Json@@QAEAAV01@ABV01@@Z ENDP			; Json::Reader::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0Reader@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Reader@Json@@QAE@ABV01@@Z PROC			; Json::Reader::Reader, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cx, WORD PTR [eax+116]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+116], cx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+118]
	mov	BYTE PTR [eax+118], dl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0Reader@Json@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@ABV01@@Z ENDP			; Json::Reader::Reader
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1Reader@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1Reader@Json@@QAE@XZ PROC				; Json::Reader::~Reader, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1Reader@Json@@QAE@XZ ENDP				; Json::Reader::~Reader
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z
_TEXT	SEGMENT
tv77 = -256						; size = 4
__Pnext$ = -56						; size = 4
__Lock$ = -44						; size = 4
__Offhigh$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Offlo$ = 8						; size = 4
?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Orphan_off, COMDAT
; _this$ = ecx

; 1849 : 		{	// orphan iterators with specified offset(s)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1850 : 		size_type _Offhigh = this->_Myoff + this->_Mysize <= _Offlo + 1
; 1851 : 			? (size_type)(-1) : _Offlo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR __Offlo$[ebp]
	add	eax, 1
	cmp	ecx, eax
	ja	SHORT $LN10@Orphan_off
	mov	DWORD PTR tv77[ebp], -1
	jmp	SHORT $LN11@Orphan_off
$LN10@Orphan_off:
	mov	ecx, DWORD PTR __Offlo$[ebp]
	mov	DWORD PTR tv77[ebp], ecx
$LN11@Orphan_off:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Offhigh$[ebp], edx

; 1852 : 		if (_Offlo == this->_Myoff)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Offlo$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jne	SHORT $LN7@Orphan_off

; 1853 : 			_Offlo = 0;

	mov	DWORD PTR __Offlo$[ebp], 0
$LN7@Orphan_off:

; 1854 : 
; 1855 : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1856 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Pnext$[ebp], eax

; 1857 : 		if (_Pnext != 0)

	cmp	DWORD PTR __Pnext$[ebp], 0
	je	SHORT $LN6@Orphan_off
$LN5@Orphan_off:

; 1858 : 			while (*_Pnext != 0)

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_off

; 1859 : 				if ((*_Pnext)->_Myoff < _Offlo
; 1860 : 					|| _Offhigh < (*_Pnext)->_Myoff)

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Offlo$[ebp]
	jb	SHORT $LN2@Orphan_off
	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Offhigh$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@Orphan_off
$LN2@Orphan_off:

; 1861 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	DWORD PTR __Pnext$[ebp], eax

; 1862 : 				else

	jmp	SHORT $LN1@Orphan_off
$LN3@Orphan_off:

; 1863 : 					{	// orphan the iterator
; 1864 : 					(*_Pnext)->_Clrcont();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Clrcont@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Clrcont

; 1865 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
$LN1@Orphan_off:

; 1866 : 					}

	jmp	SHORT $LN5@Orphan_off
$LN6@Orphan_off:

; 1867 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@Orphan_off
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN16@Orphan_off:
	DD	1
	DD	$LN15@Orphan_off
$LN15@Orphan_off:
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN13@Orphan_off
$LN13@Orphan_off:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Orphan_off
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -257						; size = 1
$T2 = -245						; size = 1
$T3 = -233						; size = 1
__Block$4 = -32						; size = 4
__Almap$ = -17						; size = 1
_this$ = -8						; size = 4
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1827 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1828 : 		_Alpty _Almap(this->_Getal());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
$LN6@Tidy:

; 1829 : 		while (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Tidy

; 1830 : 			pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
	jmp	SHORT $LN6@Tidy
$LN5@Tidy:

; 1831 : 		for (size_type _Block = this->_Mapsize; 0 < _Block; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Block$4[ebp], ecx
$LN4@Tidy:
	cmp	DWORD PTR __Block$4[ebp], 0
	jbe	SHORT $LN3@Tidy

; 1832 : 			{	// free storage for a block and destroy pointer
; 1833 : 			if (this->_Map[--_Block] != pointer())

	mov	eax, DWORD PTR __Block$4[ebp]
	sub	eax, 1
	mov	DWORD PTR __Block$4[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Block$4[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN2@Tidy

; 1834 : 				{	// free block and destroy its pointer
; 1835 : 				this->_Getal().deallocate(this->_Map[_Block], _DEQUESIZ);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$4[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::deallocate

; 1836 : 				this->_Getal().destroy(&this->_Map[_Block]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$4[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
$LN2@Tidy:

; 1837 : 				}
; 1838 : 			}

	jmp	SHORT $LN4@Tidy
$LN3@Tidy:

; 1839 : 
; 1840 : 		if (this->_Map != _Mapptr())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1841 : 			_Almap.deallocate(this->_Map,
; 1842 : 				this->_Mapsize);	// free storage for map

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::deallocate
$LN1@Tidy:

; 1843 : 		this->_Mapsize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1844 : 		this->_Map = _Mapptr();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1845 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Tidy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@Tidy:
	DD	1
	DD	$LN10@Tidy
$LN10@Tidy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN9@Tidy
$LN9@Tidy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv84 = -280						; size = 4
$T1 = -269						; size = 1
__Myptr$ = -68						; size = 4
__Newmap$ = -56						; size = 4
__Myboff$ = -44						; size = 4
__Newsize$ = -32					; size = 4
__Almap$ = -17						; size = 1
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap, COMDAT
; _this$ = ecx

; 1772 : 		{	// grow map by at least _Count pointers, _Mapsize a power of 2

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1773 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1774 : 			"The _Xlen() test should always be performed.");
; 1775 : 
; 1776 : 		typedef typename _Alpty::pointer _Blockptr;
; 1777 : 		_Alpty _Almap(this->_Getal());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >

; 1778 : 		size_type _Newsize = 0 < this->_Mapsize ? this->_Mapsize : 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN10@Growmap
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN11@Growmap
$LN10@Growmap:
	mov	DWORD PTR tv84[ebp], 1
$LN11@Growmap:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Newsize$[ebp], eax
$LN7@Growmap:

; 1779 : 		while (_Newsize - this->_Mapsize < _Count || _Newsize < _DEQUEMAPSIZ)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jb	SHORT $LN5@Growmap
	cmp	DWORD PTR __Newsize$[ebp], 8
	jae	SHORT $LN6@Growmap
$LN5@Growmap:

; 1780 : 			{	// scale _Newsize to 2^N >= _Mapsize + _Count
; 1781 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
	sub	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN4@Growmap

; 1782 : 				_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
$LN4@Growmap:

; 1783 : 			_Newsize *= 2;

	mov	eax, DWORD PTR __Newsize$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Newsize$[ebp], eax

; 1784 : 			}

	jmp	SHORT $LN7@Growmap
$LN6@Growmap:

; 1785 : 		_Count = _Newsize - this->_Mapsize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Count$[ebp], ecx

; 1786 : 
; 1787 : 		size_type _Myboff = this->_Myoff / _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Myboff$[ebp], ecx

; 1788 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::allocate
	mov	DWORD PTR __Newmap$[ebp], eax

; 1789 : 		_Mapptr _Myptr = _Newmap + _Myboff;

	mov	eax, DWORD PTR __Myboff$[ebp]
	mov	ecx, DWORD PTR __Newmap$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Myptr$[ebp], edx

; 1790 : 
; 1791 : 		_Myptr = _Uninitialized_copy(this->_Map + _Myboff,
; 1792 : 			this->_Map + this->_Mapsize,
; 1793 : 			_Myptr, _Almap);	// copy initial to end

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Myboff$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1794 : 		if (_Myboff <= _Count)

	mov	eax, DWORD PTR __Myboff$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@Growmap

; 1795 : 			{	// increment greater than offset of initial block
; 1796 : 			_Myptr = _Uninitialized_copy(this->_Map,
; 1797 : 				this->_Map + _Myboff,
; 1798 : 				_Myptr, _Almap);	// copy rest of old

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Myboff$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1799 : 			_Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,
; 1800 : 				_Almap);	// clear suffix of new

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Myboff$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	call	??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
	add	esp, 12					; 0000000cH

; 1801 : 			_Uninitialized_default_fill_n(_Newmap, _Myboff,
; 1802 : 				_Almap);	// clear prefix of new

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myboff$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newmap$[ebp]
	push	edx
	call	??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
	add	esp, 12					; 0000000cH

; 1803 : 			}
; 1804 : 		else

	jmp	SHORT $LN2@Growmap
$LN3@Growmap:

; 1805 : 			{	// increment not greater than offset of initial block
; 1806 : 			_Uninitialized_copy(this->_Map,
; 1807 : 				this->_Map + _Count,
; 1808 : 				_Myptr, _Almap);	// copy more old

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
	add	esp, 16					; 00000010H

; 1809 : 			_Myptr = _Uninitialized_copy(this->_Map + _Count,
; 1810 : 				this->_Map + _Myboff,
; 1811 : 				_Newmap, _Almap);	// copy rest of old

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newmap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Myboff$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1812 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1813 : 				_Almap);	// clear rest to initial block

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	call	??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
	add	esp, 12					; 0000000cH
$LN2@Growmap:

; 1814 : 			}
; 1815 : 
; 1816 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1817 : 			_Almap);

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Myboff$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> > >
	add	esp, 12					; 0000000cH

; 1818 : 		if (this->_Map != _Mapptr())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Growmap

; 1819 : 			_Almap.deallocate(this->_Map,
; 1820 : 				this->_Mapsize);	// free storage for old

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::deallocate
$LN1@Growmap:

; 1821 : 
; 1822 : 		this->_Map = _Newmap;	// point at new

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newmap$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1823 : 		this->_Mapsize += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN9@Growmap:

; 1824 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@Growmap
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN14@Growmap:
	DD	1
	DD	$LN13@Growmap
$LN13@Growmap:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN12@Growmap
$LN12@Growmap:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen, COMDAT
; _this$ = ecx

; 1762 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1763 : 		_Xlength_error("deque<T> too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 1764 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear, COMDAT
; _this$ = ecx

; 1642 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1643 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 1644 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
tv421 = -612						; size = 4
tv427 = -608						; size = 4
tv411 = -608						; size = 4
tv183 = -608						; size = 4
tv424 = -604						; size = 4
tv417 = -604						; size = 4
tv393 = -604						; size = 4
tv485 = -600						; size = 4
tv442 = -600						; size = 4
tv414 = -600						; size = 4
tv404 = -600						; size = 4
tv261 = -600						; size = 4
tv430 = -596						; size = 4
tv420 = -596						; size = 4
tv410 = -596						; size = 4
tv408 = -596						; size = 4
tv406 = -596						; size = 4
tv401 = -596						; size = 4
tv388 = -596						; size = 4
tv382 = -596						; size = 4
tv378 = -596						; size = 4
tv487 = -592						; size = 4
tv484 = -592						; size = 4
tv482 = -592						; size = 4
tv481 = -592						; size = 4
tv480 = -592						; size = 4
tv446 = -592						; size = 4
tv381 = -592						; size = 4
tv377 = -592						; size = 4
tv370 = -592						; size = 4
tv246 = -592						; size = 4
$T2 = -584						; size = 4
$T3 = -572						; size = 4
$T4 = -557						; size = 1
$T5 = -548						; size = 12
$T6 = -528						; size = 12
$T7 = -508						; size = 4
$T8 = -496						; size = 4
$T9 = -484						; size = 12
$T10 = -461						; size = 1
$T11 = -452						; size = 12
$T12 = -432						; size = 4
$T13 = -420						; size = 4
$T14 = -408						; size = 4
$T15 = -396						; size = 12
$T16 = -376						; size = 4
$T17 = -364						; size = 4
$T18 = -352						; size = 4
$T19 = -340						; size = 12
$T20 = -320						; size = 12
$T21 = -300						; size = 4
__Moved$ = -93						; size = 1
__Count$ = -84						; size = 4
__Off$ = -72						; size = 4
__Last$ = -60						; size = 12
__First$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 12
__Last_arg$ = 24					; size = 12
?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase, COMDAT
; _this$ = ecx

; 1601 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 600				; 00000258H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-612]
	mov	ecx, 150				; 00000096H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T21[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1602 : 		iterator _First = _Make_iter(_First_arg);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __First_arg$[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv377[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter
	mov	DWORD PTR tv378[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1603 : 		iterator _Last = _Make_iter(_Last_arg);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Last_arg$[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv381[ebp], eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter
	mov	DWORD PTR tv382[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1604 : 
; 1605 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1606 : 		if (_Last < _First
; 1607 : 			|| _First < begin() || end() < _Last)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator<
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN13@erase
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv370[ebp], eax
	mov	eax, DWORD PTR tv370[ebp]
	mov	DWORD PTR tv388[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T21[ebp]
	or	ecx, 1
	mov	DWORD PTR $T21[ebp], ecx
	mov	edx, DWORD PTR tv388[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator<
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@erase
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	DWORD PTR tv442[ebp], eax
	mov	eax, DWORD PTR tv442[ebp]
	mov	DWORD PTR tv393[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T21[ebp]
	or	ecx, 2
	mov	DWORD PTR $T21[ebp], ecx
	mov	ecx, DWORD PTR tv393[ebp]
	call	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator<
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN13@erase
	mov	DWORD PTR tv183[ebp], 0
	jmp	SHORT $LN14@erase
$LN13@erase:
	mov	DWORD PTR tv183[ebp], 1
$LN14@erase:
	mov	al, BYTE PTR tv183[ebp]
	mov	BYTE PTR $T4[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T21[ebp]
	and	ecx, 2
	je	SHORT $LN29@erase
	and	DWORD PTR $T21[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
$LN29@erase:
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR $T21[ebp]
	and	edx, 1
	je	SHORT $LN30@erase
	and	DWORD PTR $T21[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
$LN30@erase:
	movzx	eax, BYTE PTR $T4[ebp]
	test	eax, eax
	je	SHORT $LN10@erase

; 1608 : 			_DEBUG_ERROR("deque erase iterator outside range");

	mov	esi, esp
	push	1608					; 00000648H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EG@IIKPBBHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa?$AAn@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@erase:

; 1609 : 		_DEBUG_RANGE(_First, _Last);

	push	1609					; 00000649H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T7[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv446[ebp], eax
	mov	ecx, DWORD PTR tv446[ebp]
	mov	DWORD PTR tv401[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T8[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv404[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 32					; 00000020H

; 1610 : 
; 1611 : 		size_type _Off = _First - begin();

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv480[ebp], eax
	mov	ecx, DWORD PTR tv480[ebp]
	mov	DWORD PTR tv406[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR tv406[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
	mov	DWORD PTR __Off$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 1612 : 		size_type _Count = _Last - _First;

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
	mov	DWORD PTR __Count$[ebp], eax

; 1613 : 		bool _Moved = 0 < _Off && _Off + _Count < this->_Mysize;

	cmp	DWORD PTR __Off$[ebp], 0
	jbe	SHORT $LN15@erase
	mov	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+16]
	jae	SHORT $LN15@erase
	mov	DWORD PTR tv246[ebp], 1
	jmp	SHORT $LN16@erase
$LN15@erase:
	mov	DWORD PTR tv246[ebp], 0
$LN16@erase:
	mov	dl, BYTE PTR tv246[ebp]
	mov	BYTE PTR __Moved$[ebp], dl

; 1614 : 
; 1615 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1616 : 		size_type _Off = _First - begin();
; 1617 : 		size_type _Count = _Last - _First;
; 1618 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1619 : 
; 1620 : 		if (_Off < (size_type)(end() - _Last))

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	DWORD PTR tv481[ebp], eax
	mov	edx, DWORD PTR tv481[ebp]
	mov	DWORD PTR tv408[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR tv408[ebp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
	cmp	DWORD PTR __Off$[ebp], eax
	jae	SHORT $LN17@erase
	mov	DWORD PTR tv261[ebp], 1
	jmp	SHORT $LN18@erase
$LN17@erase:
	mov	DWORD PTR tv261[ebp], 0
$LN18@erase:
	mov	al, BYTE PTR tv261[ebp]
	mov	BYTE PTR $T10[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	movzx	ecx, BYTE PTR $T10[ebp]
	test	ecx, ecx
	je	$LN9@erase

; 1621 : 			{	// closer to front
; 1622 : 			_Move_backward(begin(), _First, _Last);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T12[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv482[ebp], eax
	mov	ecx, DWORD PTR tv482[ebp]
	mov	DWORD PTR tv410[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T13[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv414[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T14[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv417[ebp], eax
	lea	ecx, DWORD PTR $T15[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv411[ebp], eax
	lea	ecx, DWORD PTR $T15[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 1623 : 			for (; 0 < _Count; --_Count)

	jmp	SHORT $LN8@erase
$LN7@erase:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN8@erase:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN6@erase

; 1624 : 				pop_front();	// pop copied elements

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
	jmp	SHORT $LN7@erase
$LN6@erase:

; 1625 : 			}
; 1626 : 		else

	jmp	$LN5@erase
$LN9@erase:

; 1627 : 			{	// closer to back
; 1628 : 			_Move(_Last, end(), _First);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T16[ebp], esp
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv484[ebp], eax
	mov	ecx, DWORD PTR tv484[ebp]
	mov	DWORD PTR tv420[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T17[ebp], esp
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	DWORD PTR tv485[ebp], eax
	mov	eax, DWORD PTR tv485[ebp]
	mov	DWORD PTR tv424[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T18[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv427[ebp], eax
	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv421[ebp], eax
	lea	ecx, DWORD PTR $T19[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 1629 : 			for (; 0 < _Count; --_Count)

	jmp	SHORT $LN4@erase
$LN3@erase:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@erase:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN5@erase

; 1630 : 				pop_back();	// pop copied elements

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
	jmp	SHORT $LN3@erase
$LN5@erase:

; 1631 : 			}
; 1632 : 
; 1633 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1634 : 		if (_Moved)

	movzx	eax, BYTE PTR __Moved$[ebp]
	test	eax, eax
	je	SHORT $LN1@erase

; 1635 : 			this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@erase:

; 1636 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1637 : 
; 1638 : 		return (begin() + _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T20[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv487[ebp], eax
	mov	eax, DWORD PTR tv487[ebp]
	mov	DWORD PTR tv430[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR tv430[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	ecx, DWORD PTR $T21[ebp]
	or	ecx, 4
	mov	DWORD PTR $T21[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T20[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First_arg$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last_arg$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1639 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN50@erase
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 612				; 00000264H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	3
$LN50@erase:
	DD	2
	DD	$LN49@erase
$LN49@erase:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN46@erase
	DD	-60					; ffffffc4H
	DD	12					; 0000000cH
	DD	$LN47@erase
$LN47@erase:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN46@erase:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$0:
	lea	ecx, DWORD PTR __Last_arg$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$1:
	lea	ecx, DWORD PTR __First_arg$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$3:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$5:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$6:
	mov	eax, DWORD PTR $T21[ebp]
	and	eax, 1
	je	$LN26@erase
	and	DWORD PTR $T21[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
$LN26@erase:
	ret	0
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$7:
	mov	eax, DWORD PTR $T21[ebp]
	and	eax, 2
	je	$LN28@erase
	and	DWORD PTR $T21[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
$LN28@erase:
	ret	0
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$8:
	mov	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$10:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$11:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$12:
	mov	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$16:
	mov	ecx, DWORD PTR $T16[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$17:
	mov	ecx, DWORD PTR $T17[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z$20:
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-616]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
tv149 = -244						; size = 4
$T1 = -233						; size = 1
__Block$2 = -32						; size = 4
__Newoff$3 = -20					; size = 4
_this$ = -8						; size = 4
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back, COMDAT
; _this$ = ecx

; 1471 : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@pop_back

; 1474 : 			_DEBUG_ERROR("deque empty before pop");

	mov	esi, esp
	push	1474					; 000005c2H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1475 : 		else

	jmp	$LN4@pop_back
$LN3@pop_back:

; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR __Newoff$3[ebp], ecx

; 1478 : 			_Orphan_off(_Newoff);

	mov	eax, DWORD PTR __Newoff$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Orphan_off

; 1479 : 			size_type _Block = this->_Getblock(_Newoff);

	mov	eax, DWORD PTR __Newoff$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
	mov	DWORD PTR __Block$2[ebp], eax

; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Newoff$3[ebp]
	xor	edx, edx
	mov	esi, 1
	div	esi
	imul	edx, edx, 44
	mov	eax, DWORD PTR __Block$2[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>

; 1482 : 			if (--this->_Mysize == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, 1
	mov	DWORD PTR tv149[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR [edx+16], eax
	cmp	DWORD PTR tv149[ebp], 0
	jne	SHORT $LN4@pop_back

; 1483 : 				this->_Myoff = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN4@pop_back:

; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1491 : 		if (--this->_Mysize == 0)
; 1492 : 			this->_Myoff = 0;
; 1493 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1494 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Block$ = -32						; size = 4
__Newoff$ = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back, COMDAT
; _this$ = ecx

; 1462 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1463 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1464 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_back
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], ecx
	ja	SHORT $LN2@push_back
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR __Newoff$[ebp], ecx
	mov	eax, DWORD PTR __Newoff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	jne	SHORT $LN1@push_back
	push	1
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@push_back:

; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 1
	div	esi
	imul	edx, edx, 44
	mov	eax, DWORD PTR __Block$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>

; 1467 : 		_PUSH_BACK_END;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1468 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
tv152 = -232						; size = 4
$T1 = -221						; size = 1
__Block$2 = -20						; size = 4
_this$ = -8						; size = 4
?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front, COMDAT
; _this$ = ecx

; 1434 : 		{	// erase element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@pop_front

; 1437 : 			_DEBUG_ERROR("deque empty before pop");

	mov	esi, esp
	push	1437					; 0000059dH
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1438 : 		else

	jmp	$LN5@pop_front
$LN4@pop_front:

; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_off@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Orphan_off

; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
	mov	DWORD PTR __Block$2[ebp], eax

; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	xor	edx, edx
	mov	esi, 1
	div	esi
	imul	eax, edx, 44
	mov	edx, DWORD PTR __Block$2[ebp]
	add	eax, DWORD PTR [ecx+edx*4]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>

; 1444 : 			if (--this->_Mysize == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, 1
	mov	DWORD PTR tv152[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv152[ebp]
	mov	DWORD PTR [edx+16], eax
	cmp	DWORD PTR tv152[ebp], 0
	jne	SHORT $LN2@pop_front

; 1445 : 				this->_Myoff = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 1446 : 			else

	jmp	SHORT $LN5@pop_front
$LN2@pop_front:

; 1447 : 				++this->_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN5@pop_front:

; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
tv151 = -256						; size = 4
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Block$ = -32						; size = 4
__Newoff$ = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front, COMDAT
; _this$ = ecx

; 1425 : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1426 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1427 : 		_PUSH_FRONT_BEGIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_front
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], ecx
	ja	SHORT $LN2@push_front
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@push_front:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@push_front
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv151[ebp], edx
	jmp	SHORT $LN6@push_front
$LN5@push_front:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv151[ebp], ecx
$LN6@push_front:
	mov	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR __Newoff$[ebp], edx
	mov	eax, DWORD PTR __Newoff$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Newoff$[ebp], eax
	mov	ecx, DWORD PTR __Newoff$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	jne	SHORT $LN1@push_front
	push	1
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@push_front:

; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 1
	div	esi
	imul	edx, edx, 44
	mov	eax, DWORD PTR __Block$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>

; 1430 : 		_PUSH_FRONT_END;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newoff$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1431 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv70 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty, COMDAT
; _this$ = ecx

; 1361 : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1362 : 		return (this->_Mysize == 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv70[ebp], 0
$LN4@empty:
	mov	al, BYTE PTR tv70[ebp]

; 1363 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT
; _this$ = ecx

; 1356 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1357 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size

; 1358 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size, COMDAT
; _this$ = ecx

; 1351 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1352 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1353 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize, COMDAT
; _this$ = ecx

; 1334 : 		{	// determine new length, padding as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@resize:

; 1335 : 		while (this->_Mysize < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN2@resize

; 1336 : 			emplace_back();

	mov	ecx, DWORD PTR _this$[ebp]
	call	??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>
	jmp	SHORT $LN4@resize
$LN2@resize:

; 1337 : 
; 1338 : 		while (_Newsize < this->_Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN5@resize

; 1339 : 			pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
	jmp	SHORT $LN2@resize
$LN5@resize:

; 1340 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter, COMDAT
; _this$ = ecx

; 1270 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1271 : 		return (iterator(_Where._Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1272 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end, COMDAT
; _this$ = ecx

; 1265 : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1266 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1267 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end, COMDAT
; _this$ = ecx

; 1260 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1261 : 		return (iterator(this->_Myoff + this->_Mysize, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1262 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin, COMDAT
; _this$ = ecx

; 1255 : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1256 : 		return (const_iterator(this->_Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1257 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin, COMDAT
; _this$ = ecx

; 1250 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1251 : 		return (iterator(this->_Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1252 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv386 = -576						; size = 4
tv394 = -572						; size = 4
tv391 = -568						; size = 4
tv366 = -568						; size = 4
tv403 = -564						; size = 4
tv376 = -564						; size = 4
tv369 = -564						; size = 4
tv389 = -560						; size = 4
tv382 = -560						; size = 4
tv365 = -560						; size = 4
tv354 = -560						; size = 4
tv402 = -556						; size = 4
tv397 = -556						; size = 4
tv379 = -556						; size = 4
tv360 = -556						; size = 4
tv385 = -552						; size = 4
tv375 = -552						; size = 4
tv372 = -552						; size = 4
tv363 = -552						; size = 4
tv357 = -552						; size = 4
tv401 = -548						; size = 4
tv399 = -548						; size = 4
tv396 = -548						; size = 4
tv353 = -548						; size = 4
tv247 = -548						; size = 4
$T2 = -537						; size = 1
$T3 = -525						; size = 1
$T4 = -513						; size = 1
$T5 = -504						; size = 4
$T6 = -492						; size = 4
$T7 = -480						; size = 4
$T8 = -468						; size = 4
$T9 = -456						; size = 12
$T10 = -436						; size = 4
$T11 = -424						; size = 12
$T12 = -404						; size = 12
$T13 = -384						; size = 4
$T14 = -372						; size = 4
$T15 = -360						; size = 4
$T16 = -348						; size = 12
$T17 = -328						; size = 4
$T18 = -316						; size = 4
$T19 = -304						; size = 4
$T20 = -292						; size = 12
$T21 = -272						; size = 12
__Mid$22 = -60						; size = 12
__Mid$23 = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=, COMDAT
; _this$ = ecx

; 1219 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 564				; 00000234H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-576]
	mov	ecx, 141				; 0000008dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1220 : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN6@operator

; 1221 : 			{	// different, assign it
; 1222 : 			if (this->_Getal() != _Right._Getal()
; 1223 : 				&& _Alty::propagate_on_container_copy_assignment::value)

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	push	eax
	call	??$?9V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ; std::operator!=<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@operator
	xor	eax, eax
	je	SHORT $LN5@operator

; 1224 : 				{	// change allocator before copying
; 1225 : 				_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 1226 : 				this->_Change_alloc(_Right._Getal());

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Change_alloc@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Change_alloc
$LN5@operator:

; 1227 : 				}
; 1228 : 
; 1229 : 			this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1230 : 
; 1231 : 			if (_Right._Mysize == 0)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN4@operator

; 1232 : 				clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
	jmp	$LN6@operator
$LN4@operator:

; 1233 : 			else if (_Right._Mysize <= this->_Mysize)

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	ja	$LN2@operator

; 1234 : 				{	// enough elements, copy new and destroy old
; 1235 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1236 : 					begin());

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T5[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv353[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T6[ebp], esp
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	DWORD PTR tv357[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T7[ebp], esp
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv360[ebp], eax
	lea	eax, DWORD PTR __Mid$23[ebp]
	push	eax
	call	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv354[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1237 : 				erase(_Mid, end());

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	DWORD PTR tv396[ebp], eax
	mov	ecx, DWORD PTR tv396[ebp]
	mov	DWORD PTR tv363[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T8[ebp], esp
	mov	edx, DWORD PTR tv363[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv397[ebp], eax
	mov	eax, DWORD PTR tv397[ebp]
	mov	DWORD PTR tv365[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T10[ebp], esp
	lea	edx, DWORD PTR __Mid$23[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv369[ebp], eax
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
	mov	DWORD PTR tv366[ebp], eax
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 1238 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Mid$23[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 1239 : 			else

	jmp	$LN6@operator
$LN2@operator:

; 1240 : 				{	// new sequence longer, copy and construct new
; 1241 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	lea	edx, DWORD PTR __Mid$22[ebp]
	push	edx
	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv399[ebp], eax
	mov	ecx, DWORD PTR tv399[ebp]
	mov	DWORD PTR tv372[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv372[ebp]
	call	??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T12[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 1242 : 				_STD copy(_Right.begin(), _Mid, begin());

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T13[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv247[ebp], eax
	mov	ecx, DWORD PTR tv247[ebp]
	mov	DWORD PTR tv375[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T14[ebp], esp
	lea	edx, DWORD PTR __Mid$22[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv379[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T15[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv382[ebp], eax
	lea	ecx, DWORD PTR $T16[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	call	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv376[ebp], eax
	lea	ecx, DWORD PTR $T16[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 1243 : 				insert(end(), _Mid, _Right.end());

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T17[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	DWORD PTR tv401[ebp], eax
	mov	ecx, DWORD PTR tv401[ebp]
	mov	DWORD PTR tv385[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T18[ebp], esp
	lea	edx, DWORD PTR __Mid$22[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv402[ebp], eax
	mov	eax, DWORD PTR tv402[ebp]
	mov	DWORD PTR tv389[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T20[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	DWORD PTR tv403[ebp], eax
	mov	edx, DWORD PTR tv403[ebp]
	mov	DWORD PTR tv391[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T19[ebp], esp
	mov	eax, DWORD PTR tv391[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv394[ebp], eax
	lea	ecx, DWORD PTR $T21[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	mov	DWORD PTR tv386[ebp], eax
	lea	ecx, DWORD PTR $T21[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T20[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 1244 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Mid$22[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
$LN6@operator:

; 1245 : 			}
; 1246 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1247 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 576				; 00000240H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN32@operator:
	DD	2
	DD	$LN31@operator
$LN31@operator:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN28@operator
	DD	-60					; ffffffc4H
	DD	12					; 0000000cH
	DD	$LN29@operator
$LN29@operator:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$LN28@operator:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$3:
	lea	ecx, DWORD PTR __Mid$23[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$4:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$5:
	mov	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$8:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$9:
	lea	ecx, DWORD PTR __Mid$22[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$10:
	mov	ecx, DWORD PTR $T13[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$14:
	mov	ecx, DWORD PTR $T17[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$15:
	mov	ecx, DWORD PTR $T18[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$16:
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-580]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 1214 : 		{	// destroy the deque

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1215 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 1216 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv155 = -272						; size = 4
tv152 = -268						; size = 4
$T2 = -257						; size = 1
$T3 = -245						; size = 1
$T4 = -236						; size = 4
$T5 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 982  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
	mov	ecx, eax
	call	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 983  : 		_Construct(_Right.begin(), _Right.end());

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T4[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	DWORD PTR tv152[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	DWORD PTR tv155[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >

; 984  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
__ehhandler$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-276]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 951  : 		{	// construct empty deque

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >

; 952  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 911  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 912  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 913  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 901  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 902  : 		typename _Alty::template rebind<_Container_proxy>::other
; 903  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >

; 904  : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 905  : 		_Alproxy.destroy(this->_Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 906  : 		_Alproxy.deallocate(this->_Myproxy, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 907  : 		this->_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 908  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 892  : 		{	// construct proxy from _Alval

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 893  : 		typename _Alty::template rebind<_Container_proxy>::other
; 894  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >

; 895  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 896  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 898  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Change_alloc@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
?_Change_alloc@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Change_alloc, COMDAT
; _this$ = ecx

; 883  : 		{	// replace old allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Change_alloc@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 879  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Free_proxy

; 880  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 873  : 		{	// construct allocators from _Al
; 874  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy

; 875  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::~_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::~_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock, COMDAT
; _this$ = ecx

; 780  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 781  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, 1
	and	eax, DWORD PTR __Off$[ebp]

; 783  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 771  : 	_Deque_val()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 772  : 		{	// initialize values
; 773  : 		_Map = _Mapptr();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 774  : 		_Mapsize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 775  : 		_Myoff = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 776  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 777  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::deallocate

; 859  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocate

; 848  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo *>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size
	add	esp, 4

; 885  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct, COMDAT
; _this$ = ecx

; 862  : 		{	// default construct object at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 863  : 		_Mytraits::construct(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$construct@VErrorInfo@Reader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>
	add	esp, 8

; 864  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::deallocate

; 859  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::allocate

; 848  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 806  : 		{	// construct by copying base

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>

; 807  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA?AV?$allocator@VErrorInfo@Reader@Json@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA?AV?$allocator@VErrorInfo@Reader@Json@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA?AV?$allocator@VErrorInfo@Reader@Json@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 741  : 		return (_Al.select_on_container_copy_construction());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?select_on_container_copy_construction@?$allocator@VErrorInfo@Reader@Json@@@std@@QBE?AV12@XZ ; std::allocator<Json::Reader::ErrorInfo>::select_on_container_copy_construction
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA?AV?$allocator@VErrorInfo@Reader@Json@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ; std::allocator<Json::Reader::ErrorInfo>::max_size

; 736  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ PROC ; std::allocator<Json::Reader::ErrorInfo>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 97612893				; 05d1745dH

; 613  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	44					; 0000002cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 594  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::construct, COMDAT
; _this$ = ecx

; 587  : 		{	// default construct object at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 588  : 		::new ((void *)_Ptr) _Ty();

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	44					; 0000002cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0ErrorInfo@Reader@Json@@QAE@XZ
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 589  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ PROC ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@VErrorInfo@Reader@Json@@@std@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@VErrorInfo@Reader@Json@@@std@@QBE?AV12@XZ PROC ; std::allocator<Json::Reader::ErrorInfo>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$allocator@VErrorInfo@Reader@Json@@@std@@QBE?AV12@XZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop, COMDAT
; _this$ = ecx

; 144  : 		{	// erase last element

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		c.pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back

; 146  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top, COMDAT
; _this$ = ecx

; 129  : 		{	// return last element of mutable stack

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 130  : 		return (c.back());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back

; 131  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty, COMDAT
; _this$ = ecx

; 119  : 		{	// test if stack is empty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		return (c.empty());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty

; 121  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push, COMDAT
; _this$ = ecx

; 107  : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 		c.push_back(_STD move(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::move<Json::Value * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back

; 109  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=, COMDAT
; _this$ = ecx

; 42   : 		{	// assign by copying _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 		c = _Right.c;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=

; 44   : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 45   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 33   : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >

; 34   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 28   : 		{	// construct with empty container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >

; 29   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z
_TEXT	SEGMENT
tv77 = -256						; size = 4
__Pnext$ = -56						; size = 4
__Lock$ = -44						; size = 4
__Offhigh$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Offlo$ = 8						; size = 4
?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Orphan_off, COMDAT
; _this$ = ecx

; 1849 : 		{	// orphan iterators with specified offset(s)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1850 : 		size_type _Offhigh = this->_Myoff + this->_Mysize <= _Offlo + 1
; 1851 : 			? (size_type)(-1) : _Offlo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR __Offlo$[ebp]
	add	eax, 1
	cmp	ecx, eax
	ja	SHORT $LN10@Orphan_off
	mov	DWORD PTR tv77[ebp], -1
	jmp	SHORT $LN11@Orphan_off
$LN10@Orphan_off:
	mov	ecx, DWORD PTR __Offlo$[ebp]
	mov	DWORD PTR tv77[ebp], ecx
$LN11@Orphan_off:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Offhigh$[ebp], edx

; 1852 : 		if (_Offlo == this->_Myoff)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Offlo$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jne	SHORT $LN7@Orphan_off

; 1853 : 			_Offlo = 0;

	mov	DWORD PTR __Offlo$[ebp], 0
$LN7@Orphan_off:

; 1854 : 
; 1855 : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1856 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Pnext$[ebp], eax

; 1857 : 		if (_Pnext != 0)

	cmp	DWORD PTR __Pnext$[ebp], 0
	je	SHORT $LN6@Orphan_off
$LN5@Orphan_off:

; 1858 : 			while (*_Pnext != 0)

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_off

; 1859 : 				if ((*_Pnext)->_Myoff < _Offlo
; 1860 : 					|| _Offhigh < (*_Pnext)->_Myoff)

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Offlo$[ebp]
	jb	SHORT $LN2@Orphan_off
	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Offhigh$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@Orphan_off
$LN2@Orphan_off:

; 1861 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	DWORD PTR __Pnext$[ebp], eax

; 1862 : 				else

	jmp	SHORT $LN1@Orphan_off
$LN3@Orphan_off:

; 1863 : 					{	// orphan the iterator
; 1864 : 					(*_Pnext)->_Clrcont();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Clrcont@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Clrcont

; 1865 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
$LN1@Orphan_off:

; 1866 : 					}

	jmp	SHORT $LN5@Orphan_off
$LN6@Orphan_off:

; 1867 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@Orphan_off
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN16@Orphan_off:
	DD	1
	DD	$LN15@Orphan_off
$LN15@Orphan_off:
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN13@Orphan_off
$LN13@Orphan_off:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Orphan_off
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -257						; size = 1
$T2 = -245						; size = 1
$T3 = -233						; size = 1
__Block$4 = -32						; size = 4
__Almap$ = -17						; size = 1
_this$ = -8						; size = 4
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy, COMDAT
; _this$ = ecx

; 1827 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1828 : 		_Alpty _Almap(this->_Getal());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::_Wrap_alloc<std::allocator<Json::Value * *> ><std::_Wrap_alloc<std::allocator<Json::Value *> > >
$LN6@Tidy:

; 1829 : 		while (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Tidy

; 1830 : 			pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
	jmp	SHORT $LN6@Tidy
$LN5@Tidy:

; 1831 : 		for (size_type _Block = this->_Mapsize; 0 < _Block; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Block$4[ebp], ecx
$LN4@Tidy:
	cmp	DWORD PTR __Block$4[ebp], 0
	jbe	SHORT $LN3@Tidy

; 1832 : 			{	// free storage for a block and destroy pointer
; 1833 : 			if (this->_Map[--_Block] != pointer())

	mov	eax, DWORD PTR __Block$4[ebp]
	sub	eax, 1
	mov	DWORD PTR __Block$4[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Block$4[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN2@Tidy

; 1834 : 				{	// free block and destroy its pointer
; 1835 : 				this->_Getal().deallocate(this->_Map[_Block], _DEQUESIZ);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$4[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::deallocate

; 1836 : 				this->_Getal().destroy(&this->_Map[_Block]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$4[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value * *>
$LN2@Tidy:

; 1837 : 				}
; 1838 : 			}

	jmp	SHORT $LN4@Tidy
$LN3@Tidy:

; 1839 : 
; 1840 : 		if (this->_Map != _Mapptr())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1841 : 			_Almap.deallocate(this->_Map,
; 1842 : 				this->_Mapsize);	// free storage for map

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::deallocate
$LN1@Tidy:

; 1843 : 		this->_Mapsize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1844 : 		this->_Map = _Mapptr();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1845 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Tidy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@Tidy:
	DD	1
	DD	$LN10@Tidy
$LN10@Tidy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN9@Tidy
$LN9@Tidy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv84 = -280						; size = 4
$T1 = -269						; size = 1
__Myptr$ = -68						; size = 4
__Newmap$ = -56						; size = 4
__Myboff$ = -44						; size = 4
__Newsize$ = -32					; size = 4
__Almap$ = -17						; size = 1
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap, COMDAT
; _this$ = ecx

; 1772 : 		{	// grow map by at least _Count pointers, _Mapsize a power of 2

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1773 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1774 : 			"The _Xlen() test should always be performed.");
; 1775 : 
; 1776 : 		typedef typename _Alpty::pointer _Blockptr;
; 1777 : 		_Alpty _Almap(this->_Getal());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::_Wrap_alloc<std::allocator<Json::Value * *> ><std::_Wrap_alloc<std::allocator<Json::Value *> > >

; 1778 : 		size_type _Newsize = 0 < this->_Mapsize ? this->_Mapsize : 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN10@Growmap
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN11@Growmap
$LN10@Growmap:
	mov	DWORD PTR tv84[ebp], 1
$LN11@Growmap:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Newsize$[ebp], eax
$LN7@Growmap:

; 1779 : 		while (_Newsize - this->_Mapsize < _Count || _Newsize < _DEQUEMAPSIZ)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jb	SHORT $LN5@Growmap
	cmp	DWORD PTR __Newsize$[ebp], 8
	jae	SHORT $LN6@Growmap
$LN5@Growmap:

; 1780 : 			{	// scale _Newsize to 2^N >= _Mapsize + _Count
; 1781 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
	shr	eax, 2
	sub	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN4@Growmap

; 1782 : 				_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
$LN4@Growmap:

; 1783 : 			_Newsize *= 2;

	mov	eax, DWORD PTR __Newsize$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Newsize$[ebp], eax

; 1784 : 			}

	jmp	SHORT $LN7@Growmap
$LN6@Growmap:

; 1785 : 		_Count = _Newsize - this->_Mapsize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Count$[ebp], ecx

; 1786 : 
; 1787 : 		size_type _Myboff = this->_Myoff / _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 2
	mov	DWORD PTR __Myboff$[ebp], ecx

; 1788 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::allocate
	mov	DWORD PTR __Newmap$[ebp], eax

; 1789 : 		_Mapptr _Myptr = _Newmap + _Myboff;

	mov	eax, DWORD PTR __Myboff$[ebp]
	mov	ecx, DWORD PTR __Newmap$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Myptr$[ebp], edx

; 1790 : 
; 1791 : 		_Myptr = _Uninitialized_copy(this->_Map + _Myboff,
; 1792 : 			this->_Map + this->_Mapsize,
; 1793 : 			_Myptr, _Almap);	// copy initial to end

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Myboff$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1794 : 		if (_Myboff <= _Count)

	mov	eax, DWORD PTR __Myboff$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@Growmap

; 1795 : 			{	// increment greater than offset of initial block
; 1796 : 			_Myptr = _Uninitialized_copy(this->_Map,
; 1797 : 				this->_Map + _Myboff,
; 1798 : 				_Myptr, _Almap);	// copy rest of old

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Myboff$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1799 : 			_Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,
; 1800 : 				_Almap);	// clear suffix of new

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Myboff$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	call	??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
	add	esp, 12					; 0000000cH

; 1801 : 			_Uninitialized_default_fill_n(_Newmap, _Myboff,
; 1802 : 				_Almap);	// clear prefix of new

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myboff$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newmap$[ebp]
	push	edx
	call	??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
	add	esp, 12					; 0000000cH

; 1803 : 			}
; 1804 : 		else

	jmp	SHORT $LN2@Growmap
$LN3@Growmap:

; 1805 : 			{	// increment not greater than offset of initial block
; 1806 : 			_Uninitialized_copy(this->_Map,
; 1807 : 				this->_Map + _Count,
; 1808 : 				_Myptr, _Almap);	// copy more old

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
	add	esp, 16					; 00000010H

; 1809 : 			_Myptr = _Uninitialized_copy(this->_Map + _Count,
; 1810 : 				this->_Map + _Myboff,
; 1811 : 				_Newmap, _Almap);	// copy rest of old

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newmap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Myboff$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1812 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1813 : 				_Almap);	// clear rest to initial block

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	call	??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,std::_Wrap_alloc<std::allocator<Json::Value * *> > >
	add	esp, 12					; 0000000cH
$LN2@Growmap:

; 1814 : 			}
; 1815 : 
; 1816 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1817 : 			_Almap);

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Myboff$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * *> > >
	add	esp, 12					; 0000000cH

; 1818 : 		if (this->_Map != _Mapptr())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Growmap

; 1819 : 			_Almap.deallocate(this->_Map,
; 1820 : 				this->_Mapsize);	// free storage for old

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::deallocate
$LN1@Growmap:

; 1821 : 
; 1822 : 		this->_Map = _Newmap;	// point at new

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newmap$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1823 : 		this->_Mapsize += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN9@Growmap:

; 1824 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@Growmap
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN14@Growmap:
	DD	1
	DD	$LN13@Growmap
$LN13@Growmap:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN12@Growmap
$LN12@Growmap:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen, COMDAT
; _this$ = ecx

; 1762 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1763 : 		_Xlength_error("deque<T> too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 1764 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::clear, COMDAT
; _this$ = ecx

; 1642 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1643 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy

; 1644 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
tv421 = -612						; size = 4
tv427 = -608						; size = 4
tv411 = -608						; size = 4
tv183 = -608						; size = 4
tv424 = -604						; size = 4
tv417 = -604						; size = 4
tv393 = -604						; size = 4
tv485 = -600						; size = 4
tv442 = -600						; size = 4
tv414 = -600						; size = 4
tv404 = -600						; size = 4
tv261 = -600						; size = 4
tv430 = -596						; size = 4
tv420 = -596						; size = 4
tv410 = -596						; size = 4
tv408 = -596						; size = 4
tv406 = -596						; size = 4
tv401 = -596						; size = 4
tv388 = -596						; size = 4
tv382 = -596						; size = 4
tv378 = -596						; size = 4
tv487 = -592						; size = 4
tv484 = -592						; size = 4
tv482 = -592						; size = 4
tv481 = -592						; size = 4
tv480 = -592						; size = 4
tv446 = -592						; size = 4
tv381 = -592						; size = 4
tv377 = -592						; size = 4
tv370 = -592						; size = 4
tv246 = -592						; size = 4
$T2 = -584						; size = 4
$T3 = -572						; size = 4
$T4 = -557						; size = 1
$T5 = -548						; size = 12
$T6 = -528						; size = 12
$T7 = -508						; size = 4
$T8 = -496						; size = 4
$T9 = -484						; size = 12
$T10 = -461						; size = 1
$T11 = -452						; size = 12
$T12 = -432						; size = 4
$T13 = -420						; size = 4
$T14 = -408						; size = 4
$T15 = -396						; size = 12
$T16 = -376						; size = 4
$T17 = -364						; size = 4
$T18 = -352						; size = 4
$T19 = -340						; size = 12
$T20 = -320						; size = 12
$T21 = -300						; size = 4
__Moved$ = -93						; size = 1
__Count$ = -84						; size = 4
__Off$ = -72						; size = 4
__Last$ = -60						; size = 12
__First$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 12
__Last_arg$ = 24					; size = 12
?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase, COMDAT
; _this$ = ecx

; 1601 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 600				; 00000258H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-612]
	mov	ecx, 150				; 00000096H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T21[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1602 : 		iterator _First = _Make_iter(_First_arg);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __First_arg$[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv377[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter
	mov	DWORD PTR tv378[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1603 : 		iterator _Last = _Make_iter(_Last_arg);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Last_arg$[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv381[ebp], eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter
	mov	DWORD PTR tv382[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1604 : 
; 1605 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1606 : 		if (_Last < _First
; 1607 : 			|| _First < begin() || end() < _Last)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator<
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN13@erase
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv370[ebp], eax
	mov	eax, DWORD PTR tv370[ebp]
	mov	DWORD PTR tv388[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T21[ebp]
	or	ecx, 1
	mov	DWORD PTR $T21[ebp], ecx
	mov	edx, DWORD PTR tv388[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator<
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@erase
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	DWORD PTR tv442[ebp], eax
	mov	eax, DWORD PTR tv442[ebp]
	mov	DWORD PTR tv393[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T21[ebp]
	or	ecx, 2
	mov	DWORD PTR $T21[ebp], ecx
	mov	ecx, DWORD PTR tv393[ebp]
	call	??M?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator<
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN13@erase
	mov	DWORD PTR tv183[ebp], 0
	jmp	SHORT $LN14@erase
$LN13@erase:
	mov	DWORD PTR tv183[ebp], 1
$LN14@erase:
	mov	al, BYTE PTR tv183[ebp]
	mov	BYTE PTR $T4[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T21[ebp]
	and	ecx, 2
	je	SHORT $LN29@erase
	and	DWORD PTR $T21[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
$LN29@erase:
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR $T21[ebp]
	and	edx, 1
	je	SHORT $LN30@erase
	and	DWORD PTR $T21[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
$LN30@erase:
	movzx	eax, BYTE PTR $T4[ebp]
	test	eax, eax
	je	SHORT $LN10@erase

; 1608 : 			_DEBUG_ERROR("deque erase iterator outside range");

	mov	esi, esp
	push	1608					; 00000648H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EG@IIKPBBHP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa?$AAn@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@erase:

; 1609 : 		_DEBUG_RANGE(_First, _Last);

	push	1609					; 00000649H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T7[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv446[ebp], eax
	mov	ecx, DWORD PTR tv446[ebp]
	mov	DWORD PTR tv401[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T8[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv404[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??$_Debug_range@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 32					; 00000020H

; 1610 : 
; 1611 : 		size_type _Off = _First - begin();

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv480[ebp], eax
	mov	ecx, DWORD PTR tv480[ebp]
	mov	DWORD PTR tv406[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR tv406[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	mov	DWORD PTR __Off$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ

; 1612 : 		size_type _Count = _Last - _First;

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	mov	DWORD PTR __Count$[ebp], eax

; 1613 : 		bool _Moved = 0 < _Off && _Off + _Count < this->_Mysize;

	cmp	DWORD PTR __Off$[ebp], 0
	jbe	SHORT $LN15@erase
	mov	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+16]
	jae	SHORT $LN15@erase
	mov	DWORD PTR tv246[ebp], 1
	jmp	SHORT $LN16@erase
$LN15@erase:
	mov	DWORD PTR tv246[ebp], 0
$LN16@erase:
	mov	dl, BYTE PTR tv246[ebp]
	mov	BYTE PTR __Moved$[ebp], dl

; 1614 : 
; 1615 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1616 : 		size_type _Off = _First - begin();
; 1617 : 		size_type _Count = _Last - _First;
; 1618 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1619 : 
; 1620 : 		if (_Off < (size_type)(end() - _Last))

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	DWORD PTR tv481[ebp], eax
	mov	edx, DWORD PTR tv481[ebp]
	mov	DWORD PTR tv408[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR tv408[ebp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	cmp	DWORD PTR __Off$[ebp], eax
	jae	SHORT $LN17@erase
	mov	DWORD PTR tv261[ebp], 1
	jmp	SHORT $LN18@erase
$LN17@erase:
	mov	DWORD PTR tv261[ebp], 0
$LN18@erase:
	mov	al, BYTE PTR tv261[ebp]
	mov	BYTE PTR $T10[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	movzx	ecx, BYTE PTR $T10[ebp]
	test	ecx, ecx
	je	$LN9@erase

; 1621 : 			{	// closer to front
; 1622 : 			_Move_backward(begin(), _First, _Last);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T12[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv482[ebp], eax
	mov	ecx, DWORD PTR tv482[ebp]
	mov	DWORD PTR tv410[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T13[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv414[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T14[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv417[ebp], eax
	lea	ecx, DWORD PTR $T15[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??$_Move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv411[ebp], eax
	lea	ecx, DWORD PTR $T15[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ

; 1623 : 			for (; 0 < _Count; --_Count)

	jmp	SHORT $LN8@erase
$LN7@erase:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN8@erase:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN6@erase

; 1624 : 				pop_front();	// pop copied elements

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front
	jmp	SHORT $LN7@erase
$LN6@erase:

; 1625 : 			}
; 1626 : 		else

	jmp	$LN5@erase
$LN9@erase:

; 1627 : 			{	// closer to back
; 1628 : 			_Move(_Last, end(), _First);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T16[ebp], esp
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv484[ebp], eax
	mov	ecx, DWORD PTR tv484[ebp]
	mov	DWORD PTR tv420[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T17[ebp], esp
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	DWORD PTR tv485[ebp], eax
	mov	eax, DWORD PTR tv485[ebp]
	mov	DWORD PTR tv424[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T18[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv427[ebp], eax
	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??$_Move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv421[ebp], eax
	lea	ecx, DWORD PTR $T19[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ

; 1629 : 			for (; 0 < _Count; --_Count)

	jmp	SHORT $LN4@erase
$LN3@erase:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@erase:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN5@erase

; 1630 : 				pop_back();	// pop copied elements

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
	jmp	SHORT $LN3@erase
$LN5@erase:

; 1631 : 			}
; 1632 : 
; 1633 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1634 : 		if (_Moved)

	movzx	eax, BYTE PTR __Moved$[ebp]
	test	eax, eax
	je	SHORT $LN1@erase

; 1635 : 			this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@erase:

; 1636 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1637 : 
; 1638 : 		return (begin() + _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T20[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv487[ebp], eax
	mov	eax, DWORD PTR tv487[ebp]
	mov	DWORD PTR tv430[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR tv430[ebp]
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	ecx, DWORD PTR $T21[ebp]
	or	ecx, 4
	mov	DWORD PTR $T21[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T20[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First_arg$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last_arg$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1639 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN50@erase
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 612				; 00000264H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	3
$LN50@erase:
	DD	2
	DD	$LN49@erase
$LN49@erase:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN46@erase
	DD	-60					; ffffffc4H
	DD	12					; 0000000cH
	DD	$LN47@erase
$LN47@erase:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN46@erase:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$0:
	lea	ecx, DWORD PTR __Last_arg$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$1:
	lea	ecx, DWORD PTR __First_arg$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$3:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$5:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$6:
	mov	eax, DWORD PTR $T21[ebp]
	and	eax, 1
	je	$LN26@erase
	and	DWORD PTR $T21[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
$LN26@erase:
	ret	0
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$7:
	mov	eax, DWORD PTR $T21[ebp]
	and	eax, 2
	je	$LN28@erase
	and	DWORD PTR $T21[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
$LN28@erase:
	ret	0
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$8:
	mov	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$10:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$11:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$12:
	mov	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$16:
	mov	ecx, DWORD PTR $T16[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$17:
	mov	ecx, DWORD PTR $T17[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z$20:
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-616]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
tv149 = -244						; size = 4
$T1 = -233						; size = 1
__Block$2 = -32						; size = 4
__Newoff$3 = -20					; size = 4
_this$ = -8						; size = 4
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back, COMDAT
; _this$ = ecx

; 1471 : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@pop_back

; 1474 : 			_DEBUG_ERROR("deque empty before pop");

	mov	esi, esp
	push	1474					; 000005c2H
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1475 : 		else

	jmp	$LN4@pop_back
$LN3@pop_back:

; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR __Newoff$3[ebp], ecx

; 1478 : 			_Orphan_off(_Newoff);

	mov	eax, DWORD PTR __Newoff$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Orphan_off

; 1479 : 			size_type _Block = this->_Getblock(_Newoff);

	mov	eax, DWORD PTR __Newoff$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
	mov	DWORD PTR __Block$2[ebp], eax

; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Newoff$3[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$2[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value *>

; 1482 : 			if (--this->_Mysize == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, 1
	mov	DWORD PTR tv149[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR [edx+16], eax
	cmp	DWORD PTR tv149[ebp], 0
	jne	SHORT $LN4@pop_back

; 1483 : 				this->_Myoff = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN4@pop_back:

; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1491 : 		if (--this->_Mysize == 0)
; 1492 : 			this->_Myoff = 0;
; 1493 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1494 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Block$ = -32						; size = 4
__Newoff$ = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back, COMDAT
; _this$ = ecx

; 1462 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1463 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1464 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_back
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 4
	shr	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], ecx
	ja	SHORT $LN2@push_back
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN2@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx*4-1]
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR __Newoff$[ebp], ecx
	mov	eax, DWORD PTR __Newoff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	jne	SHORT $LN1@push_back
	push	4
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@push_back:

; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVValue@Json@@ABQAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>

; 1467 : 		_PUSH_BACK_END;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1468 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
tv152 = -232						; size = 4
$T1 = -221						; size = 1
__Block$2 = -20						; size = 4
_this$ = -8						; size = 4
?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front, COMDAT
; _this$ = ecx

; 1434 : 		{	// erase element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@pop_front

; 1437 : 			_DEBUG_ERROR("deque empty before pop");

	mov	esi, esp
	push	1437					; 0000059dH
	push	OFFSET ??_C@_1IK@DNCJHBGE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1438 : 		else

	jmp	$LN5@pop_front
$LN4@pop_front:

; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_off@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Orphan_off

; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
	mov	DWORD PTR __Block$2[ebp], eax

; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$2[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value *>

; 1444 : 			if (--this->_Mysize == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, 1
	mov	DWORD PTR tv152[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv152[ebp]
	mov	DWORD PTR [edx+16], eax
	cmp	DWORD PTR tv152[ebp], 0
	jne	SHORT $LN2@pop_front

; 1445 : 				this->_Myoff = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 1446 : 			else

	jmp	SHORT $LN5@pop_front
$LN2@pop_front:

; 1447 : 				++this->_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN5@pop_front:

; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT
tv154 = -256						; size = 4
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Block$ = -32						; size = 4
__Newoff$ = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_front, COMDAT
; _this$ = ecx

; 1425 : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1426 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1427 : 		_PUSH_FRONT_BEGIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_front
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 4
	shr	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], ecx
	ja	SHORT $LN2@push_front
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN2@push_front:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx*4-1]
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@push_front
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv154[ebp], edx
	jmp	SHORT $LN6@push_front
$LN5@push_front:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 2
	mov	DWORD PTR tv154[ebp], ecx
$LN6@push_front:
	mov	edx, DWORD PTR tv154[ebp]
	mov	DWORD PTR __Newoff$[ebp], edx
	mov	eax, DWORD PTR __Newoff$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Newoff$[ebp], eax
	mov	ecx, DWORD PTR __Newoff$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	jne	SHORT $LN1@push_front
	push	4
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@push_front:

; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVValue@Json@@ABQAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>

; 1430 : 		_PUSH_FRONT_END;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newoff$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1431 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_front
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
tv80 = -284						; size = 4
tv82 = -280						; size = 4
tv78 = -276						; size = 4
tv81 = -272						; size = 4
$T2 = -264						; size = 4
$T3 = -252						; size = 12
$T4 = -232						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back, COMDAT
; _this$ = ecx

; 1415 : 		{	// return last element of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1416 : 		return (*(end() - 1));

	push	1
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	DWORD PTR tv81[ebp], eax
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR tv78[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv78[ebp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	mov	DWORD PTR tv82[ebp], eax
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv80[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv80[ebp]
	call	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ$1:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv70 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty, COMDAT
; _this$ = ecx

; 1361 : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1362 : 		return (this->_Mysize == 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv70[ebp], 0
$LN4@empty:
	mov	al, BYTE PTR tv70[ebp]

; 1363 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size, COMDAT
; _this$ = ecx

; 1356 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1357 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Json::Value *> >::max_size

; 1358 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter, COMDAT
; _this$ = ecx

; 1270 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1271 : 		return (iterator(_Where._Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1272 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end, COMDAT
; _this$ = ecx

; 1265 : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1266 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1267 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end, COMDAT
; _this$ = ecx

; 1260 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1261 : 		return (iterator(this->_Myoff + this->_Mysize, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1262 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin, COMDAT
; _this$ = ecx

; 1255 : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1256 : 		return (const_iterator(this->_Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1257 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin, COMDAT
; _this$ = ecx

; 1250 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1251 : 		return (iterator(this->_Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1252 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv386 = -576						; size = 4
tv394 = -572						; size = 4
tv391 = -568						; size = 4
tv366 = -568						; size = 4
tv403 = -564						; size = 4
tv376 = -564						; size = 4
tv369 = -564						; size = 4
tv389 = -560						; size = 4
tv382 = -560						; size = 4
tv365 = -560						; size = 4
tv354 = -560						; size = 4
tv402 = -556						; size = 4
tv397 = -556						; size = 4
tv379 = -556						; size = 4
tv360 = -556						; size = 4
tv385 = -552						; size = 4
tv375 = -552						; size = 4
tv372 = -552						; size = 4
tv363 = -552						; size = 4
tv357 = -552						; size = 4
tv401 = -548						; size = 4
tv399 = -548						; size = 4
tv396 = -548						; size = 4
tv353 = -548						; size = 4
tv247 = -548						; size = 4
$T2 = -537						; size = 1
$T3 = -525						; size = 1
$T4 = -513						; size = 1
$T5 = -504						; size = 4
$T6 = -492						; size = 4
$T7 = -480						; size = 4
$T8 = -468						; size = 4
$T9 = -456						; size = 12
$T10 = -436						; size = 4
$T11 = -424						; size = 12
$T12 = -404						; size = 12
$T13 = -384						; size = 4
$T14 = -372						; size = 4
$T15 = -360						; size = 4
$T16 = -348						; size = 12
$T17 = -328						; size = 4
$T18 = -316						; size = 4
$T19 = -304						; size = 4
$T20 = -292						; size = 12
$T21 = -272						; size = 12
__Mid$22 = -60						; size = 12
__Mid$23 = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=, COMDAT
; _this$ = ecx

; 1219 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 564				; 00000234H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-576]
	mov	ecx, 141				; 0000008dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1220 : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN6@operator

; 1221 : 			{	// different, assign it
; 1222 : 			if (this->_Getal() != _Right._Getal()
; 1223 : 				&& _Alty::propagate_on_container_copy_assignment::value)

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	push	eax
	call	??$?9V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ; std::operator!=<std::allocator<Json::Value *>,std::allocator<Json::Value *> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@operator
	xor	eax, eax
	je	SHORT $LN5@operator

; 1224 : 				{	// change allocator before copying
; 1225 : 				_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy

; 1226 : 				this->_Change_alloc(_Right._Getal());

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Change_alloc@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Change_alloc
$LN5@operator:

; 1227 : 				}
; 1228 : 
; 1229 : 			this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1230 : 
; 1231 : 			if (_Right._Mysize == 0)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN4@operator

; 1232 : 				clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::clear
	jmp	$LN6@operator
$LN4@operator:

; 1233 : 			else if (_Right._Mysize <= this->_Mysize)

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	ja	$LN2@operator

; 1234 : 				{	// enough elements, copy new and destroy old
; 1235 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1236 : 					begin());

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T5[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv353[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T6[ebp], esp
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	DWORD PTR tv357[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T7[ebp], esp
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv360[ebp], eax
	lea	eax, DWORD PTR __Mid$23[ebp]
	push	eax
	call	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv354[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1237 : 				erase(_Mid, end());

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	DWORD PTR tv396[ebp], eax
	mov	ecx, DWORD PTR tv396[ebp]
	mov	DWORD PTR tv363[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T8[ebp], esp
	mov	edx, DWORD PTR tv363[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv397[ebp], eax
	mov	eax, DWORD PTR tv397[ebp]
	mov	DWORD PTR tv365[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T10[ebp], esp
	lea	edx, DWORD PTR __Mid$23[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv369[ebp], eax
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase
	mov	DWORD PTR tv366[ebp], eax
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ

; 1238 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Mid$23[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ

; 1239 : 			else

	jmp	$LN6@operator
$LN2@operator:

; 1240 : 				{	// new sequence longer, copy and construct new
; 1241 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	lea	edx, DWORD PTR __Mid$22[ebp]
	push	edx
	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv399[ebp], eax
	mov	ecx, DWORD PTR tv399[ebp]
	mov	DWORD PTR tv372[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv372[ebp]
	call	??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T12[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ

; 1242 : 				_STD copy(_Right.begin(), _Mid, begin());

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T13[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv247[ebp], eax
	mov	ecx, DWORD PTR tv247[ebp]
	mov	DWORD PTR tv375[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T14[ebp], esp
	lea	edx, DWORD PTR __Mid$22[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv379[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T15[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv382[ebp], eax
	lea	ecx, DWORD PTR $T16[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	call	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv376[ebp], eax
	lea	ecx, DWORD PTR $T16[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ

; 1243 : 				insert(end(), _Mid, _Right.end());

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T17[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	DWORD PTR tv401[ebp], eax
	mov	ecx, DWORD PTR tv401[ebp]
	mov	DWORD PTR tv385[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T18[ebp], esp
	lea	edx, DWORD PTR __Mid$22[ebp]
	push	edx
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv402[ebp], eax
	mov	eax, DWORD PTR tv402[ebp]
	mov	DWORD PTR tv389[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T20[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	DWORD PTR tv403[ebp], eax
	mov	edx, DWORD PTR tv403[ebp]
	mov	DWORD PTR tv391[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T19[ebp], esp
	mov	eax, DWORD PTR tv391[ebp]
	push	eax
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv394[ebp], eax
	lea	ecx, DWORD PTR $T21[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	mov	DWORD PTR tv386[ebp], eax
	lea	ecx, DWORD PTR $T21[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T20[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ

; 1244 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Mid$22[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
$LN6@operator:

; 1245 : 			}
; 1246 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1247 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 576				; 00000240H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN32@operator:
	DD	2
	DD	$LN31@operator
$LN31@operator:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN28@operator
	DD	-60					; ffffffc4H
	DD	12					; 0000000cH
	DD	$LN29@operator
$LN29@operator:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$LN28@operator:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$3:
	lea	ecx, DWORD PTR __Mid$23[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$4:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$5:
	mov	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$8:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$9:
	lea	ecx, DWORD PTR __Mid$22[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$10:
	mov	ecx, DWORD PTR $T13[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$14:
	mov	ecx, DWORD PTR $T17[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$15:
	mov	ecx, DWORD PTR $T18[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z$16:
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-580]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 1214 : 		{	// destroy the deque

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1215 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy

; 1216 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z
_TEXT	SEGMENT
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Block$ = -32						; size = 4
__Newoff$ = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back, COMDAT
; _this$ = ecx

; 1129 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1130 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_back
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 4
	shr	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], ecx
	ja	SHORT $LN2@push_back
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN2@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx*4-1]
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR __Newoff$[ebp], ecx
	mov	eax, DWORD PTR __Newoff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	jne	SHORT $LN1@push_back
	push	4
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@push_back:

; 1132 : 		this->_Getal().construct(
; 1133 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 			_STD forward<value_type>(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::forward<Json::Value *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>

; 1135 : 		_PUSH_BACK_END;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1136 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv155 = -272						; size = 4
tv152 = -268						; size = 4
$T2 = -257						; size = 1
$T3 = -245						; size = 1
$T4 = -236						; size = 4
$T5 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 982  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
	mov	ecx, eax
	call	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<Json::Value *> >::select_on_container_copy_construction
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 983  : 		_Construct(_Right.begin(), _Right.end());

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T4[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	DWORD PTR tv152[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	DWORD PTR tv155[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >

; 984  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
__ehhandler$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-276]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 951  : 		{	// construct empty deque

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@PAVValue@Json@@@std@@QAE@XZ ; std::allocator<Json::Value *>::allocator<Json::Value *>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >

; 952  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal, COMDAT
; _this$ = ecx

; 911  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 912  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 913  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 901  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 902  : 		typename _Alty::template rebind<_Container_proxy>::other
; 903  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >

; 904  : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 905  : 		_Alproxy.destroy(this->_Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 906  : 		_Alproxy.deallocate(this->_Myproxy, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 907  : 		this->_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 908  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 892  : 		{	// construct proxy from _Alval

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 893  : 		typename _Alty::template rebind<_Container_proxy>::other
; 894  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >

; 895  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 896  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 898  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Change_alloc@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
?_Change_alloc@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Change_alloc, COMDAT
; _this$ = ecx

; 883  : 		{	// replace old allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Change_alloc@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 879  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Free_proxy

; 880  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Deque_val<std::_Deque_simple_types<Json::Value *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 873  : 		{	// construct allocators from _Al
; 874  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Alloc_proxy

; 875  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::~_Deque_val<std::_Deque_simple_types<Json::Value *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::~_Deque_val<std::_Deque_simple_types<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock, COMDAT
; _this$ = ecx

; 780  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 781  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	eax, DWORD PTR __Off$[ebp]
	shr	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 1
	and	eax, edx

; 783  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Deque_val<std::_Deque_simple_types<Json::Value *> >, COMDAT
; _this$ = ecx

; 771  : 	_Deque_val()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 772  : 		{	// initialize values
; 773  : 		_Map = _Mapptr();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 774  : 		_Mapsize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 775  : 		_Myoff = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 776  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 777  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Deque_val<std::_Deque_simple_types<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::deallocate

; 859  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::allocate

; 848  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value * *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ; std::_Allocate<Json::Value * *>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value * *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::max_size
	add	esp, 4

; 885  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::deallocate

; 859  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::allocate

; 848  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 806  : 		{	// construct by copying base

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>

; 807  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAVValue@Json@@@std@@QAE@XZ ; std::allocator<Json::Value *>::allocator<Json::Value *>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SA?AV?$allocator@PAVValue@Json@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SA?AV?$allocator@PAVValue@Json@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SA?AV?$allocator@PAVValue@Json@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 741  : 		return (_Al.select_on_container_copy_construction());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?select_on_container_copy_construction@?$allocator@PAVValue@Json@@@std@@QBE?AV12@XZ ; std::allocator<Json::Value *>::select_on_container_copy_construction
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SA?AV?$allocator@PAVValue@Json@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ; std::allocator<Json::Value *>::max_size

; 736  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ PROC	; std::allocator<Json::Value *>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 613  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ENDP	; std::allocator<Json::Value *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z
_TEXT	SEGMENT
tv68 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z PROC ; std::allocator<Json::Value *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@construct:

; 594  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z ENDP ; std::allocator<Json::Value *>::construct
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ; std::_Allocate<Json::Value *>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z PROC	; std::allocator<Json::Value *>::allocator<Json::Value *>, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<Json::Value *>::allocator<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ PROC		; std::allocator<Json::Value *>::allocator<Json::Value *>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ ENDP		; std::allocator<Json::Value *>::allocator<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@PAVValue@Json@@@std@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@PAVValue@Json@@@std@@QBE?AV12@XZ PROC ; std::allocator<Json::Value *>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$allocator@PAVValue@Json@@@std@@QBE?AV12@XZ ENDP ; std::allocator<Json::Value *>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_token$ = 8						; size = 4
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z PROC	; Json::Reader::skipCommentTokens, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 248  :    if ( features_.allowComments_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+116]
	test	ecx, ecx
	je	SHORT $LN5@skipCommen
$LN4@skipCommen:

; 249  :    {
; 250  :       do
; 251  :       {
; 252  :          readToken( token );

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 253  :       }
; 254  :       while ( token.type_ == tokenComment );

	mov	eax, DWORD PTR _token$[ebp]
	cmp	DWORD PTR [eax], 12			; 0000000cH
	je	SHORT $LN4@skipCommen

; 255  :    }
; 256  :    else

	jmp	SHORT $LN6@skipCommen
$LN5@skipCommen:

; 257  :    {
; 258  :       readToken( token );

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
$LN6@skipCommen:

; 259  :    }
; 260  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ENDP	; Json::Reader::skipCommentTokens
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
_TEXT	SEGMENT
tv142 = -300						; size = 4
tv140 = -300						; size = 4
tv144 = -296						; size = 4
tv143 = -296						; size = 4
$T2 = -288						; size = 28
$T3 = -252						; size = 28
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
_placement$ = 16					; size = 4
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z PROC ; Json::Reader::addComment, COMDAT
; _this$ = ecx

; 409  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 410  :    assert( collectComments_ );

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+118]
	test	ecx, ecx
	jne	SHORT $LN6@addComment
	mov	edx, DWORD PTR ?__LINE__Var@?1??addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@3@@Z@4JA
	add	edx, 1
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1OG@MJGKPHCJ@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AE5?$AE2?$AE3?$AE5?$AE?$DN?$AE8?$AE9?$AA?2?$AAd?$AAr?$AAo?$AAp?$AAb?$AAo?$AAx?$AA?2?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt@
	push	OFFSET ??_C@_1CC@CHPNCPJ@?$AAc?$AAo?$AAl?$AAl?$AAe?$AAc?$AAt?$AAC?$AAo?$AAm?$AAm?$AAe?$AAn?$AAt?$AAs?$AA_?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@addComment:

; 411  :    if ( placement == commentAfterOnSameLine )

	cmp	DWORD PTR _placement$[ebp], 1
	jne	$LN3@addComment

; 412  :    {
; 413  :       assert( lastValue_ != 0 );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 0
	jne	SHORT $LN7@addComment
	mov	ecx, DWORD PTR ?__LINE__Var@?1??addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@3@@Z@4JA
	add	ecx, 4
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1OG@MJGKPHCJ@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AE5?$AE2?$AE3?$AE5?$AE?$DN?$AE8?$AE9?$AA?2?$AAd?$AAr?$AAo?$AAp?$AAb?$AAo?$AAx?$AA?2?$AAp?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt@
	push	OFFSET ??_C@_1CA@HJPILKKO@?$AAl?$AAa?$AAs?$AAt?$AAV?$AAa?$AAl?$AAu?$AAe?$AA_?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@addComment:

; 414  :       lastValue_->setComment( std::string( begin, end ), placement );

	mov	eax, DWORD PTR _placement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _begin$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv143[ebp], eax
	mov	eax, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv140[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv140[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+84]
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 415  :    }
; 416  :    else

	jmp	SHORT $LN4@addComment
$LN3@addComment:

; 417  :    {
; 418  :       if ( !commentsBefore_.empty() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@addComment

; 419  :          commentsBefore_ += "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN1@addComment:

; 420  :       commentsBefore_ += std::string( begin, end );

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _begin$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv144[ebp], eax
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR tv142[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv142[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@addComment:

; 421  :    }
; 422  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-304]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ENDP ; Json::Reader::addComment
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
_TEXT	SEGMENT
$T1 = -300						; size = 4
_buffer$ = -96						; size = 51
_column$ = -36						; size = 4
_line$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_location$ = 12						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = ecx

; 848  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 849  :    int line, column;
; 850  :    getLocationLineAndColumn( location, line, column );

	lea	eax, DWORD PTR _column$[ebp]
	push	eax
	lea	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	edx, DWORD PTR _location$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ; Json::Reader::getLocationLineAndColumn

; 851  :    char buffer[18+16+16+1];
; 852  :    sprintf( buffer, "Line %d, Column %d", line, column );

	mov	esi, esp
	mov	eax, DWORD PTR _column$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 853  :    return buffer;

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 854  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@getLocatio
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN9@getLocatio:
	DD	3
	DD	$LN8@getLocatio
$LN8@getLocatio:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN5@getLocatio
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN6@getLocatio
	DD	-96					; ffffffa0H
	DD	51					; 00000033H
	DD	$LN7@getLocatio
$LN7@getLocatio:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN6@getLocatio:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	110					; 0000006eH
	DB	0
$LN5@getLocatio:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	0
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z
_TEXT	SEGMENT
_c$1 = -41						; size = 1
_lastLineStart$ = -32					; size = 4
_current$ = -20						; size = 4
_this$ = -8						; size = 4
_location$ = 8						; size = 4
_line$ = 12						; size = 4
_column$ = 16						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z PROC ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = ecx

; 820  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 821  :    Location current = begin_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR _current$[ebp], ecx

; 822  :    Location lastLineStart = current;

	mov	eax, DWORD PTR _current$[ebp]
	mov	DWORD PTR _lastLineStart$[ebp], eax

; 823  :    line = 0;

	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax], 0
$LN6@getLocatio:

; 824  :    while ( current < location  &&  current != end_ )

	mov	eax, DWORD PTR _current$[ebp]
	cmp	eax, DWORD PTR _location$[ebp]
	jae	SHORT $LN5@getLocatio
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	je	SHORT $LN5@getLocatio

; 825  :    {
; 826  :       Char c = *current++;

	mov	eax, DWORD PTR _current$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$1[ebp], cl
	mov	edx, DWORD PTR _current$[ebp]
	add	edx, 1
	mov	DWORD PTR _current$[ebp], edx

; 827  :       if ( c == '\r' )

	movsx	eax, BYTE PTR _c$1[ebp]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN4@getLocatio

; 828  :       {
; 829  :          if ( *current == '\n' )

	mov	eax, DWORD PTR _current$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN3@getLocatio

; 830  :             ++current;

	mov	eax, DWORD PTR _current$[ebp]
	add	eax, 1
	mov	DWORD PTR _current$[ebp], eax
$LN3@getLocatio:

; 831  :          lastLineStart = current;

	mov	eax, DWORD PTR _current$[ebp]
	mov	DWORD PTR _lastLineStart$[ebp], eax

; 832  :          ++line;

	mov	eax, DWORD PTR _line$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@getLocatio
$LN4@getLocatio:

; 833  :       }
; 834  :       else if ( c == '\n' )

	movsx	eax, BYTE PTR _c$1[ebp]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN2@getLocatio

; 835  :       {
; 836  :          lastLineStart = current;

	mov	eax, DWORD PTR _current$[ebp]
	mov	DWORD PTR _lastLineStart$[ebp], eax

; 837  :          ++line;

	mov	eax, DWORD PTR _line$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@getLocatio:

; 838  :       }
; 839  :    }

	jmp	SHORT $LN6@getLocatio
$LN5@getLocatio:

; 840  :    // column & line start at 1
; 841  :    column = int(location - lastLineStart) + 1;

	mov	eax, DWORD PTR _location$[ebp]
	sub	eax, DWORD PTR _lastLineStart$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _column$[ebp]
	mov	DWORD PTR [ecx], eax

; 842  :    ++line;

	mov	eax, DWORD PTR _line$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [edx], ecx

; 843  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?getNextChar@Reader@Json@@AAEDXZ
_TEXT	SEGMENT
tv72 = -205						; size = 1
_this$ = -8						; size = 4
?getNextChar@Reader@Json@@AAEDXZ PROC			; Json::Reader::getNextChar, COMDAT
; _this$ = ecx

; 809  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 810  :    if ( current_ == end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+76]
	cmp	edx, DWORD PTR [ecx+72]
	jne	SHORT $LN1@getNextCha

; 811  :       return 0;

	xor	al, al
	jmp	SHORT $LN2@getNextCha
$LN1@getNextCha:

; 812  :    return *current_++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv72[ebp], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], ecx
	mov	al, BYTE PTR tv72[ebp]
$LN2@getNextCha:

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getNextChar@Reader@Json@@AAEDXZ ENDP			; Json::Reader::getNextChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?currentValue@Reader@Json@@AAEAAVValue@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?currentValue@Reader@Json@@AAEAAVValue@2@XZ PROC	; Json::Reader::currentValue, COMDAT
; _this$ = ecx

; 802  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 803  :    return *(nodes_.top());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
	mov	eax, DWORD PTR [eax]

; 804  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?currentValue@Reader@Json@@AAEAAVValue@2@XZ ENDP	; Json::Reader::currentValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_message$ = 8						; size = 4
_token$ = 12						; size = 4
_skipUntilToken$ = 16					; size = 4
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z PROC ; Json::Reader::addErrorAndRecover, COMDAT
; _this$ = ecx

; 794  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 795  :    addError( message, token );

	push	0
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError

; 796  :    return recoverFromError( skipUntilToken );

	mov	eax, DWORD PTR _skipUntilToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError

; 797  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ENDP ; Json::Reader::addErrorAndRecover
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z
_TEXT	SEGMENT
_skip$ = -40						; size = 12
_errorCount$ = -20					; size = 4
_this$ = -8						; size = 4
_skipUntilToken$ = 8					; size = 4
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z PROC ; Json::Reader::recoverFromError, COMDAT
; _this$ = ecx

; 775  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 776  :    int errorCount = int(errors_.size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
	mov	DWORD PTR _errorCount$[ebp], eax
$LN5@recoverFro:

; 777  :    Token skip;
; 778  :    while ( true )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN4@recoverFro

; 779  :    {
; 780  :       if ( !readToken(skip) )

	lea	eax, DWORD PTR _skip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@recoverFro

; 781  :          errors_.resize( errorCount ); // discard errors caused by recovery

	mov	eax, DWORD PTR _errorCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN3@recoverFro:

; 782  :       if ( skip.type_ == skipUntilToken  ||  skip.type_ == tokenEndOfStream )

	mov	eax, DWORD PTR _skip$[ebp]
	cmp	eax, DWORD PTR _skipUntilToken$[ebp]
	je	SHORT $LN1@recoverFro
	cmp	DWORD PTR _skip$[ebp], 0
	jne	SHORT $LN2@recoverFro
$LN1@recoverFro:

; 783  :          break;

	jmp	SHORT $LN4@recoverFro
$LN2@recoverFro:

; 784  :    }

	jmp	SHORT $LN5@recoverFro
$LN4@recoverFro:

; 785  :    errors_.resize( errorCount );

	mov	eax, DWORD PTR _errorCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize

; 786  :    return false;

	xor	al, al

; 787  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@recoverFro
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN10@recoverFro:
	DD	1
	DD	$LN9@recoverFro
$LN9@recoverFro:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN8@recoverFro
$LN8@recoverFro:
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	112					; 00000070H
	DB	0
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ENDP ; Json::Reader::recoverFromError
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
_TEXT	SEGMENT
$T2 = -277						; size = 1
_info$ = -76						; size = 44
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_message$ = 8						; size = 4
_token$ = 12						; size = 4
_extra$ = 16						; size = 4
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z PROC ; Json::Reader::addError, COMDAT
; _this$ = ecx

; 763  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 764  :    ErrorInfo info;

	lea	ecx, DWORD PTR _info$[ebp]
	call	??0ErrorInfo@Reader@Json@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 765  :    info.token_ = token;

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _info$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _info$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _info$[ebp+8], eax

; 766  :    info.message_ = message;

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	lea	ecx, DWORD PTR _info$[ebp+12]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 767  :    info.extra_ = extra;

	mov	eax, DWORD PTR _extra$[ebp]
	mov	DWORD PTR _info$[ebp+40], eax

; 768  :    errors_.push_back( info );

	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back

; 769  :    return false;

	mov	BYTE PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _info$[ebp]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	mov	al, BYTE PTR $T2[ebp]

; 770  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@addError
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN7@addError:
	DD	1
	DD	$LN6@addError
$LN6@addError:
	DD	-76					; ffffffb4H
	DD	44					; 0000002cH
	DD	$LN4@addError
$LN4@addError:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z$0:
	lea	ecx, DWORD PTR _info$[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ENDP ; Json::Reader::addError
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT
$T2 = -336						; size = 28
$T3 = -300						; size = 28
$T4 = -261						; size = 1
$T5 = -249						; size = 1
_c$6 = -45						; size = 1
_index$7 = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_current$ = 12						; size = 4
_end$ = 16						; size = 4
_unicode$ = 20						; size = 4
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z PROC ; Json::Reader::decodeUnicodeEscapeSequence, COMDAT
; _this$ = ecx

; 738  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 739  :    if ( end - current < 4 )

	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	jge	SHORT $LN10@decodeUnic

; 740  :       return addError( "Bad unicode escape sequence in string: four digits expected.", token, current );

	push	OFFSET ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T4[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T4[ebp]
	jmp	$LN11@decodeUnic
$LN10@decodeUnic:

; 741  :    unicode = 0;

	mov	eax, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [eax], 0

; 742  :    for ( int index =0; index < 4; ++index )

	mov	DWORD PTR _index$7[ebp], 0
	jmp	SHORT $LN9@decodeUnic
$LN8@decodeUnic:
	mov	eax, DWORD PTR _index$7[ebp]
	add	eax, 1
	mov	DWORD PTR _index$7[ebp], eax
$LN9@decodeUnic:
	cmp	DWORD PTR _index$7[ebp], 4
	jge	$LN7@decodeUnic

; 743  :    {
; 744  :       Char c = *current++;

	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$6[ebp], dl
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _current$[ebp]
	mov	DWORD PTR [edx], ecx

; 745  :       unicode *= 16;

	mov	eax, DWORD PTR _unicode$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 4
	mov	edx, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [edx], ecx

; 746  :       if ( c >= '0'  &&  c <= '9' )

	movsx	eax, BYTE PTR _c$6[ebp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN6@decodeUnic
	movsx	eax, BYTE PTR _c$6[ebp]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN6@decodeUnic

; 747  :          unicode += c - '0';

	movsx	eax, BYTE PTR _c$6[ebp]
	mov	ecx, DWORD PTR _unicode$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-48]
	mov	ecx, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	$LN5@decodeUnic
$LN6@decodeUnic:

; 748  :       else if ( c >= 'a'  &&  c <= 'f' )

	movsx	eax, BYTE PTR _c$6[ebp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN4@decodeUnic
	movsx	eax, BYTE PTR _c$6[ebp]
	cmp	eax, 102				; 00000066H
	jg	SHORT $LN4@decodeUnic

; 749  :          unicode += c - 'a' + 10;

	movsx	eax, BYTE PTR _c$6[ebp]
	mov	ecx, DWORD PTR _unicode$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-87]
	mov	ecx, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN5@decodeUnic
$LN4@decodeUnic:

; 750  :       else if ( c >= 'A'  &&  c <= 'F' )

	movsx	eax, BYTE PTR _c$6[ebp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN2@decodeUnic
	movsx	eax, BYTE PTR _c$6[ebp]
	cmp	eax, 70					; 00000046H
	jg	SHORT $LN2@decodeUnic

; 751  :          unicode += c - 'A' + 10;

	movsx	eax, BYTE PTR _c$6[ebp]
	mov	ecx, DWORD PTR _unicode$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-55]
	mov	ecx, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [ecx], eax

; 752  :       else

	jmp	SHORT $LN5@decodeUnic
$LN2@decodeUnic:

; 753  :          return addError( "Bad unicode escape sequence in string: hexadecimal digit expected.", token, current );

	push	OFFSET ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T5[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T5[ebp]
	jmp	SHORT $LN11@decodeUnic
$LN5@decodeUnic:

; 754  :    }

	jmp	$LN8@decodeUnic
$LN7@decodeUnic:

; 755  :    return true;

	mov	al, 1
$LN11@decodeUnic:

; 756  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ENDP ; Json::Reader::decodeUnicodeEscapeSequence
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT
tv129 = -336						; size = 4
tv90 = -336						; size = 4
tv128 = -332						; size = 4
tv89 = -332						; size = 4
$T2 = -324						; size = 28
$T3 = -288						; size = 28
$T4 = -249						; size = 1
$T5 = -237						; size = 1
_surrogatePair$6 = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_current$ = 12						; size = 4
_end$ = 16						; size = 4
_unicode$ = 20						; size = 4
?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z PROC ; Json::Reader::decodeUnicodeCodePoint, COMDAT
; _this$ = ecx

; 708  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-336]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 709  : 
; 710  :    if ( !decodeUnicodeEscapeSequence( token, current, end, unicode ) )

	mov	eax, DWORD PTR _unicode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _current$[ebp]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@decodeUnic

; 711  :       return false;

	xor	al, al
	jmp	$LN8@decodeUnic
$LN7@decodeUnic:

; 712  :    if (unicode >= 0xD800 && unicode <= 0xDBFF)

	mov	eax, DWORD PTR _unicode$[ebp]
	cmp	DWORD PTR [eax], 55296			; 0000d800H
	jb	$LN6@decodeUnic
	mov	eax, DWORD PTR _unicode$[ebp]
	cmp	DWORD PTR [eax], 56319			; 0000dbffH
	ja	$LN6@decodeUnic

; 713  :    {
; 714  :       // surrogate pairs
; 715  :       if (end - current < 6)

	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, DWORD PTR [eax]
	cmp	ecx, 6
	jge	SHORT $LN5@decodeUnic

; 716  :          return addError( "additional six characters expected to parse unicode surrogate pair.", token, current );

	push	OFFSET ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T4[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T4[ebp]
	jmp	$LN8@decodeUnic
$LN5@decodeUnic:

; 717  :       unsigned int surrogatePair;
; 718  :       if (*(current++) == '\\' && *(current++)== 'u')

	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv89[ebp], edx
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _current$[ebp]
	mov	DWORD PTR [edx], ecx
	cmp	DWORD PTR tv89[ebp], 92			; 0000005cH
	jne	SHORT $LN10@decodeUnic
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN11@decodeUnic
$LN10@decodeUnic:
	mov	DWORD PTR tv90[ebp], 0
$LN11@decodeUnic:
	cmp	DWORD PTR tv90[ebp], 0
	je	$LN4@decodeUnic
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv128[ebp], edx
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _current$[ebp]
	mov	DWORD PTR [edx], ecx
	cmp	DWORD PTR tv128[ebp], 117		; 00000075H
	jne	SHORT $LN12@decodeUnic
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN13@decodeUnic
$LN12@decodeUnic:
	mov	DWORD PTR tv129[ebp], 0
$LN13@decodeUnic:
	cmp	DWORD PTR tv129[ebp], 0
	je	SHORT $LN4@decodeUnic

; 719  :       {
; 720  :          if (decodeUnicodeEscapeSequence( token, current, end, surrogatePair ))

	lea	eax, DWORD PTR _surrogatePair$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _current$[ebp]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@decodeUnic

; 721  :          {
; 722  :             unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);

	mov	eax, DWORD PTR _unicode$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1023				; 000003ffH
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _surrogatePair$6[ebp]
	and	edx, 1023				; 000003ffH
	lea	eax, DWORD PTR [ecx+edx+65536]
	mov	ecx, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [ecx], eax

; 723  :          } 
; 724  :          else

	jmp	SHORT $LN2@decodeUnic
$LN3@decodeUnic:

; 725  :             return false;

	xor	al, al
	jmp	SHORT $LN8@decodeUnic
$LN2@decodeUnic:

; 726  :       } 
; 727  :       else

	jmp	SHORT $LN6@decodeUnic
$LN4@decodeUnic:

; 728  :          return addError( "expecting another \\u token to begin the second half of a unicode surrogate pair", token, current );

	push	OFFSET ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T5[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T5[ebp]
	jmp	SHORT $LN8@decodeUnic
$LN6@decodeUnic:

; 729  :    }
; 730  :    return true;

	mov	al, 1
$LN8@decodeUnic:

; 731  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@decodeUnic
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 336				; 00000150H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN19@decodeUnic:
	DD	1
	DD	$LN18@decodeUnic
$LN18@decodeUnic:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN16@decodeUnic
$LN16@decodeUnic:
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-340]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ENDP ; Json::Reader::decodeUnicodeCodePoint
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
tv163 = -528						; size = 4
tv166 = -524						; size = 4
tv161 = -520						; size = 4
tv165 = -516						; size = 4
tv159 = -512						; size = 4
tv79 = -508						; size = 4
$T2 = -500						; size = 4
$T3 = -485						; size = 1
$T4 = -476						; size = 16
$T5 = -452						; size = 28
$T6 = -416						; size = 28
$T7 = -380						; size = 28
_buffer$8 = -152					; size = 28
_buffer$9 = -116					; size = 32
_length$ = -76						; size = 4
_count$ = -64						; size = 4
_bufferSize$ = -52					; size = 4
_value$ = -40						; size = 8
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeDouble, COMDAT
; _this$ = ecx

; 621  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 516				; 00000204H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-528]
	mov	ecx, 129				; 00000081H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 622  :    double value = 0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _value$[ebp], xmm0

; 623  :    const int bufferSize = 32;

	mov	DWORD PTR _bufferSize$[ebp], 32		; 00000020H

; 624  :    int count;
; 625  :    int length = int(token.end_ - token.start_);

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _length$[ebp], edx

; 626  :    if ( length <= bufferSize )

	cmp	DWORD PTR _length$[ebp], 32		; 00000020H
	jg	SHORT $LN3@decodeDoub

; 627  :    {
; 628  :       Char buffer[bufferSize];
; 629  :       memcpy( buffer, token.start_, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR _buffer$9[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 630  :       buffer[length] = 0;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 32			; 00000020H
	jae	SHORT $LN6@decodeDoub
	jmp	SHORT $LN7@decodeDoub
$LN6@decodeDoub:
	call	___report_rangecheckfailure
$LN7@decodeDoub:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _buffer$9[ebp+ecx], 0

; 631  :       count = sscanf( buffer, "%lf", &value );

	mov	esi, esp
	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET ??_C@_03DLDNIBIK@?$CFlf?$AA@
	lea	ecx, DWORD PTR _buffer$9[ebp]
	push	ecx
	call	DWORD PTR __imp__sscanf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _count$[ebp], eax

; 632  :    }
; 633  :    else

	jmp	SHORT $LN2@decodeDoub
$LN3@decodeDoub:

; 634  :    {
; 635  :       std::string buffer( token.start_, token.end_ );

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _token$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR _buffer$8[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 636  :       count = sscanf( buffer.c_str(), "%lf", &value );

	mov	esi, esp
	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET ??_C@_03DLDNIBIK@?$CFlf?$AA@
	lea	ecx, DWORD PTR _buffer$8[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	DWORD PTR __imp__sscanf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _count$[ebp], eax

; 637  :    }

	lea	ecx, DWORD PTR _buffer$8[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2@decodeDoub:

; 638  : 
; 639  :    if ( count != 1 )

	cmp	DWORD PTR _count$[ebp], 1
	je	$LN1@decodeDoub

; 640  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	push	0
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv79[ebp], eax
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv159[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv159[ebp]
	push	eax
	push	OFFSET ??_C@_01GEODFPGF@?8?$AA@
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv165[ebp], eax
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR tv161[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv161[ebp]
	push	eax
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv166[ebp], eax
	mov	edx, DWORD PTR tv166[ebp]
	mov	DWORD PTR tv163[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv163[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T3[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T3[ebp]
	jmp	SHORT $LN4@decodeDoub
$LN1@decodeDoub:

; 641  :    currentValue() = value;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _value$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0Value@Json@@QAE@N@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 642  :    return true;

	mov	al, 1
$LN4@decodeDoub:

; 643  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@decodeDoub
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 528				; 00000210H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN18@decodeDoub:
	DD	3
	DD	$LN17@decodeDoub
$LN17@decodeDoub:
	DD	-40					; ffffffd8H
	DD	8
	DD	$LN13@decodeDoub
	DD	-116					; ffffff8cH
	DD	32					; 00000020H
	DD	$LN14@decodeDoub
	DD	-152					; ffffff68H
	DD	28					; 0000001cH
	DD	$LN15@decodeDoub
$LN15@decodeDoub:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN14@decodeDoub:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN13@decodeDoub:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-532]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeDouble
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
tv171 = -420						; size = 4
tv92 = -416						; size = 4
tv86 = -416						; size = 4
$T2 = -408						; size = 28
$T3 = -372						; size = 28
$T4 = -336						; size = 28
$T5 = -297						; size = 1
$T6 = -285						; size = 1
_unicode$7 = -84					; size = 4
_escape$8 = -69						; size = 1
_c$9 = -57						; size = 1
_end$ = -48						; size = 4
_current$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_decoded$ = 12						; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Reader::decodeString, COMDAT
; _this$ = ecx

; 659  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-420]
	mov	ecx, 102				; 00000066H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 660  :    decoded.reserve( token.end_ - token.start_ - 2 );

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sub	edx, 2
	push	edx
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 661  :    Location current = token.start_ + 1; // skip '"'

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx

; 662  :    Location end = token.end_ - 1;      // do not include '"'

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	DWORD PTR _end$[ebp], ecx
$LN20@decodeStri:

; 663  :    while ( current != end )

	mov	eax, DWORD PTR _current$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	je	$LN19@decodeStri

; 664  :    {
; 665  :       Char c = *current++;

	mov	eax, DWORD PTR _current$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$9[ebp], cl
	mov	edx, DWORD PTR _current$[ebp]
	add	edx, 1
	mov	DWORD PTR _current$[ebp], edx

; 666  :       if ( c == '"' )

	movsx	eax, BYTE PTR _c$9[ebp]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN18@decodeStri

; 667  :          break;

	jmp	$LN19@decodeStri
	jmp	$LN17@decodeStri
$LN18@decodeStri:

; 668  :       else if ( c == '\\' )

	movsx	eax, BYTE PTR _c$9[ebp]
	cmp	eax, 92					; 0000005cH
	jne	$LN16@decodeStri

; 669  :       {
; 670  :          if ( current == end )

	mov	eax, DWORD PTR _current$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jne	SHORT $LN15@decodeStri

; 671  :             return addError( "Empty escape sequence in string", token, current );

	push	OFFSET ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _current$[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T5[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T5[ebp]
	jmp	$LN21@decodeStri
$LN15@decodeStri:

; 672  :          Char escape = *current++;

	mov	eax, DWORD PTR _current$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _escape$8[ebp], cl
	mov	edx, DWORD PTR _current$[ebp]
	add	edx, 1
	mov	DWORD PTR _current$[ebp], edx

; 673  :          switch ( escape )

	movsx	eax, BYTE PTR _escape$8[ebp]
	mov	DWORD PTR tv92[ebp], eax
	mov	ecx, DWORD PTR tv92[ebp]
	sub	ecx, 34					; 00000022H
	mov	DWORD PTR tv92[ebp], ecx
	cmp	DWORD PTR tv92[ebp], 83			; 00000053H
	ja	$LN2@decodeStri
	mov	edx, DWORD PTR tv92[ebp]
	movzx	eax, BYTE PTR $LN26@decodeStri[edx]
	jmp	DWORD PTR $LN32@decodeStri[eax*4]
$LN12@decodeStri:

; 674  :          {
; 675  :          case '"': decoded += '"'; break;

	push	34					; 00000022H
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	jmp	$LN13@decodeStri
$LN11@decodeStri:

; 676  :          case '/': decoded += '/'; break;

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	jmp	$LN13@decodeStri
$LN10@decodeStri:

; 677  :          case '\\': decoded += '\\'; break;

	push	92					; 0000005cH
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	jmp	$LN13@decodeStri
$LN9@decodeStri:

; 678  :          case 'b': decoded += '\b'; break;

	push	8
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	jmp	$LN13@decodeStri
$LN8@decodeStri:

; 679  :          case 'f': decoded += '\f'; break;

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	jmp	$LN13@decodeStri
$LN7@decodeStri:

; 680  :          case 'n': decoded += '\n'; break;

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	jmp	$LN13@decodeStri
$LN6@decodeStri:

; 681  :          case 'r': decoded += '\r'; break;

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	jmp	$LN13@decodeStri
$LN5@decodeStri:

; 682  :          case 't': decoded += '\t'; break;

	push	9
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	jmp	$LN13@decodeStri
$LN4@decodeStri:

; 683  :          case 'u':
; 684  :             {
; 685  :                unsigned int unicode;
; 686  :                if ( !decodeUnicodeCodePoint( token, current, end, unicode ) )

	lea	eax, DWORD PTR _unicode$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _current$[ebp]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeCodePoint
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@decodeStri

; 687  :                   return false;

	xor	al, al
	jmp	$LN21@decodeStri
$LN3@decodeStri:

; 688  :                decoded += codePointToUTF8(unicode);

	mov	eax, DWORD PTR _unicode$7[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::codePointToUTF8
	add	esp, 8
	mov	DWORD PTR tv86[ebp], eax
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv171[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv171[ebp]
	push	eax
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 689  :             }
; 690  :             break;

	jmp	SHORT $LN13@decodeStri
$LN2@decodeStri:

; 691  :          default:
; 692  :             return addError( "Bad escape sequence in string", token, current );

	push	OFFSET ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _current$[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T6[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T6[ebp]
	jmp	SHORT $LN21@decodeStri
$LN13@decodeStri:

; 693  :          }
; 694  :       }
; 695  :       else

	jmp	SHORT $LN17@decodeStri
$LN16@decodeStri:

; 696  :       {
; 697  :          decoded += c;

	movzx	eax, BYTE PTR _c$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN17@decodeStri:

; 698  :       }
; 699  :    }

	jmp	$LN20@decodeStri
$LN19@decodeStri:

; 700  :    return true;

	mov	al, 1
$LN21@decodeStri:

; 701  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN31@decodeStri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 420				; 000001a4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN31@decodeStri:
	DD	2
	DD	$LN30@decodeStri
$LN30@decodeStri:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN27@decodeStri
	DD	-84					; ffffffacH
	DD	4
	DD	$LN28@decodeStri
$LN28@decodeStri:
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN27@decodeStri:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN32@decodeStri:
	DD	$LN12@decodeStri
	DD	$LN11@decodeStri
	DD	$LN10@decodeStri
	DD	$LN9@decodeStri
	DD	$LN8@decodeStri
	DD	$LN7@decodeStri
	DD	$LN6@decodeStri
	DD	$LN5@decodeStri
	DD	$LN4@decodeStri
	DD	$LN2@decodeStri
$LN26@decodeStri:
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	7
	DB	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-424]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Reader::decodeString
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T2 = -297						; size = 1
$T3 = -288						; size = 16
$T4 = -261						; size = 1
_decoded$ = -60						; size = 28
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeString, COMDAT
; _this$ = ecx

; 648  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 649  :    std::string decoded;

	lea	ecx, DWORD PTR _decoded$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 650  :    if ( !decodeString( token, decoded ) )

	lea	eax, DWORD PTR _decoded$[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@decodeStri

; 651  :       return false;

	mov	BYTE PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _decoded$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T2[ebp]
	jmp	SHORT $LN2@decodeStri
$LN1@decodeStri:

; 652  :    currentValue() = decoded;

	lea	eax, DWORD PTR _decoded$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::Value
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 653  :    return true;

	mov	BYTE PTR $T4[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _decoded$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T4[ebp]
$LN2@decodeStri:

; 654  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@decodeStri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN9@decodeStri:
	DD	1
	DD	$LN8@decodeStri
$LN8@decodeStri:
	DD	-60					; ffffffc4H
	DD	28					; 0000001cH
	DD	$LN6@decodeStri
$LN6@decodeStri:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR _decoded$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-308]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeString
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
tv207 = -520						; size = 4
tv213 = -516						; size = 4
tv205 = -512						; size = 4
tv212 = -508						; size = 4
tv203 = -504						; size = 4
tv211 = -500						; size = 4
tv132 = -500						; size = 4
tv92 = -500						; size = 4
tv82 = -500						; size = 4
$T2 = -489						; size = 1
$T3 = -480						; size = 16
$T4 = -456						; size = 16
$T5 = -432						; size = 16
$T6 = -408						; size = 28
$T7 = -372						; size = 28
$T8 = -336						; size = 28
_c$9 = -105						; size = 1
_value$ = -96						; size = 4
_threshold$ = -84					; size = 4
_isNegative$ = -69					; size = 1
_current$ = -60						; size = 4
_inspect$10 = -48					; size = 4
_isDouble$ = -33					; size = 1
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeNumber, COMDAT
; _this$ = ecx

; 583  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 508				; 000001fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-520]
	mov	ecx, 127				; 0000007fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 584  :    bool isDouble = false;

	mov	BYTE PTR _isDouble$[ebp], 0

; 585  :    for ( Location inspect = token.start_; inspect != token.end_; ++inspect )

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _inspect$10[ebp], ecx
	jmp	SHORT $LN14@decodeNumb
$LN13@decodeNumb:
	mov	eax, DWORD PTR _inspect$10[ebp]
	add	eax, 1
	mov	DWORD PTR _inspect$10[ebp], eax
$LN14@decodeNumb:
	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _inspect$10[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN12@decodeNumb

; 586  :    {
; 587  :       isDouble = isDouble  
; 588  :                  ||  in( *inspect, '.', 'e', 'E', '+' )  
; 589  :                  ||  ( *inspect == '-'  &&  inspect != token.start_ );

	movzx	eax, BYTE PTR _isDouble$[ebp]
	test	eax, eax
	jne	SHORT $LN17@decodeNumb
	push	43					; 0000002bH
	push	69					; 00000045H
	push	101					; 00000065H
	push	46					; 0000002eH
	mov	ecx, DWORD PTR _inspect$10[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?in@Json@@YA_NDDDDD@Z			; Json::in
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@decodeNumb
	mov	ecx, DWORD PTR _inspect$10[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN18@decodeNumb
	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _inspect$10[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN17@decodeNumb
$LN18@decodeNumb:
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN19@decodeNumb
$LN17@decodeNumb:
	mov	DWORD PTR tv82[ebp], 1
$LN19@decodeNumb:
	mov	dl, BYTE PTR tv82[ebp]
	mov	BYTE PTR _isDouble$[ebp], dl

; 590  :    }

	jmp	SHORT $LN13@decodeNumb
$LN12@decodeNumb:

; 591  :    if ( isDouble )

	movzx	eax, BYTE PTR _isDouble$[ebp]
	test	eax, eax
	je	SHORT $LN11@decodeNumb

; 592  :       return decodeDouble( token );

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeDouble
	jmp	$LN15@decodeNumb
$LN11@decodeNumb:

; 593  :    Location current = token.start_;

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _current$[ebp], ecx

; 594  :    bool isNegative = *current == '-';

	mov	eax, DWORD PTR _current$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN20@decodeNumb
	mov	DWORD PTR tv92[ebp], 1
	jmp	SHORT $LN21@decodeNumb
$LN20@decodeNumb:
	mov	DWORD PTR tv92[ebp], 0
$LN21@decodeNumb:
	mov	dl, BYTE PTR tv92[ebp]
	mov	BYTE PTR _isNegative$[ebp], dl

; 595  :    if ( isNegative )

	movzx	eax, BYTE PTR _isNegative$[ebp]
	test	eax, eax
	je	SHORT $LN10@decodeNumb

; 596  :       ++current;

	mov	eax, DWORD PTR _current$[ebp]
	add	eax, 1
	mov	DWORD PTR _current$[ebp], eax
$LN10@decodeNumb:

; 597  :    Value::UInt threshold = (isNegative ? Value::UInt(-Value::minInt) 
; 598  :                                        : Value::maxUInt) / 10;

	movzx	eax, BYTE PTR _isNegative$[ebp]
	test	eax, eax
	je	SHORT $LN22@decodeNumb
	mov	ecx, DWORD PTR ?minInt@Value@Json@@2HB	; Json::Value::minInt
	neg	ecx
	mov	DWORD PTR tv132[ebp], ecx
	jmp	SHORT $LN23@decodeNumb
$LN22@decodeNumb:
	mov	edx, DWORD PTR ?maxUInt@Value@Json@@2IB	; Json::Value::maxUInt
	mov	DWORD PTR tv132[ebp], edx
$LN23@decodeNumb:
	mov	eax, DWORD PTR tv132[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	DWORD PTR _threshold$[ebp], eax

; 599  :    Value::UInt value = 0;

	mov	DWORD PTR _value$[ebp], 0
$LN9@decodeNumb:

; 600  :    while ( current < token.end_ )

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	$LN8@decodeNumb

; 601  :    {
; 602  :       Char c = *current++;

	mov	eax, DWORD PTR _current$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$9[ebp], cl
	mov	edx, DWORD PTR _current$[ebp]
	add	edx, 1
	mov	DWORD PTR _current$[ebp], edx

; 603  :       if ( c < '0'  ||  c > '9' )

	movsx	eax, BYTE PTR _c$9[ebp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN6@decodeNumb
	movsx	eax, BYTE PTR _c$9[ebp]
	cmp	eax, 57					; 00000039H
	jle	$LN7@decodeNumb
$LN6@decodeNumb:

; 604  :          return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	push	0
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv211[ebp], eax
	mov	edx, DWORD PTR tv211[ebp]
	mov	DWORD PTR tv203[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv203[ebp]
	push	eax
	push	OFFSET ??_C@_01GEODFPGF@?8?$AA@
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv212[ebp], eax
	mov	edx, DWORD PTR tv212[ebp]
	mov	DWORD PTR tv205[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv205[ebp]
	push	eax
	lea	ecx, DWORD PTR $T8[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv213[ebp], eax
	mov	edx, DWORD PTR tv213[ebp]
	mov	DWORD PTR tv207[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv207[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T2[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T2[ebp]
	jmp	$LN15@decodeNumb
$LN7@decodeNumb:

; 605  :       if ( value >= threshold )

	mov	eax, DWORD PTR _value$[ebp]
	cmp	eax, DWORD PTR _threshold$[ebp]
	jb	SHORT $LN5@decodeNumb

; 606  :          return decodeDouble( token );

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeDouble
	jmp	$LN15@decodeNumb
$LN5@decodeNumb:

; 607  :       value = value * 10 + Value::UInt(c - '0');

	imul	eax, DWORD PTR _value$[ebp], 10
	movsx	ecx, BYTE PTR _c$9[ebp]
	lea	edx, DWORD PTR [eax+ecx-48]
	mov	DWORD PTR _value$[ebp], edx

; 608  :    }

	jmp	$LN9@decodeNumb
$LN8@decodeNumb:

; 609  :    if ( isNegative )

	movzx	eax, BYTE PTR _isNegative$[ebp]
	test	eax, eax
	je	SHORT $LN4@decodeNumb

; 610  :       currentValue() = -Value::Int( value );

	mov	eax, DWORD PTR _value$[ebp]
	neg	eax
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0Value@Json@@QAE@H@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	jmp	$LN3@decodeNumb
$LN4@decodeNumb:

; 611  :    else if ( value <= Value::UInt(Value::maxInt) )

	mov	eax, DWORD PTR _value$[ebp]
	cmp	eax, DWORD PTR ?maxInt@Value@Json@@2HB	; Json::Value::maxInt
	ja	SHORT $LN2@decodeNumb

; 612  :       currentValue() = Value::Int( value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0Value@Json@@QAE@H@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 613  :    else

	jmp	SHORT $LN3@decodeNumb
$LN2@decodeNumb:

; 614  :       currentValue() = value;

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0Value@Json@@QAE@I@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN3@decodeNumb:

; 615  :    return true;

	mov	al, 1
$LN15@decodeNumb:

; 616  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 520				; 00000208H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$5:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-524]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeNumber
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
tv160 = -388						; size = 4
tv162 = -384						; size = 4
tv143 = -384						; size = 4
tv86 = -384						; size = 4
$T2 = -376						; size = 16
$T3 = -349						; size = 1
$T4 = -340						; size = 28
_badTokenType$5 = -109					; size = 1
_token$6 = -100						; size = 12
_ok$7 = -77						; size = 1
_value$8 = -68						; size = 4
_index$ = -56						; size = 4
_endArray$9 = -44					; size = 12
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tokenStart$ = 8					; size = 4
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readArray, COMDAT
; _this$ = ecx

; 540  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 376				; 00000178H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 94					; 0000005eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 541  :    currentValue() = Value( arrayValue );

	push	6
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv162[ebp], eax
	mov	eax, DWORD PTR tv162[ebp]
	mov	DWORD PTR tv160[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv160[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 542  :    skipSpaces();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipSpaces@Reader@Json@@AAEXXZ		; Json::Reader::skipSpaces

; 543  :    if ( *current_ == ']' ) // empty array

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 93					; 0000005dH
	jne	SHORT $LN9@readArray

; 544  :    {
; 545  :       Token endArray;
; 546  :       readToken( endArray );

	lea	eax, DWORD PTR _endArray$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 547  :       return true;

	mov	al, 1
	jmp	$LN10@readArray
$LN9@readArray:

; 548  :    }
; 549  :    int index = 0;

	mov	DWORD PTR _index$[ebp], 0
$LN8@readArray:

; 550  :    while ( true )

	mov	eax, 1
	test	eax, eax
	je	$LN7@readArray

; 551  :    {
; 552  :       Value &value = currentValue()[ index++ ];

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR tv86[ebp], eax
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$[ebp], ecx
	mov	edx, DWORD PTR tv86[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]
	mov	DWORD PTR _value$8[ebp], eax

; 553  :       nodes_.push( &value );

	lea	eax, DWORD PTR _value$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push

; 554  :       bool ok = readValue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
	mov	BYTE PTR _ok$7[ebp], al

; 555  :       nodes_.pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop

; 556  :       if ( !ok ) // error already set

	movzx	eax, BYTE PTR _ok$7[ebp]
	test	eax, eax
	jne	SHORT $LN6@readArray

; 557  :          return recoverFromError( tokenArrayEnd );

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	jmp	$LN10@readArray
$LN6@readArray:

; 558  : 
; 559  :       Token token;
; 560  :       // Accept Comment after last item in the array.
; 561  :       ok = readToken( token );

	lea	eax, DWORD PTR _token$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	BYTE PTR _ok$7[ebp], al
$LN5@readArray:

; 562  :       while ( token.type_ == tokenComment  &&  ok )

	cmp	DWORD PTR _token$6[ebp], 12		; 0000000cH
	jne	SHORT $LN4@readArray
	movzx	eax, BYTE PTR _ok$7[ebp]
	test	eax, eax
	je	SHORT $LN4@readArray

; 563  :       {
; 564  :          ok = readToken( token );

	lea	eax, DWORD PTR _token$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	BYTE PTR _ok$7[ebp], al

; 565  :       }

	jmp	SHORT $LN5@readArray
$LN4@readArray:

; 566  :       bool badTokenType = ( token.type_ == tokenArraySeparator  &&  
; 567  :                             token.type_ == tokenArrayEnd );

	cmp	DWORD PTR _token$6[ebp], 10		; 0000000aH
	jne	SHORT $LN12@readArray
	cmp	DWORD PTR _token$6[ebp], 4
	jne	SHORT $LN12@readArray
	mov	DWORD PTR tv143[ebp], 1
	jmp	SHORT $LN13@readArray
$LN12@readArray:
	mov	DWORD PTR tv143[ebp], 0
$LN13@readArray:
	mov	al, BYTE PTR tv143[ebp]
	mov	BYTE PTR _badTokenType$5[ebp], al

; 568  :       if ( !ok  ||  badTokenType )

	movzx	eax, BYTE PTR _ok$7[ebp]
	test	eax, eax
	je	SHORT $LN2@readArray
	movzx	eax, BYTE PTR _badTokenType$5[ebp]
	test	eax, eax
	je	SHORT $LN3@readArray
$LN2@readArray:

; 569  :       {
; 570  :          return addErrorAndRecover( "Missing ',' or ']' in array declaration", 
; 571  :                                     token, 
; 572  :                                     tokenArrayEnd );

	push	OFFSET ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	4
	lea	eax, DWORD PTR _token$6[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
	mov	BYTE PTR $T3[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T3[ebp]
	jmp	SHORT $LN10@readArray
$LN3@readArray:

; 573  :       }
; 574  :       if ( token.type_ == tokenArrayEnd )

	cmp	DWORD PTR _token$6[ebp], 4
	jne	SHORT $LN1@readArray

; 575  :          break;

	jmp	SHORT $LN7@readArray
$LN1@readArray:

; 576  :    }

	jmp	$LN8@readArray
$LN7@readArray:

; 577  :    return true;

	mov	al, 1
$LN10@readArray:

; 578  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@readArray
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN21@readArray:
	DD	3
	DD	$LN20@readArray
$LN20@readArray:
	DD	-44					; ffffffd4H
	DD	12					; 0000000cH
	DD	$LN16@readArray
	DD	-68					; ffffffbcH
	DD	4
	DD	$LN17@readArray
	DD	-100					; ffffff9cH
	DD	12					; 0000000cH
	DD	$LN18@readArray
$LN18@readArray:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN17@readArray:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN16@readArray:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-392]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readArray
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
tv205 = -588						; size = 4
tv65 = -584						; size = 4
$T2 = -576						; size = 16
$T3 = -549						; size = 1
$T4 = -537						; size = 1
$T5 = -525						; size = 1
$T6 = -513						; size = 1
$T7 = -501						; size = 1
$T8 = -489						; size = 1
$T9 = -477						; size = 1
$T10 = -468						; size = 28
$T11 = -432						; size = 28
$T12 = -396						; size = 28
_finalizeTokenOk$13 = -165				; size = 1
_comma$14 = -156					; size = 12
_ok$15 = -133						; size = 1
_value$16 = -124					; size = 4
_colon$17 = -112					; size = 12
_initialTokenOk$18 = -89				; size = 1
_name$ = -80						; size = 28
_tokenName$ = -44					; size = 12
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tokenStart$ = 8					; size = 4
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readObject, COMDAT
; _this$ = ecx

; 481  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 576				; 00000240H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-588]
	mov	ecx, 144				; 00000090H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 482  :    Token tokenName;
; 483  :    std::string name;

	lea	ecx, DWORD PTR _name$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 484  :    currentValue() = Value( objectValue );

	push	7
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv205[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv205[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN16@readObject:

; 485  :    while ( readToken( tokenName ) )

	lea	eax, DWORD PTR _tokenName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	movzx	ecx, al
	test	ecx, ecx
	je	$LN15@readObject

; 486  :    {
; 487  :       bool initialTokenOk = true;

	mov	BYTE PTR _initialTokenOk$18[ebp], 1
$LN14@readObject:

; 488  :       while ( tokenName.type_ == tokenComment  &&  initialTokenOk )

	cmp	DWORD PTR _tokenName$[ebp], 12		; 0000000cH
	jne	SHORT $LN13@readObject
	movzx	eax, BYTE PTR _initialTokenOk$18[ebp]
	test	eax, eax
	je	SHORT $LN13@readObject

; 489  :          initialTokenOk = readToken( tokenName );

	lea	eax, DWORD PTR _tokenName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	BYTE PTR _initialTokenOk$18[ebp], al
	jmp	SHORT $LN14@readObject
$LN13@readObject:

; 490  :       if  ( !initialTokenOk )

	movzx	eax, BYTE PTR _initialTokenOk$18[ebp]
	test	eax, eax
	jne	SHORT $LN12@readObject

; 491  :          break;

	jmp	$LN15@readObject
$LN12@readObject:

; 492  :       if ( tokenName.type_ == tokenObjectEnd  &&  name.empty() )  // empty object

	cmp	DWORD PTR _tokenName$[ebp], 2
	jne	SHORT $LN11@readObject
	lea	ecx, DWORD PTR _name$[ebp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@readObject

; 493  :          return true;

	mov	BYTE PTR $T3[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T3[ebp]
	jmp	$LN17@readObject
$LN11@readObject:

; 494  :       if ( tokenName.type_ != tokenString )

	cmp	DWORD PTR _tokenName$[ebp], 5
	je	SHORT $LN10@readObject

; 495  :          break;

	jmp	$LN15@readObject
$LN10@readObject:

; 496  :       
; 497  :       name = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _name$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 498  :       if ( !decodeString( tokenName, name ) )

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tokenName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN9@readObject

; 499  :          return recoverFromError( tokenObjectEnd );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	BYTE PTR $T4[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T4[ebp]
	jmp	$LN17@readObject
$LN9@readObject:

; 500  : 
; 501  :       Token colon;
; 502  :       if ( !readToken( colon ) ||  colon.type_ != tokenMemberSeparator )

	lea	eax, DWORD PTR _colon$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@readObject
	cmp	DWORD PTR _colon$17[ebp], 11		; 0000000bH
	je	SHORT $LN8@readObject
$LN7@readObject:

; 503  :       {
; 504  :          return addErrorAndRecover( "Missing ':' after object member name", 
; 505  :                                     colon, 
; 506  :                                     tokenObjectEnd );

	push	OFFSET ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
	lea	ecx, DWORD PTR $T10[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	2
	lea	eax, DWORD PTR _colon$17[ebp]
	push	eax
	lea	ecx, DWORD PTR $T10[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
	mov	BYTE PTR $T5[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T10[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T5[ebp]
	jmp	$LN17@readObject
$LN8@readObject:

; 507  :       }
; 508  :       Value &value = currentValue()[ name ];

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	DWORD PTR _value$16[ebp], eax

; 509  :       nodes_.push( &value );

	lea	eax, DWORD PTR _value$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push

; 510  :       bool ok = readValue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
	mov	BYTE PTR _ok$15[ebp], al

; 511  :       nodes_.pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop

; 512  :       if ( !ok ) // error already set

	movzx	eax, BYTE PTR _ok$15[ebp]
	test	eax, eax
	jne	SHORT $LN6@readObject

; 513  :          return recoverFromError( tokenObjectEnd );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	BYTE PTR $T6[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T6[ebp]
	jmp	$LN17@readObject
$LN6@readObject:

; 514  : 
; 515  :       Token comma;
; 516  :       if ( !readToken( comma )
; 517  :             ||  ( comma.type_ != tokenObjectEnd  &&  
; 518  :                   comma.type_ != tokenArraySeparator &&
; 519  : 		  comma.type_ != tokenComment ) )

	lea	eax, DWORD PTR _comma$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@readObject
	cmp	DWORD PTR _comma$14[ebp], 2
	je	SHORT $LN5@readObject
	cmp	DWORD PTR _comma$14[ebp], 10		; 0000000aH
	je	SHORT $LN5@readObject
	cmp	DWORD PTR _comma$14[ebp], 12		; 0000000cH
	je	SHORT $LN5@readObject
$LN4@readObject:

; 520  :       {
; 521  :          return addErrorAndRecover( "Missing ',' or '}' in object declaration", 
; 522  :                                     comma, 
; 523  :                                     tokenObjectEnd );

	push	OFFSET ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
	lea	ecx, DWORD PTR $T11[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	2
	lea	eax, DWORD PTR _comma$14[ebp]
	push	eax
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
	mov	BYTE PTR $T7[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T7[ebp]
	jmp	$LN17@readObject
$LN5@readObject:

; 524  :       }
; 525  :       bool finalizeTokenOk = true;

	mov	BYTE PTR _finalizeTokenOk$13[ebp], 1
$LN3@readObject:

; 526  :       while ( comma.type_ == tokenComment &&
; 527  :               finalizeTokenOk )

	cmp	DWORD PTR _comma$14[ebp], 12		; 0000000cH
	jne	SHORT $LN2@readObject
	movzx	eax, BYTE PTR _finalizeTokenOk$13[ebp]
	test	eax, eax
	je	SHORT $LN2@readObject

; 528  :          finalizeTokenOk = readToken( comma );

	lea	eax, DWORD PTR _comma$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	BYTE PTR _finalizeTokenOk$13[ebp], al
	jmp	SHORT $LN3@readObject
$LN2@readObject:

; 529  :       if ( comma.type_ == tokenObjectEnd )

	cmp	DWORD PTR _comma$14[ebp], 2
	jne	SHORT $LN1@readObject

; 530  :          return true;

	mov	BYTE PTR $T8[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T8[ebp]
	jmp	SHORT $LN17@readObject
$LN1@readObject:

; 531  :    }

	jmp	$LN16@readObject
$LN15@readObject:

; 532  :    return addErrorAndRecover( "Missing '}' or object member name", 
; 533  :                               tokenName, 
; 534  :                               tokenObjectEnd );

	push	OFFSET ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
	lea	ecx, DWORD PTR $T12[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	2
	lea	eax, DWORD PTR _tokenName$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T12[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
	mov	BYTE PTR $T9[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T12[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T9[ebp]
$LN17@readObject:

; 535  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN31@readObject
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 588				; 0000024cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN31@readObject:
	DD	5
	DD	$LN30@readObject
$LN30@readObject:
	DD	-44					; ffffffd4H
	DD	12					; 0000000cH
	DD	$LN24@readObject
	DD	-80					; ffffffb0H
	DD	28					; 0000001cH
	DD	$LN25@readObject
	DD	-112					; ffffff90H
	DD	12					; 0000000cH
	DD	$LN26@readObject
	DD	-124					; ffffff84H
	DD	4
	DD	$LN27@readObject
	DD	-156					; ffffff64H
	DD	12					; 0000000cH
	DD	$LN28@readObject
$LN28@readObject:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	0
$LN27@readObject:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN26@readObject:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN25@readObject:
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN24@readObject:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR _name$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-592]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readObject
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?readValue@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
tv175 = -380						; size = 4
tv141 = -376						; size = 4
tv82 = -376						; size = 4
$T2 = -368						; size = 16
$T3 = -344						; size = 16
$T4 = -320						; size = 16
$T5 = -293						; size = 1
$T6 = -284						; size = 28
_successful$ = -53					; size = 1
_token$ = -44						; size = 12
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?readValue@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readValue, COMDAT
; _this$ = ecx

; 196  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readValue@Reader@Json@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-380]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 197  :    Token token;
; 198  :    skipCommentTokens( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens

; 199  :    bool successful = true;

	mov	BYTE PTR _successful$[ebp], 1

; 200  : 
; 201  :    if ( collectComments_  &&  !commentsBefore_.empty() )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+118]
	test	ecx, ecx
	je	SHORT $LN12@readValue
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@readValue

; 202  :    {
; 203  :       currentValue().setComment( commentsBefore_, commentBefore );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment

; 204  :       commentsBefore_ = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
$LN12@readValue:

; 205  :    }
; 206  : 
; 207  : 
; 208  :    switch ( token.type_ )

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR tv82[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv82[ebp], ecx
	cmp	DWORD PTR tv82[ebp], 8
	ja	$LN2@readValue
	mov	edx, DWORD PTR tv82[ebp]
	jmp	DWORD PTR $LN23@readValue[edx*4]
$LN9@readValue:

; 209  :    {
; 210  :    case tokenObjectBegin:
; 211  :       successful = readObject( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readObject
	mov	BYTE PTR _successful$[ebp], al

; 212  :       break;

	jmp	$LN10@readValue
$LN8@readValue:

; 213  :    case tokenArrayBegin:
; 214  :       successful = readArray( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readArray
	mov	BYTE PTR _successful$[ebp], al

; 215  :       break;

	jmp	$LN10@readValue
$LN7@readValue:

; 216  :    case tokenNumber:
; 217  :       successful = decodeNumber( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeNumber
	mov	BYTE PTR _successful$[ebp], al

; 218  :       break;

	jmp	$LN10@readValue
$LN6@readValue:

; 219  :    case tokenString:
; 220  :       successful = decodeString( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeString
	mov	BYTE PTR _successful$[ebp], al

; 221  :       break;

	jmp	$LN10@readValue
$LN5@readValue:

; 222  :    case tokenTrue:
; 223  :       currentValue() = true;

	push	1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Value@Json@@QAE@_N@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 224  :       break;

	jmp	$LN10@readValue
$LN4@readValue:

; 225  :    case tokenFalse:
; 226  :       currentValue() = false;

	push	0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0Value@Json@@QAE@_N@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 227  :       break;

	jmp	$LN10@readValue
$LN3@readValue:

; 228  :    case tokenNull:
; 229  :       currentValue() = Value();

	push	0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv141[ebp], eax
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR tv175[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv175[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 230  :       break;

	jmp	SHORT $LN10@readValue
$LN2@readValue:

; 231  :    default:
; 232  :       return addError( "Syntax error: value, object or array expected.", token );

	push	OFFSET ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	push	0
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T5[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T5[ebp]
	jmp	SHORT $LN13@readValue
$LN10@readValue:

; 233  :    }
; 234  : 
; 235  :    if ( collectComments_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+118]
	test	ecx, ecx
	je	SHORT $LN1@readValue

; 236  :    {
; 237  :       lastValueEnd_ = current_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+80], edx

; 238  :       lastValue_ = &currentValue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], eax
$LN1@readValue:

; 239  :    }
; 240  : 
; 241  :    return successful;

	mov	al, BYTE PTR _successful$[ebp]
$LN13@readValue:

; 242  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@readValue
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 380				; 0000017cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@readValue:
	DD	1
	DD	$LN21@readValue
$LN21@readValue:
	DD	-44					; ffffffd4H
	DD	12					; 0000000cH
	DD	$LN19@readValue
$LN19@readValue:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
	npad	2
$LN23@readValue:
	DD	$LN9@readValue
	DD	$LN2@readValue
	DD	$LN8@readValue
	DD	$LN2@readValue
	DD	$LN6@readValue
	DD	$LN7@readValue
	DD	$LN5@readValue
	DD	$LN4@readValue
	DD	$LN3@readValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$3:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readValue@Reader@Json@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-384]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readValue@Reader@Json@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?readValue@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readValue
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?readNumber@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?readNumber@Reader@Json@@AAEXXZ PROC			; Json::Reader::readNumber, COMDAT
; _this$ = ecx

; 453  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@readNumber:

; 454  :    while ( current_ != end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+76]
	cmp	edx, DWORD PTR [ecx+72]
	je	SHORT $LN5@readNumber

; 455  :    {
; 456  :       if ( !(*current_ >= '0'  &&  *current_ <= '9')  &&
; 457  :            !in( *current_, '.', 'e', 'E', '+', '-' ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN1@readNumber
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN2@readNumber
$LN1@readNumber:
	push	45					; 0000002dH
	push	43					; 0000002bH
	push	69					; 00000045H
	push	101					; 00000065H
	push	46					; 0000002eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?in@Json@@YA_NDDDDDD@Z			; Json::in
	add	esp, 24					; 00000018H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@readNumber

; 458  :          break;

	jmp	SHORT $LN5@readNumber
$LN2@readNumber:

; 459  :       ++current_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 460  :    }

	jmp	SHORT $LN4@readNumber
$LN5@readNumber:

; 461  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?readNumber@Reader@Json@@AAEXXZ ENDP			; Json::Reader::readNumber
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?readString@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
tv76 = -220						; size = 4
_c$ = -17						; size = 1
_this$ = -8						; size = 4
?readString@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readString, COMDAT
; _this$ = ecx

; 465  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 466  :    Char c = 0;

	mov	BYTE PTR _c$[ebp], 0
$LN5@readString:

; 467  :    while ( current_ != end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+76]
	cmp	edx, DWORD PTR [ecx+72]
	je	SHORT $LN4@readString

; 468  :    {
; 469  :       c = getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	mov	BYTE PTR _c$[ebp], al

; 470  :       if ( c == '\\' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN3@readString

; 471  :          getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	jmp	SHORT $LN2@readString
$LN3@readString:

; 472  :       else if ( c == '"' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN2@readString

; 473  :          break;

	jmp	SHORT $LN4@readString
$LN2@readString:

; 474  :    }

	jmp	SHORT $LN5@readString
$LN4@readString:

; 475  :    return c == '"';

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN8@readString
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN9@readString
$LN8@readString:
	mov	DWORD PTR tv76[ebp], 0
$LN9@readString:
	mov	al, BYTE PTR tv76[ebp]

; 476  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?readString@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?readCppStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
_c$1 = -17						; size = 1
_this$ = -8						; size = 4
?readCppStyleComment@Reader@Json@@AAE_NXZ PROC		; Json::Reader::readCppStyleComment, COMDAT
; _this$ = ecx

; 440  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@readCppSty:

; 441  :    while ( current_ != end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+76]
	cmp	edx, DWORD PTR [ecx+72]
	je	SHORT $LN3@readCppSty

; 442  :    {
; 443  :       Char c = getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	mov	BYTE PTR _c$1[ebp], al

; 444  :       if (  c == '\r'  ||  c == '\n' )

	movsx	eax, BYTE PTR _c$1[ebp]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN1@readCppSty
	movsx	eax, BYTE PTR _c$1[ebp]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN2@readCppSty
$LN1@readCppSty:

; 445  :          break;

	jmp	SHORT $LN3@readCppSty
$LN2@readCppSty:

; 446  :    }

	jmp	SHORT $LN4@readCppSty
$LN3@readCppSty:

; 447  :    return true;

	mov	al, 1

; 448  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?readCppStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCppStyleComment
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?readCStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
tv79 = -220						; size = 4
_c$1 = -17						; size = 1
_this$ = -8						; size = 4
?readCStyleComment@Reader@Json@@AAE_NXZ PROC		; Json::Reader::readCStyleComment, COMDAT
; _this$ = ecx

; 427  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN3@readCStyle:

; 428  :    while ( current_ != end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+76]
	cmp	edx, DWORD PTR [ecx+72]
	je	SHORT $LN2@readCStyle

; 429  :    {
; 430  :       Char c = getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	mov	BYTE PTR _c$1[ebp], al

; 431  :       if ( c == '*'  &&  *current_ == '/' )

	movsx	eax, BYTE PTR _c$1[ebp]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN1@readCStyle
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN1@readCStyle

; 432  :          break;

	jmp	SHORT $LN2@readCStyle
$LN1@readCStyle:

; 433  :    }

	jmp	SHORT $LN3@readCStyle
$LN2@readCStyle:

; 434  :    return getNextChar() == '/';

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	movsx	eax, al
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN6@readCStyle
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN7@readCStyle
$LN6@readCStyle:
	mov	DWORD PTR tv79[ebp], 0
$LN7@readCStyle:
	mov	al, BYTE PTR tv79[ebp]

; 435  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?readCStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCStyleComment
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?readComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
_placement$1 = -56					; size = 4
_successful$ = -41					; size = 1
_c$ = -29						; size = 1
_commentBegin$ = -20					; size = 4
_this$ = -8						; size = 4
?readComment@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readComment, COMDAT
; _this$ = ecx

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :    Location commentBegin = current_ - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	sub	ecx, 1
	mov	DWORD PTR _commentBegin$[ebp], ecx

; 381  :    Char c = getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	mov	BYTE PTR _c$[ebp], al

; 382  :    bool successful = false;

	mov	BYTE PTR _successful$[ebp], 0

; 383  :    if ( c == '*' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN8@readCommen

; 384  :       successful = readCStyleComment();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readCStyleComment@Reader@Json@@AAE_NXZ	; Json::Reader::readCStyleComment
	mov	BYTE PTR _successful$[ebp], al
	jmp	SHORT $LN7@readCommen
$LN8@readCommen:

; 385  :    else if ( c == '/' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN7@readCommen

; 386  :       successful = readCppStyleComment();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readCppStyleComment@Reader@Json@@AAE_NXZ ; Json::Reader::readCppStyleComment
	mov	BYTE PTR _successful$[ebp], al
$LN7@readCommen:

; 387  :    if ( !successful )

	movzx	eax, BYTE PTR _successful$[ebp]
	test	eax, eax
	jne	SHORT $LN5@readCommen

; 388  :       return false;

	xor	al, al
	jmp	SHORT $LN9@readCommen
$LN5@readCommen:

; 389  : 
; 390  :    if ( collectComments_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+118]
	test	ecx, ecx
	je	SHORT $LN4@readCommen

; 391  :    {
; 392  :       CommentPlacement placement = commentBefore;

	mov	DWORD PTR _placement$1[ebp], 0

; 393  :       if ( lastValueEnd_  &&  !containsNewLine( lastValueEnd_, commentBegin ) )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN3@readCommen
	mov	eax, DWORD PTR _commentBegin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	?containsNewLine@Json@@YA_NPBD0@Z	; Json::containsNewLine
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@readCommen

; 394  :       {
; 395  :          if ( c != '*'  ||  !containsNewLine( commentBegin, current_ ) )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN1@readCommen
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	mov	edx, DWORD PTR _commentBegin$[ebp]
	push	edx
	call	?containsNewLine@Json@@YA_NPBD0@Z	; Json::containsNewLine
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@readCommen
$LN1@readCommen:

; 396  :             placement = commentAfterOnSameLine;

	mov	DWORD PTR _placement$1[ebp], 1
$LN3@readCommen:

; 397  :       }
; 398  : 
; 399  :       addComment( commentBegin, current_, placement );

	mov	eax, DWORD PTR _placement$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	mov	eax, DWORD PTR _commentBegin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
$LN4@readCommen:

; 400  :    }
; 401  :    return true;

	mov	al, 1
$LN9@readCommen:

; 402  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?readComment@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readComment
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?match@Reader@Json@@AAE_NPBDH@Z
_TEXT	SEGMENT
tv69 = -220						; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_pattern$ = 8						; size = 4
_patternLength$ = 12					; size = 4
?match@Reader@Json@@AAE_NPBDH@Z PROC			; Json::Reader::match, COMDAT
; _this$ = ecx

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 366  :    if ( end_ - current_ < patternLength )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+72]
	sub	edx, DWORD PTR [ecx+76]
	cmp	edx, DWORD PTR _patternLength$[ebp]
	jge	SHORT $LN4@match

; 367  :       return false;

	xor	al, al
	jmp	SHORT $LN5@match
$LN4@match:

; 368  :    int index = patternLength;

	mov	eax, DWORD PTR _patternLength$[ebp]
	mov	DWORD PTR _index$[ebp], eax
$LN3@match:

; 369  :    while ( index-- )

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	mov	ecx, DWORD PTR _index$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _index$[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN2@match

; 370  :       if ( current_[index] != pattern[index] )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _index$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	mov	ecx, DWORD PTR _pattern$[ebp]
	add	ecx, DWORD PTR _index$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	je	SHORT $LN1@match

; 371  :          return false;

	xor	al, al
	jmp	SHORT $LN5@match
$LN1@match:

; 372  :    current_ += patternLength;

	jmp	SHORT $LN3@match
$LN2@match:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	add	ecx, DWORD PTR _patternLength$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 373  :    return true;

	mov	al, 1
$LN5@match:

; 374  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?match@Reader@Json@@AAE_NPBDH@Z ENDP			; Json::Reader::match
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?skipSpaces@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
_c$1 = -17						; size = 1
_this$ = -8						; size = 4
?skipSpaces@Reader@Json@@AAEXXZ PROC			; Json::Reader::skipSpaces, COMDAT
; _this$ = ecx

; 350  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN5@skipSpaces:

; 351  :    while ( current_ != end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+76]
	cmp	edx, DWORD PTR [ecx+72]
	je	SHORT $LN6@skipSpaces

; 352  :    {
; 353  :       Char c = *current_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$1[ebp], dl

; 354  :       if ( c == ' '  ||  c == '\t'  ||  c == '\r'  ||  c == '\n' )

	movsx	eax, BYTE PTR _c$1[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN2@skipSpaces
	movsx	eax, BYTE PTR _c$1[ebp]
	cmp	eax, 9
	je	SHORT $LN2@skipSpaces
	movsx	eax, BYTE PTR _c$1[ebp]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN2@skipSpaces
	movsx	eax, BYTE PTR _c$1[ebp]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN3@skipSpaces
$LN2@skipSpaces:

; 355  :          ++current_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 356  :       else

	jmp	SHORT $LN1@skipSpaces
$LN3@skipSpaces:

; 357  :          break;

	jmp	SHORT $LN6@skipSpaces
$LN1@skipSpaces:

; 358  :    }

	jmp	SHORT $LN5@skipSpaces
$LN6@skipSpaces:

; 359  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?skipSpaces@Reader@Json@@AAEXXZ ENDP			; Json::Reader::skipSpaces
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
tv70 = -232						; size = 4
_ok$ = -29						; size = 1
_c$ = -17						; size = 1
_this$ = -8						; size = 4
_token$ = 8						; size = 4
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readToken, COMDAT
; _this$ = ecx

; 275  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 276  :    skipSpaces();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipSpaces@Reader@Json@@AAEXXZ		; Json::Reader::skipSpaces

; 277  :    token.start_ = current_;

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+4], edx

; 278  :    Char c = getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	mov	BYTE PTR _c$[ebp], al

; 279  :    bool ok = true;

	mov	BYTE PTR _ok$[ebp], 1

; 280  :    switch ( c )

	movsx	eax, BYTE PTR _c$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	cmp	DWORD PTR tv70[ebp], 125		; 0000007dH
	ja	$LN2@readToken
	mov	ecx, DWORD PTR tv70[ebp]
	movzx	edx, BYTE PTR $LN20@readToken[ecx]
	jmp	DWORD PTR $LN21@readToken[edx*4]
$LN15@readToken:

; 281  :    {
; 282  :    case '{':
; 283  :       token.type_ = tokenObjectBegin;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 1

; 284  :       break;

	jmp	$LN16@readToken
$LN14@readToken:

; 285  :    case '}':
; 286  :       token.type_ = tokenObjectEnd;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 2

; 287  :       break;

	jmp	$LN16@readToken
$LN13@readToken:

; 288  :    case '[':
; 289  :       token.type_ = tokenArrayBegin;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 3

; 290  :       break;

	jmp	$LN16@readToken
$LN12@readToken:

; 291  :    case ']':
; 292  :       token.type_ = tokenArrayEnd;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 4

; 293  :       break;

	jmp	$LN16@readToken
$LN11@readToken:

; 294  :    case '"':
; 295  :       token.type_ = tokenString;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 5

; 296  :       ok = readString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readString@Reader@Json@@AAE_NXZ	; Json::Reader::readString
	mov	BYTE PTR _ok$[ebp], al

; 297  :       break;

	jmp	$LN16@readToken
$LN10@readToken:

; 298  :    case '/':
; 299  :       token.type_ = tokenComment;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 12			; 0000000cH

; 300  :       ok = readComment();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readComment@Reader@Json@@AAE_NXZ	; Json::Reader::readComment
	mov	BYTE PTR _ok$[ebp], al

; 301  :       break;

	jmp	$LN16@readToken
$LN9@readToken:

; 302  :    case '0':
; 303  :    case '1':
; 304  :    case '2':
; 305  :    case '3':
; 306  :    case '4':
; 307  :    case '5':
; 308  :    case '6':
; 309  :    case '7':
; 310  :    case '8':
; 311  :    case '9':
; 312  :    case '-':
; 313  :       token.type_ = tokenNumber;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 6

; 314  :       readNumber();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readNumber@Reader@Json@@AAEXXZ		; Json::Reader::readNumber

; 315  :       break;

	jmp	SHORT $LN16@readToken
$LN8@readToken:

; 316  :    case 't':
; 317  :       token.type_ = tokenTrue;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 7

; 318  :       ok = match( "rue", 3 );

	push	3
	push	OFFSET ??_C@_03FFDNHNKN@rue?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?match@Reader@Json@@AAE_NPBDH@Z		; Json::Reader::match
	mov	BYTE PTR _ok$[ebp], al

; 319  :       break;

	jmp	SHORT $LN16@readToken
$LN7@readToken:

; 320  :    case 'f':
; 321  :       token.type_ = tokenFalse;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 8

; 322  :       ok = match( "alse", 4 );

	push	4
	push	OFFSET ??_C@_04KCECFHEP@alse?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?match@Reader@Json@@AAE_NPBDH@Z		; Json::Reader::match
	mov	BYTE PTR _ok$[ebp], al

; 323  :       break;

	jmp	SHORT $LN16@readToken
$LN6@readToken:

; 324  :    case 'n':
; 325  :       token.type_ = tokenNull;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 9

; 326  :       ok = match( "ull", 3 );

	push	3
	push	OFFSET ??_C@_03KNPGGKC@ull?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?match@Reader@Json@@AAE_NPBDH@Z		; Json::Reader::match
	mov	BYTE PTR _ok$[ebp], al

; 327  :       break;

	jmp	SHORT $LN16@readToken
$LN5@readToken:

; 328  :    case ',':
; 329  :       token.type_ = tokenArraySeparator;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 10			; 0000000aH

; 330  :       break;

	jmp	SHORT $LN16@readToken
$LN4@readToken:

; 331  :    case ':':
; 332  :       token.type_ = tokenMemberSeparator;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 11			; 0000000bH

; 333  :       break;

	jmp	SHORT $LN16@readToken
$LN3@readToken:

; 334  :    case 0:
; 335  :       token.type_ = tokenEndOfStream;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 0

; 336  :       break;

	jmp	SHORT $LN16@readToken
$LN2@readToken:

; 337  :    default:
; 338  :       ok = false;

	mov	BYTE PTR _ok$[ebp], 0
$LN16@readToken:

; 339  :       break;
; 340  :    }
; 341  :    if ( !ok )

	movzx	eax, BYTE PTR _ok$[ebp]
	test	eax, eax
	jne	SHORT $LN1@readToken

; 342  :       token.type_ = tokenError;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 13			; 0000000dH
$LN1@readToken:

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+8], edx

; 344  :    return true;

	mov	al, 1

; 345  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN21@readToken:
	DD	$LN3@readToken
	DD	$LN11@readToken
	DD	$LN5@readToken
	DD	$LN9@readToken
	DD	$LN10@readToken
	DD	$LN4@readToken
	DD	$LN13@readToken
	DD	$LN12@readToken
	DD	$LN7@readToken
	DD	$LN6@readToken
	DD	$LN8@readToken
	DD	$LN15@readToken
	DD	$LN14@readToken
	DD	$LN2@readToken
$LN20@readToken:
	DB	0
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	1
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	2
	DB	3
	DB	13					; 0000000dH
	DB	4
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	5
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	6
	DB	13					; 0000000dH
	DB	7
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	8
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	9
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	10					; 0000000aH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	11					; 0000000bH
	DB	13					; 0000000dH
	DB	12					; 0000000cH
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readToken
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
_TEXT	SEGMENT
$T2 = -261						; size = 1
$T3 = -252						; size = 28
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
_token$ = 12						; size = 4
_message$ = 16						; size = 4
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z PROC ; Json::Reader::expectToken, COMDAT
; _this$ = ecx

; 265  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 266  :    readToken( token );

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 267  :    if ( token.type_ != type )

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _type$[ebp]
	je	SHORT $LN1@expectToke

; 268  :       return addError( message, token );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T2[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T2[ebp]
	jmp	SHORT $LN2@expectToke
$LN1@expectToke:

; 269  :    return true;

	mov	al, 1
$LN2@expectToke:

; 270  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ENDP ; Json::Reader::expectToken
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GErrorInfo@Reader@Json@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z PROC		; Json::Reader::ErrorInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z ENDP		; Json::Reader::ErrorInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z PROC	; Json::Reader::ErrorInfo::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z ENDP	; Json::Reader::ErrorInfo::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z PROC		; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z ENDP		; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1ErrorInfo@Reader@Json@@QAE@XZ PROC			; Json::Reader::ErrorInfo::~ErrorInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::~ErrorInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ErrorInfo@Reader@Json@@QAE@XZ PROC			; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
tv201 = -644						; size = 4
tv191 = -644						; size = 4
tv212 = -640						; size = 4
tv207 = -640						; size = 4
tv199 = -636						; size = 4
tv195 = -636						; size = 4
tv189 = -636						; size = 4
tv211 = -632						; size = 4
tv209 = -632						; size = 4
tv179 = -632						; size = 4
tv197 = -628						; size = 4
tv193 = -628						; size = 4
tv187 = -628						; size = 4
tv185 = -628						; size = 4
tv210 = -624						; size = 4
tv208 = -624						; size = 4
tv69 = -624						; size = 4
tv65 = -624						; size = 4
$T2 = -616						; size = 28
$T3 = -580						; size = 28
$T4 = -544						; size = 28
$T5 = -508						; size = 28
$T6 = -472						; size = 28
$T7 = -436						; size = 28
$T8 = -400						; size = 28
$T9 = -364						; size = 28
$T10 = -325						; size = 1
$T11 = -316						; size = 12
$T12 = -296						; size = 4
_error$13 = -92						; size = 4
_itError$14 = -80					; size = 12
_formattedMessage$ = -60				; size = 28
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Json::Reader::getFormatedErrorMessages, COMDAT
; _this$ = ecx

; 859  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 632				; 00000278H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-644]
	mov	ecx, 158				; 0000009eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T12[ebp], 0

; 860  :    std::string formattedMessage;

	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 861  :    for ( Errors::const_iterator itError = errors_.begin();

	lea	eax, DWORD PTR _itError$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	jmp	SHORT $LN4@getFormate
$LN3@getFormate:

; 862  :          itError != errors_.end();
; 863  :          ++itError )

	lea	ecx, DWORD PTR _itError$14[ebp]
	call	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
$LN4@getFormate:
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	DWORD PTR tv69[ebp], eax
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv185[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR tv185[ebp]
	push	edx
	lea	ecx, DWORD PTR _itError$14[ebp]
	call	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
	mov	BYTE PTR $T10[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T10[ebp]
	test	eax, eax
	je	$LN2@getFormate

; 864  :    {
; 865  :       const ErrorInfo &error = *itError;

	lea	ecx, DWORD PTR _itError$14[ebp]
	call	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
	mov	DWORD PTR _error$13[ebp], eax

; 866  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, DWORD PTR _error$13[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv187[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv187[ebp]
	push	ecx
	push	OFFSET ??_C@_02KAOAMBHJ@?$CK?5?$AA@
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv179[ebp], eax
	mov	eax, DWORD PTR tv179[ebp]
	mov	DWORD PTR tv189[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR tv189[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv207[ebp], eax
	mov	eax, DWORD PTR tv207[ebp]
	mov	DWORD PTR tv191[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR tv191[ebp]
	push	ecx
	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 867  :       formattedMessage += "  " + error.message_ + "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, DWORD PTR _error$13[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv208[ebp], eax
	mov	edx, DWORD PTR tv208[ebp]
	mov	DWORD PTR tv193[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR tv193[ebp]
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv209[ebp], eax
	mov	edx, DWORD PTR tv209[ebp]
	mov	DWORD PTR tv195[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR tv195[ebp]
	push	eax
	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 868  :       if ( error.extra_ )

	mov	eax, DWORD PTR _error$13[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	$LN1@getFormate

; 869  :          formattedMessage += "See " + getLocationLineAndColumn( error.extra_ ) + " for detail.\n";

	push	OFFSET ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
	mov	eax, DWORD PTR _error$13[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
	mov	DWORD PTR tv210[ebp], eax
	mov	eax, DWORD PTR tv210[ebp]
	mov	DWORD PTR tv197[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR tv197[ebp]
	push	ecx
	push	OFFSET ??_C@_04JBAOJHKB@See?5?$AA@
	lea	edx, DWORD PTR $T8[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv211[ebp], eax
	mov	eax, DWORD PTR tv211[ebp]
	mov	DWORD PTR tv199[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR tv199[ebp]
	push	ecx
	lea	edx, DWORD PTR $T9[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv212[ebp], eax
	mov	eax, DWORD PTR tv212[ebp]
	mov	DWORD PTR tv201[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR tv201[ebp]
	push	ecx
	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@getFormate:

; 870  :    }

	jmp	$LN3@getFormate
$LN2@getFormate:
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _itError$14[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ

; 871  :    return formattedMessage;

	lea	eax, DWORD PTR _formattedMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T12[ebp]
	or	ecx, 1
	mov	DWORD PTR $T12[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 872  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@getFormate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 644				; 00000284H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN24@getFormate:
	DD	2
	DD	$LN23@getFormate
$LN23@getFormate:
	DD	-60					; ffffffc4H
	DD	28					; 0000001cH
	DD	$LN20@getFormate
	DD	-80					; ffffffb0H
	DD	12					; 0000000cH
	DD	$LN21@getFormate
$LN21@getFormate:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN20@getFormate:
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	77					; 0000004dH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1:
	lea	ecx, DWORD PTR _itError$14[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$3:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$4:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$5:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$6:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$7:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$8:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$9:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$10:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-648]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Reader::getFormatedErrorMessages
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT
$T2 = -261						; size = 1
_doc$ = -60						; size = 28
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sin$ = 8						; size = 4
_root$ = 12						; size = 4
_collectComments$ = 16					; size = 1
?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z PROC ; Json::Reader::parse, COMDAT
; _this$ = ecx

; 137  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 138  :    //std::istream_iterator<char> begin(sin);
; 139  :    //std::istream_iterator<char> end;
; 140  :    // Those would allow streamed input from a file, if parse() were a
; 141  :    // template function.
; 142  : 
; 143  :    // Since std::string is reference-counted, this at least does not
; 144  :    // create an extra copy.
; 145  :    std::string doc;

	lea	ecx, DWORD PTR _doc$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 146  :    std::getline(sin, doc, (char)EOF);

	push	-1
	lea	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sin$[ebp]
	push	ecx
	call	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH

; 147  :    return parse( doc, root, collectComments );

	movzx	eax, BYTE PTR _collectComments$[ebp]
	push	eax
	mov	ecx, DWORD PTR _root$[ebp]
	push	ecx
	lea	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
	mov	BYTE PTR $T2[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _doc$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T2[ebp]

; 148  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@parse
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN7@parse:
	DD	1
	DD	$LN6@parse
$LN6@parse:
	DD	-60					; ffffffc4H
	DD	28					; 0000001cH
	DD	$LN4@parse
$LN4@parse:
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z$0:
	lea	ecx, DWORD PTR _doc$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ENDP ; Json::Reader::parse
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
_TEXT	SEGMENT
$T2 = -284						; size = 28
_token$ = -56						; size = 12
_successful$ = -33					; size = 1
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_beginDoc$ = 8						; size = 4
_endDoc$ = 12						; size = 4
_root$ = 16						; size = 4
_collectComments$ = 20					; size = 1
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z PROC	; Json::Reader::parse, COMDAT
; _this$ = ecx

; 154  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 155  :    if ( !features_.allowComments_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+116]
	test	ecx, ecx
	jne	SHORT $LN6@parse

; 156  :    {
; 157  :       collectComments = false;

	mov	BYTE PTR _collectComments$[ebp], 0
$LN6@parse:

; 158  :    }
; 159  : 
; 160  :    begin_ = beginDoc;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _beginDoc$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 161  :    end_ = endDoc;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _endDoc$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 162  :    collectComments_ = collectComments;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _collectComments$[ebp]
	mov	BYTE PTR [eax+118], cl

; 163  :    current_ = begin_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+76], edx

; 164  :    lastValueEnd_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 165  :    lastValue_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 166  :    commentsBefore_ = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 167  :    errors_.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
$LN5@parse:

; 168  :    while ( !nodes_.empty() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@parse

; 169  :       nodes_.pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
	jmp	SHORT $LN5@parse
$LN4@parse:

; 170  :    nodes_.push( &root );

	lea	eax, DWORD PTR _root$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push

; 171  :    
; 172  :    bool successful = readValue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
	mov	BYTE PTR _successful$[ebp], al

; 173  :    Token token;
; 174  :    skipCommentTokens( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens

; 175  :    if ( collectComments_  &&  !commentsBefore_.empty() )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+118]
	test	ecx, ecx
	je	SHORT $LN3@parse
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@parse

; 176  :       root.setComment( commentsBefore_, commentAfter );

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _root$[ebp]
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
$LN3@parse:

; 177  :    if ( features_.strictRoot_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+117]
	test	ecx, ecx
	je	SHORT $LN2@parse

; 178  :    {
; 179  :       if ( !root.isArray()  &&  !root.isObject() )

	mov	ecx, DWORD PTR _root$[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@parse
	mov	ecx, DWORD PTR _root$[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@parse

; 180  :       {
; 181  :          // Set error location to start of doc, ideally should be first token found in doc
; 182  :          token.type_ = tokenError;

	mov	DWORD PTR _token$[ebp], 13		; 0000000dH

; 183  :          token.start_ = beginDoc;

	mov	eax, DWORD PTR _beginDoc$[ebp]
	mov	DWORD PTR _token$[ebp+4], eax

; 184  :          token.end_ = endDoc;

	mov	eax, DWORD PTR _endDoc$[ebp]
	mov	DWORD PTR _token$[ebp+8], eax

; 185  :          addError( "A valid JSON document must be either an array or an object value.",
; 186  :                    token );

	push	OFFSET ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 187  :          return false;

	xor	al, al
	jmp	SHORT $LN7@parse
$LN2@parse:

; 188  :       }
; 189  :    }
; 190  :    return successful;

	mov	al, BYTE PTR _successful$[ebp]
$LN7@parse:

; 191  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@parse
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN13@parse:
	DD	1
	DD	$LN12@parse
$LN12@parse:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN10@parse
$LN10@parse:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ENDP	; Json::Reader::parse
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT
_end$ = -32						; size = 4
_begin$ = -20						; size = 4
_this$ = -8						; size = 4
_document$ = 8						; size = 4
_root$ = 12						; size = 4
_collectComments$ = 16					; size = 1
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z PROC ; Json::Reader::parse, COMDAT
; _this$ = ecx

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 126  :    document_ = document;

	mov	eax, DWORD PTR _document$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 127  :    const char *begin = document_.c_str();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	DWORD PTR _begin$[ebp], eax

; 128  :    const char *end = begin + document_.length();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	add	eax, DWORD PTR _begin$[ebp]
	mov	DWORD PTR _end$[ebp], eax

; 129  :    return parse( begin, end, root, collectComments );

	movzx	eax, BYTE PTR _collectComments$[ebp]
	push	eax
	mov	ecx, DWORD PTR _root$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _begin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ; Json::Reader::parse

; 130  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ENDP ; Json::Reader::parse
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ??0Reader@Json@@QAE@ABVFeatures@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_features$ = 8						; size = 4
??0Reader@Json@@QAE@ABVFeatures@1@@Z PROC		; Json::Reader::Reader, COMDAT
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR _features$[ebp]
	mov	cx, WORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+116], cx

; 118  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0Reader@Json@@QAE@ABVFeatures@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@ABVFeatures@1@@Z ENDP		; Json::Reader::Reader
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ??0Reader@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0Reader@Json@@QAE@XZ PROC				; Json::Reader::Reader, COMDAT
; _this$ = ecx

; 111  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 116				; 00000074H
	push	eax
	call	?all@Features@Json@@SA?AV12@XZ		; Json::Features::all
	add	esp, 4

; 112  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??0Reader@Json@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
__unwindfunclet$??0Reader@Json@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0Reader@Json@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0Reader@Json@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@XZ ENDP				; Json::Reader::Reader
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_FValue@Json@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??_FValue@Json@@QAEXXZ PROC				; Json::Value::`default constructor closure', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??_FValue@Json@@QAEXXZ ENDP				; Json::Value::`default constructor closure'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4StaticString@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4StaticString@Json@@QAEAAV01@ABV01@@Z PROC		; Json::StaticString::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4StaticString@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::StaticString::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\include\json\value.h
;	COMDAT ?c_str@StaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?c_str@StaticString@Json@@QBEPBDXZ PROC			; Json::StaticString::c_str, COMDAT
; _this$ = ecx

; 76   :       {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   :          return str_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 78   :       }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@StaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::c_str
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\include\json\value.h
;	COMDAT ??BStaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??BStaticString@Json@@QBEPBDXZ PROC			; Json::StaticString::operator char const *, COMDAT
; _this$ = ecx

; 71   :       {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   :          return str_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 73   :       }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BStaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::operator char const *
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\include\json\value.h
;	COMDAT ??0StaticString@Json@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_czstring$ = 8						; size = 4
??0StaticString@Json@@QAE@PBD@Z PROC			; Json::StaticString::StaticString, COMDAT
; _this$ = ecx

; 67   :       {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _czstring$[ebp]
	mov	DWORD PTR [eax], ecx

; 68   :       }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0StaticString@Json@@QAE@PBD@Z ENDP			; Json::StaticString::StaticString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 49   : 	_Ignore()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 		{	// construct
; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 122  : 			{	// test if _Ipfx succeeded

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 			return (_Ok);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 124  : 			}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 117  : 			{	// construct locking and calling _Ipfx

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Istr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 118  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	mov	esi, esp
	movzx	eax, BYTE PTR __Noskip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4], al

; 119  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv92 = -212						; size = 4
tv86 = -208						; size = 4
tv72 = -208						; size = 4
_this$ = -8						; size = 4
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@Sentry_bas

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv86[ebp], ecx
	mov	edx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv86[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv92[ebp], eax
	mov	ecx, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR tv92[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Sentry_bas:

; 103  : 			}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv93 = -212						; size = 4
tv87 = -208						; size = 4
tv73 = -208						; size = 4
_this$ = -8						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 94   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Istr$[ebp]
	mov	DWORD PTR [eax], ecx

; 95   : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@Sentry_bas

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv87[ebp], ecx
	mov	edx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv87[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv93[ebp], eax
	mov	ecx, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Sentry_bas:

; 97   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 614  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 615  : 		if (_Syserror_map(_Errval))

	mov	esi, esp
	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	DWORD PTR __imp_?_Syserror_map@std@@YAPBDH@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@default_er

; 616  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 617  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 618  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 619  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 607  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	esi, esp
	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	DWORD PTR __imp_?_Winerror_map@std@@YAPBDH@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Name$[ebp], eax

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	eax, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 610  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 602  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 604  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 597  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 598  : 		{	// default constructor
; 599  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 584  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 585  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 586  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 587  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 588  : 			return (_Generic_error_category::message(_Errcode));

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 589  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 579  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 580  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 581  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 574  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 575  : 		{	// default constructor
; 576  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 563  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	esi, esp
	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	DWORD PTR __imp_?_Syserror_map@std@@YAPBDH@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Name$[ebp], eax

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	eax, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 566  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 558  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 559  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 560  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 553  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 554  : 		{	// default constructor
; 555  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 352  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 355  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 337  : 		{	// get category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 332  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 333  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 334  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 299  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 300  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 246  : 		{	// get category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 248  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 241  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 243  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 176  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 178  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 391  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 393  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 384  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	esi, esp
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 386  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 377  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 379  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 160  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 154  : 	error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 155  : 		{	// default constructor
; 156  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 652  : 	{	// get system_category

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 653  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 654  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 642  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 643  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 644  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z PROC		; std::_Debug_pointer<char>, COMDAT

; 545  : 	{	// test iterator for non-singularity, const pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 546  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 547  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_poin:

; 548  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ENDP		; std::_Debug_pointer<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z PROC		; std::_Debug_range<char const *>, COMDAT

; 583  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 584  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z ; std::_Iter_cat<char const *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range2@PBD@std@@YAXPBD0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<char const *>
	add	esp, 20					; 00000014H

; 585  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z ENDP		; std::_Debug_range<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1runtime_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 173  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Message$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	DWORD PTR $T1[ebp], eax
	mov	esi, esp
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@

; 174  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2294 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2295 : 		_Xout_of_range("invalid string position");

	mov	esi, esp
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xran:

; 2296 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2289 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2290 : 		_Xlength_error("string too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 2291 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Ptr$3 = -20						; size = 4
_this$ = -8						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2273 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$3[ebp], ecx

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2279 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$3[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$3[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2285 : 		_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2286 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2256 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2259 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2260 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2261 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2262 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -208						; size = 4
tv129 = -208						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2243 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2244 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	eax, BYTE PTR __Trim$[ebp]
	test	eax, eax
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2250 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2251 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2253 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2238 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -288						; size = 4
tv203 = -288						; size = 4
tv204 = -284						; size = 4
tv202 = -284						; size = 4
$T2 = -273						; size = 1
$T3 = -261						; size = 1
$T4 = -249						; size = 1
__Ptr$ = -48						; size = 4
__Newres$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2203 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2204 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $LN5@Copy

; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR __Newres$[ebp], ecx

; 2210 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2211 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	edx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2216 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax

; 2218 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2222 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2223 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2224 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2225 : 
; 2226 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2229 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2231 : 		this->_Myres = _Newres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2232 : 		_Eos(_Oldlen);

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2233 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@Copy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN23@Copy:
	DD	1
	DD	$LN22@Copy
$LN22@Copy:
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN20@Copy
$LN20@Copy:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2194 : 		if (_Count == 1)

	cmp	DWORD PTR __Count$[ebp], 1
	jne	SHORT $LN2@Chassign

; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);

	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2196 : 		else

	jmp	SHORT $LN3@Chassign
$LN2@Chassign:

; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAPADPADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH
$LN3@Chassign:

; 2198 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
tv70 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1792 : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1793 : 		return (this->_Mysize == 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv70[ebp], 0
$LN4@empty:
	mov	al, BYTE PTR tv70[ebp]

; 1794 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$1 = -20						; size = 4
_this$ = -8						; size = 4
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 1782 : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newcap$[ebp]
	ja	SHORT $LN3@reserve
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newcap$[ebp]
	je	SHORT $LN3@reserve

; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Size$1[ebp], ecx

; 1786 : 			if (_Grow(_Newcap, true))

	push	1
	mov	eax, DWORD PTR __Newcap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@reserve

; 1787 : 				_Eos(_Size);

	mov	eax, DWORD PTR __Size$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN3@reserve:

; 1788 : 			}
; 1789 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1769 : 		{	// determine new length, padding with _Ch elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1770 : 		if (_Newsize <= this->_Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	ja	SHORT $LN2@resize

; 1771 : 			_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1772 : 		else

	jmp	SHORT $LN3@resize
$LN2@resize:

; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, DWORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN3@resize:

; 1774 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1764 : 		{	// determine new length, padding with null elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1765 : 		resize(_Newsize, _Elem());

	push	0
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1766 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv75 = -232						; size = 4
$T1 = -221						; size = 1
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1758 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1759 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv75[ebp], eax
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1761 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1753 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1755 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1748 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1749 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1750 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1738 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1739 : 		return (this->_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 1740 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1682 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@operator

; 1685 : 			_DEBUG_ERROR("string subscript out of range");

	mov	esi, esp
	push	1685					; 00000695H
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator:

; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]

; 1692 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -32					; size = 4
__Ptr$2 = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1343 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1344 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1345 : 		if (this->_Mysize - _Off <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1347 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1350 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], ecx

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, DWORD PTR __Newsize$1[ebp]
	sub	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$2[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	push	edx
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1352 : 			_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1353 : 			}
; 1354 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1355 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1334 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1335 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1336 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1337 : 		_Eos(_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1338 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1339 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1264 : 		{	// insert [_Ptr, <null>) at _Off

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1265 : 		_DEBUG_POINTER(_Ptr);

	push	1265					; 000004f1H
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1267 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)

	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN5@insert

; 1241 : 			_DEBUG_POINTER(_Ptr);

	push	1241					; 000004d9H
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH
$LN5@insert:

; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert

; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	jmp	$LN7@insert
$LN4@insert:

; 1247 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN3@insert

; 1248 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN3@insert:

; 1249 : 		if (npos - this->_Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	or	ecx, -1
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN2@insert

; 1250 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@insert:

; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@insert
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@insert

; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1258 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@insert:

; 1259 : 			}
; 1260 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@insert:

; 1261 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
tv166 = -220						; size = 4
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
__Roff$ = 16						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jb	SHORT $LN6@insert
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN7@insert
$LN6@insert:

; 1212 : 			_Xran();	// _Off or _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN7@insert:

; 1213 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1214 : 		if (_Num < _Count)

	mov	eax, DWORD PTR __Num$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN5@insert

; 1215 : 			_Count = _Num;	// trim _Count to size

	mov	eax, DWORD PTR __Num$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN5@insert:

; 1216 : 		if (npos - this->_Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	or	ecx, -1
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN4@insert

; 1217 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN4@insert:

; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	$LN3@insert
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	$LN3@insert

; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1224 : 			if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN2@insert

; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN10@insert
	mov	ecx, DWORD PTR __Roff$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv166[ebp], ecx
	jmp	SHORT $LN11@insert
$LN10@insert:
	mov	edx, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR tv166[ebp], edx
$LN11@insert:
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR tv166[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1228 : 			else

	jmp	SHORT $LN1@insert
$LN2@insert:

; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@insert:

; 1231 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN3@insert:

; 1232 : 			}
; 1233 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN9@insert:

; 1234 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1167 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1168 : 		_DEBUG_POINTER(_Ptr);

	push	1168					; 00000490H
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1170 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)

	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN3@assign

; 1151 : 			_DEBUG_POINTER(_Ptr);

	push	1151					; 0000047fH
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH
$LN3@assign:

; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN4@assign
$LN2@assign:

; 1157 : 
; 1158 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1161 : 			_Eos(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1162 : 			}
; 1163 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN4@assign:

; 1164 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1130 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1131 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1132 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1133 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1134 : 			_Num = _Count;	// trim _Num to size

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
$LN4@assign:

; 1135 : 
; 1136 : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1138 : 		else if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1142 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1143 : 			}
; 1144 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1145 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		return (assign(_Right, 0, npos));

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1125 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1091 : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1092 : 		if (npos - this->_Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN2@append

; 1093 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@append:

; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@append
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@append

; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1099 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@append:

; 1100 : 			}
; 1101 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN4@append:

; 1102 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1085 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1086 : 		_DEBUG_POINTER(_Ptr);

	push	1086					; 0000043eH
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1088 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1063 : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)

	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN4@append

; 1066 : 			_DEBUG_POINTER(_Ptr);

	push	1066					; 0000042aH
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH
$LN4@append:

; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@append

; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	jmp	SHORT $LN6@append
$LN3@append:

; 1072 : 		if (npos - this->_Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN2@append

; 1073 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@append:

; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@append
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@append

; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+20]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1079 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@append:

; 1080 : 			}
; 1081 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@append:

; 1082 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1045 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN4@append

; 1046 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@append:

; 1047 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1048 : 		if (_Num < _Count)

	mov	eax, DWORD PTR __Num$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN3@append

; 1049 : 			_Count = _Num;	// trim _Count to size

	mov	eax, DWORD PTR __Num$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN3@append:

; 1050 : 		if (npos - this->_Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN2@append

; 1051 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@append:

; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@append
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@append

; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1057 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@append:

; 1058 : 			}
; 1059 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@append:

; 1060 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1038 : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1039 : 		return (append(_Right, 0, npos));

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1040 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1033 : 		{	// append 1 * _Ch

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1034 : 		return (append((size_type)1, _Ch));

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1035 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1028 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		return (append(_Ptr));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1030 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1023 : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1024 : 		return (append(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1025 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1013 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1014 : 		return (assign(_Ptr));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1015 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
$T3 = -209						; size = 1
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 997  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 998  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@operator

; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	call	??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@operator
	xor	eax, eax
	je	SHORT $LN1@operator

; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1004 : 				this->_Change_alloc(_Right._Getal());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Change_alloc
$LN1@operator:

; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@operator:

; 1008 : 			}
; 1009 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1010 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 990  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 992  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 935  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jae	SHORT $LN2@Assign_rv

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 939  : 		else

	jmp	SHORT $LN1@Assign_rv
$LN2@Assign_rv:

; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);

	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 942  : 			_Right._Bx._Ptr = pointer();

	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN1@Assign_rv:

; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 945  : 		this->_Myres = _Right._Myres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 946  : 		_Right._Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 947  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 887  : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 888  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 890  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 859  : 		{	// construct from [_First, _Last), const pointers

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 860  : 		_DEBUG_RANGE(_First, _Last);

	push	860					; 0000035cH
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z	; std::_Debug_range<char const *>
	add	esp, 16					; 00000010H

; 861  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 862  : 		if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN2@basic_stri

; 863  : 			assign(&*_First, _Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@basic_stri:

; 864  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 781  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 782  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 738  : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 739  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 740  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 724  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 725  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 726  : 		assign(_Right, 0, npos);

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 727  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 684  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 672  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 675  : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 676  : 		_Alproxy.destroy(this->_Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 678  : 		this->_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 679  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 663  : 		{	// construct proxy from _Alval

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 666  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 668  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 669  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Change_alloc, COMDAT
; _this$ = ecx

; 654  : 		{	// replace old allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 655  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 649  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 650  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 651  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 643  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 646  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 517  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 521  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 510  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 514  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 492  : 	_String_val()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 495  : 		_Myres = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 496  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 885  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 859  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 848  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 806  : 		{	// construct by copying base

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 807  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 741  : 		return (_Al.select_on_container_copy_construction());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ; std::allocator<char>::select_on_container_copy_construction
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 736  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 613  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ PROC ; std::allocator<char>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ENDP ; std::allocator<char>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_me@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT
; _this$ = ecx

; 192  : 		{	// cut ties with parent

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 193  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 194  : 		if (_Myproxy != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Orphan_me

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx
$LN3@Orphan_me:

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Orphan_me
	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $LN2@Orphan_me

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx
	jmp	SHORT $LN3@Orphan_me
$LN2@Orphan_me:

; 199  : 
; 200  : 			if (*_Pnext == 0)

	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@Orphan_me

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

	mov	esi, esp
	push	201					; 000000c9H
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Orphan_me:

; 202  : 			*_Pnext = _Mynextiter;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 203  : 			_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@Orphan_me:

; 204  : 			}
; 205  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 206  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_me@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ PROC	; std::_Iterator_base12::_Getpnext, COMDAT
; _this$ = ecx

; 187  : 		{	// get address of remaining iterator chain

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 		return (&_Mynextiter);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4

; 189  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ENDP	; std::_Iterator_base12::_Getpnext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 182  : 		{	// get owning container

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@Getcont
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@Getcont
$LN3@Getcont:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv68[ebp], eax
$LN4@Getcont:
	mov	eax, DWORD PTR tv68[ebp]

; 184  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Clrcont@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Clrcont@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Clrcont, COMDAT
; _this$ = ecx

; 177  : 		{	// disown owning container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 178  : 		_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 179  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Clrcont@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Clrcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$2 = -56						; size = 4
__Parent_proxy$3 = -44					; size = 4
__Lock$4 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 148  : 		{	// adopt this iterator by parent

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 		if (_Parent == 0)

	cmp	DWORD PTR __Parent$[ebp], 0
	jne	SHORT $LN3@Adopt

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 153  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 156  : 		else

	jmp	SHORT $LN4@Adopt
$LN3@Adopt:

; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

	mov	eax, DWORD PTR __Parent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Parent_proxy$3[ebp], ecx

; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Parent_proxy$3[ebp]
	je	SHORT $LN4@Adopt

; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 164  : 				_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$3[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 166  : 				_Parent_proxy->_Myfirstiter = this;

	mov	eax, DWORD PTR __Parent_proxy$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 167  : 				_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$3[ebp]
	mov	DWORD PTR [eax], ecx

; 168  : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@Adopt:

; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;
; 172  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 173  : 			}
; 174  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Adopt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN12@Adopt:
	DD	2
	DD	$LN11@Adopt
$LN11@Adopt:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN8@Adopt
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN9@Adopt
$LN9@Adopt:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
$LN8@Adopt:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$ = -20						; size = 4
_this$ = -8						; size = 4
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 140  : 		{	// destroy the iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 143  : 		_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iterator_b
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Iterator_b:
	DD	1
	DD	$LN4@Iterator_b
$LN4@Iterator_b:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN3@Iterator_b
$LN3@Iterator_b:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Lock$2 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 124  : 		{	// assign an iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN4@operator
	jmp	SHORT $LN3@operator
$LN4@operator:

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@operator

; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 129  : 		else

	jmp	SHORT $LN3@operator
$LN2@operator:

; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 133  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator:

; 136  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN11@operator:
	DD	1
	DD	$LN10@operator
$LN10@operator:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN8@operator
$LN8@operator:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 119  : 		{	// copy an iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 120  : 		*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=

; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 114  : 		{	// construct orphaned iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 115  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 68   : 		{	// construct from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 69   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 604  : 		{	// return end-of-file metacharacter

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 605  : 		return (EOF);

	or	eax, -1

; 606  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 593  : 		{	// test for metacharacter equality

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 594  : 		return (_Left == _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
	mov	al, BYTE PTR tv65[ebp]

; 595  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 587  : 		{	// convert character to metacharacter

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 588  : 		return ((unsigned char)_Ch);

	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	eax, BYTE PTR [eax]

; 589  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 581  : 		{	// convert metacharacter to character

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 582  : 		return ((_Elem)_Meta);

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	al, BYTE PTR [eax]

; 583  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 558  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 559  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 560  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	esi, esp
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 65   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _hypot
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 8
_hypot	PROC						; COMDAT

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 557  :     return _hypot(_X, _Y);

	mov	esi, esp
	sub	esp, 8
	movsd	xmm0, QWORD PTR __Y$[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp___hypot
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 558  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_hypot	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4Features@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4Features@Json@@QAEAAV01@ABV01@@Z PROC		; Json::Features::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cx, WORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4Features@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::Features::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ??0Features@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Features@Json@@QAE@XZ PROC				; Json::Features::Features, COMDAT
; _this$ = ecx

; 22   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1], 0

; 23   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Features@Json@@QAE@XZ ENDP				; Json::Features::Features
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?strictMode@Features@Json@@SA?AV12@XZ
_TEXT	SEGMENT
_features$ = -8						; size = 2
___$ReturnUdt$ = 8					; size = 4
?strictMode@Features@Json@@SA?AV12@XZ PROC		; Json::Features::strictMode, COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 36   :    Features features;

	lea	ecx, DWORD PTR _features$[ebp]
	call	??0Features@Json@@QAE@XZ		; Json::Features::Features

; 37   :    features.allowComments_ = false;

	mov	BYTE PTR _features$[ebp], 0

; 38   :    features.strictRoot_ = true;

	mov	BYTE PTR _features$[ebp+1], 1

; 39   :    return features;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cx, WORD PTR _features$[ebp]
	mov	WORD PTR [eax], cx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 40   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@strictMode
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@strictMode:
	DD	1
	DD	$LN4@strictMode
$LN4@strictMode:
	DD	-8					; fffffff8H
	DD	2
	DD	$LN3@strictMode
$LN3@strictMode:
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
?strictMode@Features@Json@@SA?AV12@XZ ENDP		; Json::Features::strictMode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\евгений\dropbox\projects\selectedtexttranslate\selectedtexttranslate\jsoncpp\src\lib_json\json_reader.cpp
;	COMDAT ?all@Features@Json@@SA?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?all@Features@Json@@SA?AV12@XZ PROC			; Json::Features::all, COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 29   :    return Features();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Features@Json@@QAE@XZ		; Json::Features::Features
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 30   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?all@Features@Json@@SA?AV12@XZ ENDP			; Json::Features::all
_TEXT	ENDS
END
